// Code generated from SQLv1Antlr4.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // SQLv1Antlr4

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type SQLv1Antlr4Parser struct {
	*antlr.BaseParser
}

var SQLv1Antlr4ParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func sqlv1antlr4ParserInit() {
	staticData := &SQLv1Antlr4ParserStaticData
	staticData.LiteralNames = []string{
		"", "'='", "'=='", "'!='", "'<>'", "'<'", "'<='", "'>'", "'>='", "'<<'",
		"'|<<'", "'&'", "'|'", "'||'", "'<|'", "'|>'", "'+'", "'-'", "'~'",
		"'*'", "'/'", "'\\'", "'%'", "';'", "'.'", "','", "'('", "')'", "'?'",
		"':'", "'@'", "'@@'", "'$'", "'\"'", "'''", "'`'", "'{'", "'}'", "'^'",
		"'::'", "'->'", "']'", "'['",
	}
	staticData.SymbolicNames = []string{
		"", "EQUALS", "EQUALS2", "NOT_EQUALS", "NOT_EQUALS2", "LESS", "LESS_OR_EQ",
		"GREATER", "GREATER_OR_EQ", "SHIFT_LEFT", "ROT_LEFT", "AMPERSAND", "PIPE",
		"DOUBLE_PIPE", "STRUCT_OPEN", "STRUCT_CLOSE", "PLUS", "MINUS", "TILDA",
		"ASTERISK", "SLASH", "BACKSLASH", "PERCENT", "SEMICOLON", "DOT", "COMMA",
		"LPAREN", "RPAREN", "QUESTION", "COLON", "COMMAT", "DOUBLE_COMMAT",
		"DOLLAR", "QUOTE_DOUBLE", "QUOTE_SINGLE", "BACKTICK", "LBRACE_CURLY",
		"RBRACE_CURLY", "CARET", "NAMESPACE", "ARROW", "RBRACE_SQUARE", "LBRACE_SQUARE",
		"ABORT", "ACTION", "ADD", "AFTER", "ALL", "ALTER", "ANALYZE", "AND",
		"ANSI", "ANY", "ARRAY", "AS", "ASC", "ASSUME", "ASYMMETRIC", "ASYNC",
		"AT", "ATTACH", "ATTRIBUTES", "AUTOINCREMENT", "AUTOMAP", "BACKUP",
		"COLLECTION", "BEFORE", "BEGIN", "BERNOULLI", "BETWEEN", "BITCAST",
		"BY", "CALLABLE", "CASCADE", "CASE", "CAST", "CHANGEFEED", "CHECK",
		"CLASSIFIER", "COLLATE", "COLUMN", "COLUMNS", "COMMIT", "COMPACT", "CONDITIONAL",
		"CONFLICT", "CONNECT", "CONSTRAINT", "CONSUMER", "COVER", "CREATE",
		"CROSS", "CUBE", "CURRENT", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP",
		"DATA", "DATABASE", "DECIMAL", "DECLARE", "DEFAULT", "DEFERRABLE", "DEFERRED",
		"DEFINE", "DELETE", "DESC", "DESCRIBE", "DETACH", "DICT", "DIRECTORY",
		"DISABLE", "DISCARD", "DISTINCT", "DO", "DROP", "EACH", "ELSE", "EMPTY",
		"EMPTY_ACTION", "ENCRYPTED", "END", "ENUM", "ERASE", "ERROR", "ESCAPE",
		"EVALUATE", "EXCEPT", "EXCLUDE", "EXCLUSION", "EXCLUSIVE", "EXISTS",
		"EXPLAIN", "EXPORT", "EXTERNAL", "FAIL", "FALSE", "FAMILY", "FILTER",
		"FIRST", "FLATTEN", "FLOW", "FOLLOWING", "FOR", "FOREIGN", "FROM", "FULL",
		"FUNCTION", "GLOB", "GLOBAL", "GRANT", "GROUP", "GROUPING", "GROUPS",
		"HASH", "HAVING", "HOP", "IF", "IGNORE", "ILIKE", "IMMEDIATE", "IMPORT",
		"IN", "INCREMENTAL", "INDEX", "INDEXED", "INHERITS", "INITIAL", "INITIALLY",
		"INNER", "INSERT", "INSTEAD", "INTERSECT", "INTO", "IS", "ISNULL", "JOIN",
		"JSON_EXISTS", "JSON_QUERY", "JSON_VALUE", "KEY", "LAST", "LEFT", "LEGACY",
		"LIKE", "LIMIT", "LIST", "LOCAL", "MANAGE", "MATCH", "MATCHES", "MATCH_RECOGNIZE",
		"MEASURES", "MICROSECONDS", "MILLISECONDS", "MODIFY", "NANOSECONDS",
		"NATURAL", "NEXT", "NO", "NOT", "NOTNULL", "NULL", "NULLS", "OBJECT",
		"OF", "OFFSET", "OMIT", "ON", "ONE", "ONLY", "OPTION", "OPTIONAL", "OR",
		"ORDER", "OTHERS", "OUTER", "OVER", "PARALLEL", "PARTITION", "PASSING",
		"PASSWORD", "PAST", "PATTERN", "PER", "PERMUTE", "PLAN", "POOL", "PRAGMA",
		"PRECEDING", "PRESORT", "PRIMARY", "PRIVILEGES", "PROCESS", "QUEUE",
		"RAISE", "RANGE", "REDUCE", "REFERENCES", "REGEXP", "REINDEX", "RELEASE",
		"REMOVE", "RENAME", "REPEATABLE", "REPLACE", "REPLICATION", "RESET",
		"RESOURCE", "RESPECT", "RESTORE", "RESTRICT", "RESULT", "RETURN", "RETURNING",
		"REVERT", "REVOKE", "RIGHT", "RLIKE", "ROLLBACK", "ROLLUP", "ROW", "ROWS",
		"SAMPLE", "SAVEPOINT", "SCHEMA", "SECONDS", "SEEK", "SELECT", "SEMI",
		"SET", "SETS", "SHOW", "TSKIP", "SOURCE", "STREAM", "STRUCT", "SUBQUERY",
		"SUBSET", "SYMBOLS", "SYMMETRIC", "SYNC", "SYSTEM", "TABLE", "TABLES",
		"TABLESAMPLE", "TABLESTORE", "TAGGED", "TEMP", "TEMPORARY", "THEN",
		"TIES", "TO", "TOPIC", "TRANSACTION", "TRIGGER", "TRUE", "TUPLE", "TYPE",
		"UNBOUNDED", "UNCONDITIONAL", "UNION", "UNIQUE", "UNKNOWN", "UNMATCHED",
		"UPDATE", "UPSERT", "USE", "USER", "USING", "VACUUM", "VALUES", "VARIANT",
		"VIEW", "VIRTUAL", "WHEN", "WHERE", "WINDOW", "WITH", "WITHOUT", "WRAPPER",
		"XOR", "STRING_VALUE", "ID_PLAIN", "ID_QUOTED", "DIGITS", "INTEGER_VALUE",
		"REAL", "BLOB", "TQ", "TU", "TE", "TR", "TY", "WS", "COMMENT",
	}
	staticData.RuleNames = []string{
		"sql_query", "sql_stmt_list", "ansi_sql_stmt_list", "lambda_body", "lambda_stmt",
		"sql_stmt", "sql_stmt_core", "expr", "or_subexpr", "and_subexpr", "xor_subexpr",
		"distinct_from_op", "cond_expr", "match_op", "eq_subexpr", "shift_right",
		"rot_right", "double_question", "neq_subexpr", "bit_subexpr", "add_subexpr",
		"mul_subexpr", "con_subexpr", "unary_op", "unary_subexpr_suffix", "unary_casual_subexpr",
		"in_unary_casual_subexpr", "unary_subexpr", "in_unary_subexpr", "list_literal",
		"expr_dict_list", "dict_literal", "expr_struct_list", "struct_literal",
		"atom_expr", "in_atom_expr", "cast_expr", "bitcast_expr", "exists_expr",
		"case_expr", "lambda", "in_expr", "json_api_expr", "jsonpath_spec",
		"json_variable_name", "json_variable", "json_variables", "json_common_args",
		"json_case_handler", "json_value", "json_exists_handler", "json_exists",
		"json_query_wrapper", "json_query_handler", "json_query", "smart_parenthesis",
		"expr_list", "pure_column_list", "pure_column_or_named", "pure_column_or_named_list",
		"column_name", "without_column_name", "column_list", "without_column_list",
		"named_expr", "named_expr_list", "invoke_expr", "invoke_expr_tail",
		"using_call_expr", "key_expr", "when_expr", "literal_value", "bind_parameter",
		"opt_bind_parameter", "bind_parameter_list", "named_bind_parameter",
		"named_bind_parameter_list", "signed_number", "type_name_simple", "integer_or_bind",
		"type_name_tag", "struct_arg", "struct_arg_positional", "variant_arg",
		"callable_arg", "callable_arg_list", "type_name_decimal", "type_name_optional",
		"type_name_tuple", "type_name_struct", "type_name_variant", "type_name_list",
		"type_name_stream", "type_name_flow", "type_name_dict", "type_name_set",
		"type_name_enum", "type_name_resource", "type_name_tagged", "type_name_callable",
		"type_name_composite", "type_name", "type_name_or_bind", "value_constructor_literal",
		"value_constructor", "declare_stmt", "module_path", "import_stmt", "export_stmt",
		"call_action", "inline_action", "do_stmt", "pragma_stmt", "pragma_value",
		"sort_specification", "sort_specification_list", "select_stmt", "select_unparenthesized_stmt",
		"select_kind_parenthesis", "select_op", "select_kind_partial", "select_kind",
		"process_core", "external_call_param", "external_call_settings", "reduce_core",
		"opt_set_quantifier", "select_core", "row_pattern_recognition_clause",
		"row_pattern_rows_per_match", "row_pattern_empty_match_handling", "row_pattern_measures",
		"row_pattern_measure_list", "row_pattern_measure_definition", "row_pattern_common_syntax",
		"row_pattern_skip_to", "row_pattern_skip_to_variable_name", "row_pattern_initial_or_seek",
		"row_pattern", "row_pattern_term", "row_pattern_factor", "row_pattern_quantifier",
		"row_pattern_primary", "row_pattern_primary_variable_name", "row_pattern_permute",
		"row_pattern_subset_clause", "row_pattern_subset_list", "row_pattern_subset_item",
		"row_pattern_subset_item_variable_name", "row_pattern_subset_rhs", "row_pattern_subset_rhs_variable_name",
		"row_pattern_definition_list", "row_pattern_definition", "row_pattern_definition_variable_name",
		"row_pattern_definition_search_condition", "search_condition", "row_pattern_variable_name",
		"order_by_clause", "ext_order_by_clause", "group_by_clause", "grouping_element_list",
		"grouping_element", "ordinary_grouping_set", "ordinary_grouping_set_list",
		"rollup_list", "cube_list", "grouping_sets_specification", "hopping_window_specification",
		"result_column", "join_source", "named_column", "flatten_by_arg", "flatten_source",
		"named_single_source", "single_source", "sample_clause", "tablesample_clause",
		"sampling_mode", "repeatable_clause", "join_op", "join_constraint",
		"returning_columns_list", "into_table_stmt", "into_values_source", "values_stmt",
		"values_source", "values_source_row_list", "values_source_row", "simple_values_source",
		"create_external_data_source_stmt", "alter_external_data_source_stmt",
		"alter_external_data_source_action", "drop_external_data_source_stmt",
		"create_view_stmt", "drop_view_stmt", "upsert_object_stmt", "create_object_stmt",
		"create_object_features", "alter_object_stmt", "alter_object_features",
		"drop_object_stmt", "drop_object_features", "object_feature_value",
		"object_feature_kv", "object_feature_flag", "object_feature", "object_features",
		"object_type_ref", "create_table_stmt", "create_table_entry", "create_backup_collection_stmt",
		"alter_backup_collection_stmt", "drop_backup_collection_stmt", "database_or_table_list",
		"table_list", "alter_backup_collection_actions", "alter_backup_collection_action",
		"alter_backup_collection_entries", "alter_backup_collection_entry",
		"backup_collection", "backup_collection_settings", "backup_collection_settings_entry",
		"backup_stmt", "restore_stmt", "table_inherits", "table_partition_by",
		"with_table_settings", "table_tablestore", "table_settings_entry", "table_as_source",
		"alter_table_stmt", "alter_table_action", "alter_external_table_stmt",
		"alter_external_table_action", "alter_table_store_stmt", "alter_table_store_action",
		"alter_table_add_column", "alter_table_drop_column", "alter_table_alter_column",
		"alter_table_alter_column_drop_not_null", "alter_table_add_column_family",
		"alter_table_alter_column_family", "alter_table_set_table_setting_uncompat",
		"alter_table_set_table_setting_compat", "alter_table_reset_table_setting",
		"alter_table_add_index", "alter_table_drop_index", "alter_table_rename_to",
		"alter_table_rename_index_to", "alter_table_add_changefeed", "alter_table_alter_changefeed",
		"alter_table_drop_changefeed", "alter_table_alter_index", "column_schema",
		"family_relation", "opt_column_constraints", "column_order_by_specification",
		"table_constraint", "table_index", "table_index_type", "global_index",
		"local_index", "index_subtype", "with_index_settings", "index_setting_entry",
		"index_setting_value", "changefeed", "changefeed_settings", "changefeed_settings_entry",
		"changefeed_setting_value", "changefeed_alter_settings", "alter_table_setting_entry",
		"table_setting_value", "family_entry", "family_settings", "family_settings_entry",
		"family_setting_value", "split_boundaries", "literal_value_list", "alter_table_alter_index_action",
		"drop_table_stmt", "create_user_stmt", "alter_user_stmt", "create_group_stmt",
		"alter_group_stmt", "drop_role_stmt", "role_name", "create_user_option",
		"grant_permissions_stmt", "revoke_permissions_stmt", "permission_id",
		"permission_name", "permission_name_target", "create_resource_pool_stmt",
		"alter_resource_pool_stmt", "alter_resource_pool_action", "drop_resource_pool_stmt",
		"create_resource_pool_classifier_stmt", "alter_resource_pool_classifier_stmt",
		"alter_resource_pool_classifier_action", "drop_resource_pool_classifier_stmt",
		"create_replication_stmt", "replication_target", "replication_settings",
		"replication_settings_entry", "alter_replication_stmt", "alter_replication_action",
		"alter_replication_set_setting", "drop_replication_stmt", "action_or_subquery_args",
		"define_action_or_subquery_stmt", "define_action_or_subquery_body",
		"if_stmt", "for_stmt", "table_ref", "table_key", "table_arg", "table_hints",
		"table_hint", "object_ref", "simple_table_ref_core", "simple_table_ref",
		"into_simple_table_ref", "delete_stmt", "update_stmt", "set_clause_choice",
		"set_clause_list", "set_clause", "set_target", "multiple_column_assignment",
		"set_target_list", "create_topic_stmt", "create_topic_entries", "create_topic_entry",
		"with_topic_settings", "alter_topic_stmt", "alter_topic_action", "alter_topic_add_consumer",
		"topic_create_consumer_entry", "alter_topic_alter_consumer", "alter_topic_alter_consumer_entry",
		"alter_topic_drop_consumer", "topic_alter_consumer_set", "topic_alter_consumer_reset",
		"alter_topic_set_settings", "alter_topic_reset_settings", "drop_topic_stmt",
		"topic_settings", "topic_settings_entry", "topic_setting_value", "topic_consumer_with_settings",
		"topic_consumer_settings", "topic_consumer_settings_entry", "topic_consumer_setting_value",
		"topic_ref", "topic_consumer_ref", "null_treatment", "filter_clause",
		"window_name_or_specification", "window_name", "window_clause", "window_definition_list",
		"window_definition", "new_window_name", "window_specification", "window_specification_details",
		"existing_window_name", "window_partition_clause", "window_order_clause",
		"window_frame_clause", "window_frame_units", "window_frame_extent",
		"window_frame_between", "window_frame_bound", "window_frame_exclusion",
		"use_stmt", "subselect_stmt", "named_nodes_stmt", "commit_stmt", "rollback_stmt",
		"analyze_table", "analyze_table_list", "analyze_stmt", "identifier",
		"id", "id_schema", "id_expr", "id_expr_in", "id_window", "id_table",
		"id_without", "id_hint", "id_as_compat", "an_id", "an_id_or_type", "an_id_schema",
		"an_id_expr", "an_id_expr_in", "an_id_window", "an_id_table", "an_id_without",
		"an_id_hint", "an_id_pure", "an_id_as_compat", "view_name", "opt_id_prefix",
		"cluster_expr", "id_or_type", "opt_id_prefix_or_type", "id_or_at", "id_table_or_type",
		"id_table_or_at", "keyword", "keyword_expr_uncompat", "keyword_table_uncompat",
		"keyword_select_uncompat", "keyword_alter_uncompat", "keyword_in_uncompat",
		"keyword_window_uncompat", "keyword_hint_uncompat", "keyword_as_compat",
		"keyword_compat", "type_id", "bool_value", "real", "integer",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 335, 4477, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2,
		185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7,
		189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2,
		194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7,
		198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2,
		203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7,
		207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2,
		212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7,
		216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2,
		221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7,
		225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2,
		230, 7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7,
		234, 2, 235, 7, 235, 2, 236, 7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 2,
		239, 7, 239, 2, 240, 7, 240, 2, 241, 7, 241, 2, 242, 7, 242, 2, 243, 7,
		243, 2, 244, 7, 244, 2, 245, 7, 245, 2, 246, 7, 246, 2, 247, 7, 247, 2,
		248, 7, 248, 2, 249, 7, 249, 2, 250, 7, 250, 2, 251, 7, 251, 2, 252, 7,
		252, 2, 253, 7, 253, 2, 254, 7, 254, 2, 255, 7, 255, 2, 256, 7, 256, 2,
		257, 7, 257, 2, 258, 7, 258, 2, 259, 7, 259, 2, 260, 7, 260, 2, 261, 7,
		261, 2, 262, 7, 262, 2, 263, 7, 263, 2, 264, 7, 264, 2, 265, 7, 265, 2,
		266, 7, 266, 2, 267, 7, 267, 2, 268, 7, 268, 2, 269, 7, 269, 2, 270, 7,
		270, 2, 271, 7, 271, 2, 272, 7, 272, 2, 273, 7, 273, 2, 274, 7, 274, 2,
		275, 7, 275, 2, 276, 7, 276, 2, 277, 7, 277, 2, 278, 7, 278, 2, 279, 7,
		279, 2, 280, 7, 280, 2, 281, 7, 281, 2, 282, 7, 282, 2, 283, 7, 283, 2,
		284, 7, 284, 2, 285, 7, 285, 2, 286, 7, 286, 2, 287, 7, 287, 2, 288, 7,
		288, 2, 289, 7, 289, 2, 290, 7, 290, 2, 291, 7, 291, 2, 292, 7, 292, 2,
		293, 7, 293, 2, 294, 7, 294, 2, 295, 7, 295, 2, 296, 7, 296, 2, 297, 7,
		297, 2, 298, 7, 298, 2, 299, 7, 299, 2, 300, 7, 300, 2, 301, 7, 301, 2,
		302, 7, 302, 2, 303, 7, 303, 2, 304, 7, 304, 2, 305, 7, 305, 2, 306, 7,
		306, 2, 307, 7, 307, 2, 308, 7, 308, 2, 309, 7, 309, 2, 310, 7, 310, 2,
		311, 7, 311, 2, 312, 7, 312, 2, 313, 7, 313, 2, 314, 7, 314, 2, 315, 7,
		315, 2, 316, 7, 316, 2, 317, 7, 317, 2, 318, 7, 318, 2, 319, 7, 319, 2,
		320, 7, 320, 2, 321, 7, 321, 2, 322, 7, 322, 2, 323, 7, 323, 2, 324, 7,
		324, 2, 325, 7, 325, 2, 326, 7, 326, 2, 327, 7, 327, 2, 328, 7, 328, 2,
		329, 7, 329, 2, 330, 7, 330, 2, 331, 7, 331, 2, 332, 7, 332, 2, 333, 7,
		333, 2, 334, 7, 334, 2, 335, 7, 335, 2, 336, 7, 336, 2, 337, 7, 337, 2,
		338, 7, 338, 2, 339, 7, 339, 2, 340, 7, 340, 2, 341, 7, 341, 2, 342, 7,
		342, 2, 343, 7, 343, 2, 344, 7, 344, 2, 345, 7, 345, 2, 346, 7, 346, 2,
		347, 7, 347, 2, 348, 7, 348, 2, 349, 7, 349, 2, 350, 7, 350, 2, 351, 7,
		351, 2, 352, 7, 352, 2, 353, 7, 353, 2, 354, 7, 354, 2, 355, 7, 355, 2,
		356, 7, 356, 2, 357, 7, 357, 2, 358, 7, 358, 2, 359, 7, 359, 2, 360, 7,
		360, 2, 361, 7, 361, 2, 362, 7, 362, 2, 363, 7, 363, 2, 364, 7, 364, 2,
		365, 7, 365, 2, 366, 7, 366, 2, 367, 7, 367, 2, 368, 7, 368, 2, 369, 7,
		369, 2, 370, 7, 370, 2, 371, 7, 371, 2, 372, 7, 372, 2, 373, 7, 373, 2,
		374, 7, 374, 2, 375, 7, 375, 2, 376, 7, 376, 2, 377, 7, 377, 2, 378, 7,
		378, 2, 379, 7, 379, 2, 380, 7, 380, 2, 381, 7, 381, 2, 382, 7, 382, 2,
		383, 7, 383, 2, 384, 7, 384, 2, 385, 7, 385, 2, 386, 7, 386, 2, 387, 7,
		387, 2, 388, 7, 388, 2, 389, 7, 389, 2, 390, 7, 390, 2, 391, 7, 391, 2,
		392, 7, 392, 2, 393, 7, 393, 2, 394, 7, 394, 2, 395, 7, 395, 2, 396, 7,
		396, 2, 397, 7, 397, 2, 398, 7, 398, 2, 399, 7, 399, 2, 400, 7, 400, 2,
		401, 7, 401, 2, 402, 7, 402, 2, 403, 7, 403, 2, 404, 7, 404, 2, 405, 7,
		405, 2, 406, 7, 406, 2, 407, 7, 407, 2, 408, 7, 408, 2, 409, 7, 409, 2,
		410, 7, 410, 2, 411, 7, 411, 2, 412, 7, 412, 2, 413, 7, 413, 2, 414, 7,
		414, 2, 415, 7, 415, 2, 416, 7, 416, 2, 417, 7, 417, 2, 418, 7, 418, 2,
		419, 7, 419, 2, 420, 7, 420, 2, 421, 7, 421, 2, 422, 7, 422, 2, 423, 7,
		423, 2, 424, 7, 424, 2, 425, 7, 425, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 3, 0,
		858, 8, 0, 1, 1, 5, 1, 861, 8, 1, 10, 1, 12, 1, 864, 9, 1, 1, 1, 1, 1,
		4, 1, 868, 8, 1, 11, 1, 12, 1, 869, 1, 1, 5, 1, 873, 8, 1, 10, 1, 12, 1,
		876, 9, 1, 1, 1, 5, 1, 879, 8, 1, 10, 1, 12, 1, 882, 9, 1, 1, 1, 1, 1,
		1, 2, 5, 2, 887, 8, 2, 10, 2, 12, 2, 890, 9, 2, 1, 2, 1, 2, 1, 3, 5, 3,
		895, 8, 3, 10, 3, 12, 3, 898, 9, 3, 1, 3, 1, 3, 4, 3, 902, 8, 3, 11, 3,
		12, 3, 903, 5, 3, 906, 8, 3, 10, 3, 12, 3, 909, 9, 3, 1, 3, 1, 3, 1, 3,
		5, 3, 914, 8, 3, 10, 3, 12, 3, 917, 9, 3, 1, 4, 1, 4, 3, 4, 921, 8, 4,
		1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 930, 8, 5, 3, 5, 932, 8,
		5, 1, 5, 1, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1,
		6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1,
		6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1,
		6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1,
		6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 992,
		8, 6, 1, 7, 1, 7, 1, 7, 5, 7, 997, 8, 7, 10, 7, 12, 7, 1000, 9, 7, 1, 7,
		3, 7, 1003, 8, 7, 1, 8, 1, 8, 1, 8, 5, 8, 1008, 8, 8, 10, 8, 12, 8, 1011,
		9, 8, 1, 9, 1, 9, 1, 9, 5, 9, 1016, 8, 9, 10, 9, 12, 9, 1019, 9, 9, 1,
		10, 1, 10, 3, 10, 1023, 8, 10, 1, 11, 1, 11, 3, 11, 1027, 8, 11, 1, 11,
		1, 11, 1, 11, 1, 12, 3, 12, 1033, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3,
		12, 1039, 8, 12, 1, 12, 3, 12, 1042, 8, 12, 1, 12, 1, 12, 3, 12, 1046,
		8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 1054, 8, 12, 1,
		12, 1, 12, 3, 12, 1058, 8, 12, 1, 12, 3, 12, 1061, 8, 12, 1, 12, 1, 12,
		3, 12, 1065, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1,
		12, 1, 12, 3, 12, 1076, 8, 12, 1, 12, 4, 12, 1079, 8, 12, 11, 12, 12, 12,
		1080, 3, 12, 1083, 8, 12, 1, 13, 1, 13, 1, 14, 1, 14, 1, 14, 5, 14, 1090,
		8, 14, 10, 14, 12, 14, 1093, 9, 14, 1, 15, 1, 15, 1, 15, 1, 16, 1, 16,
		1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1,
		18, 1, 18, 1, 18, 3, 18, 1113, 8, 18, 1, 18, 5, 18, 1116, 8, 18, 10, 18,
		12, 18, 1119, 9, 18, 1, 18, 1, 18, 1, 18, 1, 18, 4, 18, 1125, 8, 18, 11,
		18, 12, 18, 1126, 3, 18, 1129, 8, 18, 1, 19, 1, 19, 1, 19, 5, 19, 1134,
		8, 19, 10, 19, 12, 19, 1137, 9, 19, 1, 20, 1, 20, 1, 20, 5, 20, 1142, 8,
		20, 10, 20, 12, 20, 1145, 9, 20, 1, 21, 1, 21, 1, 21, 5, 21, 1150, 8, 21,
		10, 21, 12, 21, 1153, 9, 21, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 1159, 8,
		22, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 1169,
		8, 24, 3, 24, 1171, 8, 24, 5, 24, 1173, 8, 24, 10, 24, 12, 24, 1176, 9,
		24, 1, 24, 1, 24, 3, 24, 1180, 8, 24, 1, 25, 1, 25, 3, 25, 1184, 8, 25,
		1, 25, 1, 25, 1, 26, 1, 26, 3, 26, 1190, 8, 26, 1, 26, 1, 26, 1, 27, 1,
		27, 3, 27, 1196, 8, 27, 1, 28, 1, 28, 3, 28, 1200, 8, 28, 1, 29, 1, 29,
		3, 29, 1204, 8, 29, 1, 29, 3, 29, 1207, 8, 29, 1, 29, 1, 29, 1, 30, 1,
		30, 1, 30, 3, 30, 1214, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1220,
		8, 30, 5, 30, 1222, 8, 30, 10, 30, 12, 30, 1225, 9, 30, 1, 31, 1, 31, 3,
		31, 1229, 8, 31, 1, 31, 3, 31, 1232, 8, 31, 1, 31, 1, 31, 1, 32, 1, 32,
		1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 5, 32, 1244, 8, 32, 10, 32, 12,
		32, 1247, 9, 32, 1, 33, 1, 33, 3, 33, 1251, 8, 33, 1, 33, 3, 33, 1254,
		8, 33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1,
		34, 1, 34, 1, 34, 3, 34, 1268, 8, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34,
		3, 34, 1275, 8, 34, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1,
		35, 1, 35, 3, 35, 1286, 8, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35,
		1, 35, 1, 35, 1, 35, 3, 35, 1297, 8, 35, 1, 36, 1, 36, 1, 36, 1, 36, 1,
		36, 1, 36, 1, 36, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 38,
		1, 38, 1, 38, 1, 38, 3, 38, 1317, 8, 38, 1, 38, 1, 38, 1, 39, 1, 39, 3,
		39, 1323, 8, 39, 1, 39, 4, 39, 1326, 8, 39, 11, 39, 12, 39, 1327, 1, 39,
		1, 39, 3, 39, 1332, 8, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40, 1, 40, 1,
		40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 1346, 8, 40, 3, 40, 1348,
		8, 40, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 3, 42, 1355, 8, 42, 1, 43, 1,
		43, 1, 44, 1, 44, 3, 44, 1361, 8, 44, 1, 45, 1, 45, 1, 45, 1, 45, 1, 46,
		1, 46, 1, 46, 5, 46, 1370, 8, 46, 10, 46, 12, 46, 1373, 9, 46, 1, 47, 1,
		47, 1, 47, 1, 47, 1, 47, 3, 47, 1380, 8, 47, 1, 48, 1, 48, 1, 48, 1, 48,
		3, 48, 1386, 8, 48, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 1393, 8,
		49, 1, 49, 1, 49, 1, 49, 1, 49, 5, 49, 1399, 8, 49, 10, 49, 12, 49, 1402,
		9, 49, 1, 49, 1, 49, 1, 50, 1, 50, 1, 50, 1, 50, 1, 51, 1, 51, 1, 51, 1,
		51, 3, 51, 1414, 8, 51, 1, 51, 1, 51, 1, 52, 1, 52, 3, 52, 1420, 8, 52,
		1, 52, 1, 52, 3, 52, 1424, 8, 52, 1, 52, 3, 52, 1427, 8, 52, 3, 52, 1429,
		8, 52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1437, 8, 53, 1,
		54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 1445, 8, 54, 1, 54, 1, 54,
		1, 54, 1, 54, 3, 54, 1451, 8, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 1457,
		8, 54, 1, 54, 1, 54, 1, 55, 1, 55, 3, 55, 1463, 8, 55, 1, 55, 3, 55, 1466,
		8, 55, 1, 55, 1, 55, 1, 56, 1, 56, 1, 56, 5, 56, 1473, 8, 56, 10, 56, 12,
		56, 1476, 9, 56, 1, 57, 1, 57, 1, 57, 1, 57, 5, 57, 1482, 8, 57, 10, 57,
		12, 57, 1485, 9, 57, 1, 57, 1, 57, 1, 58, 1, 58, 3, 58, 1491, 8, 58, 1,
		59, 1, 59, 1, 59, 1, 59, 5, 59, 1497, 8, 59, 10, 59, 12, 59, 1500, 9, 59,
		1, 59, 1, 59, 1, 60, 1, 60, 1, 60, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 3,
		61, 1512, 8, 61, 1, 62, 1, 62, 1, 62, 5, 62, 1517, 8, 62, 10, 62, 12, 62,
		1520, 9, 62, 1, 62, 3, 62, 1523, 8, 62, 1, 63, 1, 63, 1, 63, 5, 63, 1528,
		8, 63, 10, 63, 12, 63, 1531, 9, 63, 1, 63, 3, 63, 1534, 8, 63, 1, 64, 1,
		64, 1, 64, 3, 64, 1539, 8, 64, 1, 65, 1, 65, 1, 65, 5, 65, 1544, 8, 65,
		10, 65, 12, 65, 1547, 9, 65, 1, 66, 1, 66, 1, 66, 1, 66, 3, 66, 1553, 8,
		66, 1, 66, 3, 66, 1556, 8, 66, 1, 66, 1, 66, 1, 66, 1, 67, 1, 67, 3, 67,
		1563, 8, 67, 1, 67, 1, 67, 3, 67, 1567, 8, 67, 1, 68, 1, 68, 1, 68, 1,
		68, 1, 68, 1, 68, 1, 68, 1, 68, 3, 68, 1577, 8, 68, 1, 68, 1, 68, 1, 69,
		1, 69, 1, 69, 1, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 71, 1, 71, 1,
		71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 3, 71, 1600, 8, 71,
		1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 1606, 8, 72, 1, 73, 1, 73, 3, 73, 1610,
		8, 73, 1, 74, 1, 74, 1, 74, 5, 74, 1615, 8, 74, 10, 74, 12, 74, 1618, 9,
		74, 1, 75, 1, 75, 1, 75, 3, 75, 1623, 8, 75, 1, 76, 1, 76, 1, 76, 5, 76,
		1628, 8, 76, 10, 76, 12, 76, 1631, 9, 76, 1, 77, 3, 77, 1634, 8, 77, 1,
		77, 1, 77, 3, 77, 1638, 8, 77, 1, 78, 1, 78, 1, 79, 1, 79, 3, 79, 1644,
		8, 79, 1, 80, 1, 80, 1, 80, 3, 80, 1649, 8, 80, 1, 81, 1, 81, 1, 81, 1,
		81, 1, 82, 1, 82, 1, 82, 3, 82, 1658, 8, 82, 1, 82, 3, 82, 1661, 8, 82,
		1, 82, 1, 82, 1, 82, 1, 82, 3, 82, 1667, 8, 82, 1, 83, 1, 83, 1, 83, 3,
		83, 1672, 8, 83, 1, 83, 1, 83, 1, 84, 1, 84, 1, 84, 1, 84, 3, 84, 1680,
		8, 84, 1, 85, 1, 85, 1, 85, 5, 85, 1685, 8, 85, 10, 85, 12, 85, 1688, 9,
		85, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 87, 1, 87, 1, 87,
		1, 87, 1, 87, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 5, 88, 1707, 8, 88, 10,
		88, 12, 88, 1710, 9, 88, 1, 88, 3, 88, 1713, 8, 88, 3, 88, 1715, 8, 88,
		1, 88, 1, 88, 3, 88, 1719, 8, 88, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 5,
		89, 1726, 8, 89, 10, 89, 12, 89, 1729, 9, 89, 1, 89, 3, 89, 1732, 8, 89,
		3, 89, 1734, 8, 89, 1, 89, 1, 89, 3, 89, 1738, 8, 89, 1, 90, 1, 90, 1,
		90, 1, 90, 1, 90, 5, 90, 1745, 8, 90, 10, 90, 12, 90, 1748, 9, 90, 1, 90,
		3, 90, 1751, 8, 90, 1, 90, 1, 90, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1,
		92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 94,
		1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 95, 1, 95, 1, 95, 1, 95, 1,
		95, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 5, 96, 1787, 8, 96, 10, 96, 12,
		96, 1790, 9, 96, 1, 96, 3, 96, 1793, 8, 96, 1, 96, 1, 96, 1, 97, 1, 97,
		1, 97, 1, 97, 1, 97, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98, 1,
		99, 1, 99, 1, 99, 1, 99, 3, 99, 1813, 8, 99, 1, 99, 3, 99, 1816, 8, 99,
		1, 99, 1, 99, 1, 99, 1, 99, 3, 99, 1822, 8, 99, 1, 99, 1, 99, 1, 99, 1,
		99, 1, 99, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100,
		1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 3, 100, 1842, 8, 100, 1, 100, 5,
		100, 1845, 8, 100, 10, 100, 12, 100, 1848, 9, 100, 1, 101, 1, 101, 1, 101,
		3, 101, 1853, 8, 101, 1, 101, 5, 101, 1856, 8, 101, 10, 101, 12, 101, 1859,
		9, 101, 3, 101, 1861, 8, 101, 1, 102, 1, 102, 3, 102, 1865, 8, 102, 1,
		103, 1, 103, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1,
		104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1,
		104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 3, 104, 1892, 8, 104,
		1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 3, 105, 1900, 8, 105, 1,
		106, 3, 106, 1903, 8, 106, 1, 106, 1, 106, 1, 106, 5, 106, 1908, 8, 106,
		10, 106, 12, 106, 1911, 9, 106, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107,
		1, 108, 1, 108, 1, 108, 1, 109, 1, 109, 3, 109, 1923, 8, 109, 1, 109, 1,
		109, 3, 109, 1927, 8, 109, 1, 109, 1, 109, 1, 110, 1, 110, 1, 110, 1, 110,
		1, 110, 1, 111, 1, 111, 1, 111, 3, 111, 1939, 8, 111, 1, 112, 1, 112, 1,
		112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 5, 112, 1950, 8, 112,
		10, 112, 12, 112, 1953, 9, 112, 1, 112, 1, 112, 3, 112, 1957, 8, 112, 1,
		113, 1, 113, 1, 113, 1, 113, 1, 113, 3, 113, 1964, 8, 113, 1, 114, 1, 114,
		3, 114, 1968, 8, 114, 1, 115, 1, 115, 1, 115, 5, 115, 1973, 8, 115, 10,
		115, 12, 115, 1976, 9, 115, 1, 116, 1, 116, 1, 116, 1, 116, 5, 116, 1982,
		8, 116, 10, 116, 12, 116, 1985, 9, 116, 1, 117, 1, 117, 1, 117, 1, 117,
		5, 117, 1991, 8, 117, 10, 117, 12, 117, 1994, 9, 117, 1, 118, 1, 118, 1,
		118, 1, 118, 1, 118, 3, 118, 2001, 8, 118, 1, 119, 1, 119, 3, 119, 2005,
		8, 119, 1, 119, 1, 119, 3, 119, 2009, 8, 119, 1, 120, 1, 120, 1, 120, 1,
		120, 1, 120, 3, 120, 2016, 8, 120, 3, 120, 2018, 8, 120, 1, 121, 3, 121,
		2021, 8, 121, 1, 121, 1, 121, 1, 121, 3, 121, 2026, 8, 121, 1, 121, 1,
		121, 1, 121, 3, 121, 2031, 8, 121, 1, 122, 1, 122, 3, 122, 2035, 8, 122,
		1, 122, 1, 122, 1, 122, 5, 122, 2040, 8, 122, 10, 122, 12, 122, 2043, 9,
		122, 1, 122, 1, 122, 1, 122, 1, 122, 3, 122, 2049, 8, 122, 1, 122, 1, 122,
		3, 122, 2053, 8, 122, 1, 122, 1, 122, 3, 122, 2057, 8, 122, 1, 122, 1,
		122, 3, 122, 2061, 8, 122, 1, 122, 1, 122, 3, 122, 2065, 8, 122, 3, 122,
		2067, 8, 122, 1, 123, 1, 123, 1, 123, 1, 123, 1, 124, 1, 124, 1, 124, 5,
		124, 2076, 8, 124, 10, 124, 12, 124, 2079, 9, 124, 1, 125, 1, 125, 1, 125,
		1, 125, 5, 125, 2085, 8, 125, 10, 125, 12, 125, 2088, 9, 125, 1, 125, 1,
		125, 3, 125, 2092, 8, 125, 1, 125, 1, 125, 1, 125, 1, 125, 3, 125, 2098,
		8, 125, 1, 125, 1, 125, 1, 125, 3, 125, 2103, 8, 125, 1, 125, 1, 125, 3,
		125, 2107, 8, 125, 1, 125, 1, 125, 3, 125, 2111, 8, 125, 1, 125, 1, 125,
		3, 125, 2115, 8, 125, 1, 126, 3, 126, 2118, 8, 126, 1, 127, 1, 127, 3,
		127, 2122, 8, 127, 1, 127, 1, 127, 3, 127, 2126, 8, 127, 1, 127, 1, 127,
		1, 127, 1, 127, 5, 127, 2132, 8, 127, 10, 127, 12, 127, 2135, 9, 127, 1,
		127, 3, 127, 2138, 8, 127, 1, 127, 1, 127, 3, 127, 2142, 8, 127, 1, 127,
		1, 127, 3, 127, 2146, 8, 127, 1, 127, 1, 127, 3, 127, 2150, 8, 127, 1,
		127, 3, 127, 2153, 8, 127, 1, 127, 1, 127, 3, 127, 2157, 8, 127, 1, 127,
		3, 127, 2160, 8, 127, 1, 127, 3, 127, 2163, 8, 127, 1, 128, 1, 128, 1,
		128, 3, 128, 2168, 8, 128, 1, 128, 3, 128, 2171, 8, 128, 1, 128, 3, 128,
		2174, 8, 128, 1, 128, 3, 128, 2177, 8, 128, 1, 128, 1, 128, 1, 128, 1,
		129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 3,
		129, 2191, 8, 129, 3, 129, 2193, 8, 129, 1, 130, 1, 130, 1, 130, 1, 130,
		1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 3, 130, 2204, 8, 130, 1, 131, 1,
		131, 1, 131, 1, 132, 1, 132, 1, 132, 5, 132, 2212, 8, 132, 10, 132, 12,
		132, 2215, 9, 132, 1, 133, 1, 133, 1, 133, 1, 133, 1, 134, 1, 134, 1, 134,
		3, 134, 2224, 8, 134, 1, 134, 3, 134, 2227, 8, 134, 1, 134, 1, 134, 1,
		134, 1, 134, 1, 134, 3, 134, 2234, 8, 134, 1, 134, 1, 134, 1, 134, 1, 135,
		1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135,
		1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135,
		3, 135, 2258, 8, 135, 1, 136, 1, 136, 1, 137, 1, 137, 1, 138, 1, 138, 1,
		138, 5, 138, 2267, 8, 138, 10, 138, 12, 138, 2270, 9, 138, 1, 139, 4, 139,
		2273, 8, 139, 11, 139, 12, 139, 2274, 1, 140, 1, 140, 3, 140, 2279, 8,
		140, 1, 141, 1, 141, 3, 141, 2283, 8, 141, 1, 141, 1, 141, 3, 141, 2287,
		8, 141, 1, 141, 1, 141, 3, 141, 2291, 8, 141, 1, 141, 1, 141, 3, 141, 2295,
		8, 141, 1, 141, 1, 141, 3, 141, 2299, 8, 141, 1, 141, 1, 141, 3, 141, 2303,
		8, 141, 1, 141, 1, 141, 1, 141, 1, 141, 3, 141, 2309, 8, 141, 1, 142, 1,
		142, 1, 142, 1, 142, 1, 142, 3, 142, 2316, 8, 142, 1, 142, 1, 142, 1, 142,
		1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 3, 142, 2326, 8, 142, 1, 143, 1,
		143, 1, 144, 1, 144, 1, 144, 1, 144, 1, 144, 5, 144, 2335, 8, 144, 10,
		144, 12, 144, 2338, 9, 144, 1, 144, 1, 144, 1, 145, 1, 145, 1, 145, 1,
		146, 1, 146, 1, 146, 5, 146, 2348, 8, 146, 10, 146, 12, 146, 2351, 9, 146,
		1, 147, 1, 147, 1, 147, 1, 147, 1, 147, 1, 147, 1, 148, 1, 148, 1, 149,
		1, 149, 1, 149, 5, 149, 2364, 8, 149, 10, 149, 12, 149, 2367, 9, 149, 1,
		150, 1, 150, 1, 151, 1, 151, 1, 151, 5, 151, 2374, 8, 151, 10, 151, 12,
		151, 2377, 9, 151, 1, 152, 1, 152, 1, 152, 1, 152, 1, 153, 1, 153, 1, 154,
		1, 154, 1, 155, 1, 155, 1, 156, 1, 156, 1, 157, 1, 157, 1, 157, 1, 157,
		1, 158, 3, 158, 2396, 8, 158, 1, 158, 1, 158, 1, 159, 1, 159, 3, 159, 2402,
		8, 159, 1, 159, 1, 159, 1, 159, 1, 159, 1, 159, 3, 159, 2409, 8, 159, 1,
		160, 1, 160, 1, 160, 5, 160, 2414, 8, 160, 10, 160, 12, 160, 2417, 9, 160,
		1, 161, 1, 161, 1, 161, 1, 161, 1, 161, 3, 161, 2424, 8, 161, 1, 162, 1,
		162, 1, 163, 1, 163, 1, 163, 5, 163, 2431, 8, 163, 10, 163, 12, 163, 2434,
		9, 163, 1, 164, 1, 164, 1, 164, 1, 164, 1, 164, 1, 165, 1, 165, 1, 165,
		1, 165, 1, 165, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 167,
		1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167,
		1, 167, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 3, 168,
		2470, 8, 168, 3, 168, 2472, 8, 168, 1, 169, 3, 169, 2475, 8, 169, 1, 169,
		1, 169, 1, 169, 3, 169, 2480, 8, 169, 1, 169, 1, 169, 3, 169, 2484, 8,
		169, 5, 169, 2486, 8, 169, 10, 169, 12, 169, 2489, 9, 169, 1, 170, 1, 170,
		1, 170, 3, 170, 2494, 8, 170, 1, 171, 1, 171, 1, 171, 1, 171, 3, 171, 2500,
		8, 171, 1, 171, 1, 171, 3, 171, 2504, 8, 171, 1, 172, 1, 172, 1, 172, 3,
		172, 2509, 8, 172, 1, 172, 1, 172, 1, 172, 3, 172, 2514, 8, 172, 3, 172,
		2516, 8, 172, 1, 173, 1, 173, 3, 173, 2520, 8, 173, 1, 173, 1, 173, 1,
		173, 3, 173, 2525, 8, 173, 1, 173, 3, 173, 2528, 8, 173, 3, 173, 2530,
		8, 173, 1, 173, 1, 173, 3, 173, 2534, 8, 173, 1, 174, 1, 174, 1, 174, 1,
		174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 3, 174, 2545, 8, 174, 1, 175,
		1, 175, 1, 175, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 3, 176,
		2556, 8, 176, 1, 177, 1, 177, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1,
		179, 1, 179, 3, 179, 2567, 8, 179, 1, 179, 1, 179, 3, 179, 2571, 8, 179,
		1, 179, 1, 179, 3, 179, 2575, 8, 179, 1, 179, 1, 179, 3, 179, 2579, 8,
		179, 1, 179, 3, 179, 2582, 8, 179, 1, 179, 1, 179, 3, 179, 2586, 8, 179,
		1, 179, 3, 179, 2589, 8, 179, 1, 180, 1, 180, 1, 180, 1, 180, 3, 180, 2595,
		8, 180, 1, 181, 1, 181, 1, 181, 1, 181, 1, 181, 5, 181, 2602, 8, 181, 10,
		181, 12, 181, 2605, 9, 181, 3, 181, 2607, 8, 181, 1, 182, 1, 182, 1, 182,
		1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182,
		3, 182, 2621, 8, 182, 1, 182, 1, 182, 1, 182, 1, 182, 3, 182, 2627, 8,
		182, 1, 183, 3, 183, 2630, 8, 183, 1, 183, 1, 183, 1, 183, 3, 183, 2635,
		8, 183, 1, 184, 1, 184, 1, 184, 1, 185, 1, 185, 3, 185, 2642, 8, 185, 1,
		186, 1, 186, 1, 186, 5, 186, 2647, 8, 186, 10, 186, 12, 186, 2650, 9, 186,
		1, 187, 1, 187, 1, 187, 1, 187, 1, 188, 1, 188, 3, 188, 2658, 8, 188, 1,
		189, 1, 189, 1, 189, 3, 189, 2663, 8, 189, 1, 189, 1, 189, 1, 189, 1, 189,
		1, 189, 1, 189, 3, 189, 2671, 8, 189, 1, 189, 1, 189, 1, 189, 1, 190, 1,
		190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 5, 190, 2684, 8, 190,
		10, 190, 12, 190, 2687, 9, 190, 1, 191, 1, 191, 1, 191, 3, 191, 2692, 8,
		191, 1, 192, 1, 192, 1, 192, 1, 192, 1, 192, 1, 192, 3, 192, 2700, 8, 192,
		1, 192, 1, 192, 1, 193, 1, 193, 1, 193, 1, 193, 3, 193, 2708, 8, 193, 1,
		193, 1, 193, 1, 193, 1, 194, 1, 194, 1, 194, 1, 194, 1, 195, 1, 195, 1,
		195, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 3, 195, 2725, 8, 195, 1, 196,
		1, 196, 1, 196, 1, 196, 1, 196, 3, 196, 2732, 8, 196, 1, 196, 1, 196, 1,
		196, 1, 196, 1, 196, 1, 196, 3, 196, 2740, 8, 196, 1, 197, 1, 197, 1, 197,
		1, 198, 1, 198, 1, 198, 1, 198, 1, 198, 1, 198, 1, 198, 1, 198, 1, 198,
		1, 199, 1, 199, 1, 199, 1, 200, 1, 200, 1, 200, 1, 200, 3, 200, 2761, 8,
		200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 3, 200, 2769, 8, 200,
		1, 201, 1, 201, 1, 201, 1, 202, 1, 202, 1, 202, 1, 202, 3, 202, 2778, 8,
		202, 1, 203, 1, 203, 1, 203, 1, 203, 1, 204, 1, 204, 1, 205, 1, 205, 3,
		205, 2788, 8, 205, 1, 206, 1, 206, 1, 206, 1, 206, 1, 206, 5, 206, 2795,
		8, 206, 10, 206, 12, 206, 2798, 9, 206, 1, 206, 1, 206, 3, 206, 2802, 8,
		206, 1, 207, 1, 207, 1, 208, 1, 208, 1, 208, 3, 208, 2809, 8, 208, 1, 208,
		1, 208, 1, 208, 1, 208, 1, 208, 1, 208, 1, 208, 1, 208, 3, 208, 2819, 8,
		208, 1, 208, 1, 208, 1, 208, 3, 208, 2824, 8, 208, 1, 208, 1, 208, 1, 208,
		1, 208, 1, 208, 5, 208, 2831, 8, 208, 10, 208, 12, 208, 2834, 9, 208, 1,
		208, 3, 208, 2837, 8, 208, 1, 208, 1, 208, 3, 208, 2841, 8, 208, 1, 208,
		3, 208, 2844, 8, 208, 1, 208, 3, 208, 2847, 8, 208, 1, 208, 3, 208, 2850,
		8, 208, 1, 208, 3, 208, 2853, 8, 208, 1, 209, 1, 209, 1, 209, 1, 209, 1,
		209, 1, 209, 3, 209, 2861, 8, 209, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210,
		1, 210, 1, 210, 3, 210, 2870, 8, 210, 1, 211, 1, 211, 1, 211, 1, 211, 3,
		211, 2876, 8, 211, 1, 212, 1, 212, 1, 212, 1, 213, 1, 213, 3, 213, 2883,
		8, 213, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 5, 214, 2890, 8, 214, 10,
		214, 12, 214, 2893, 9, 214, 1, 215, 1, 215, 1, 215, 5, 215, 2898, 8, 215,
		10, 215, 12, 215, 2901, 9, 215, 1, 216, 1, 216, 3, 216, 2905, 8, 216, 1,
		217, 1, 217, 1, 217, 5, 217, 2910, 8, 217, 10, 217, 12, 217, 2913, 9, 217,
		1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218,
		1, 218, 3, 218, 2925, 8, 218, 1, 219, 1, 219, 1, 219, 1, 219, 1, 220, 1,
		220, 1, 220, 5, 220, 2934, 8, 220, 10, 220, 12, 220, 2937, 9, 220, 1, 221,
		1, 221, 1, 221, 1, 221, 1, 222, 1, 222, 1, 222, 3, 222, 2946, 8, 222, 1,
		223, 1, 223, 1, 223, 1, 223, 3, 223, 2952, 8, 223, 1, 224, 1, 224, 1, 224,
		1, 224, 1, 224, 5, 224, 2959, 8, 224, 10, 224, 12, 224, 2962, 9, 224, 1,
		224, 1, 224, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 226, 1, 226, 1,
		226, 1, 226, 1, 226, 5, 226, 2976, 8, 226, 10, 226, 12, 226, 2979, 9, 226,
		1, 226, 1, 226, 1, 227, 1, 227, 1, 227, 1, 228, 1, 228, 1, 228, 1, 228,
		1, 229, 1, 229, 1, 229, 1, 230, 1, 230, 1, 230, 1, 230, 1, 230, 1, 230,
		5, 230, 2999, 8, 230, 10, 230, 12, 230, 3002, 9, 230, 1, 231, 1, 231, 1,
		231, 1, 231, 1, 231, 1, 231, 1, 231, 1, 231, 1, 231, 1, 231, 1, 231, 1,
		231, 1, 231, 1, 231, 1, 231, 1, 231, 1, 231, 3, 231, 3021, 8, 231, 1, 232,
		1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 5, 232, 3030, 8, 232, 10,
		232, 12, 232, 3033, 9, 232, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 3,
		233, 3040, 8, 233, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 5, 234,
		3048, 8, 234, 10, 234, 12, 234, 3051, 9, 234, 1, 235, 1, 235, 3, 235, 3055,
		8, 235, 1, 236, 1, 236, 3, 236, 3059, 8, 236, 1, 236, 1, 236, 1, 237, 1,
		237, 3, 237, 3065, 8, 237, 1, 237, 1, 237, 1, 238, 1, 238, 1, 238, 1, 238,
		1, 238, 1, 238, 1, 239, 1, 239, 1, 239, 1, 239, 1, 239, 1, 239, 1, 239,
		1, 240, 1, 240, 1, 240, 1, 241, 1, 241, 1, 241, 1, 241, 1, 241, 1, 241,
		1, 241, 1, 242, 1, 242, 1, 242, 1, 242, 1, 243, 1, 243, 1, 243, 1, 243,
		1, 243, 5, 243, 3101, 8, 243, 10, 243, 12, 243, 3104, 9, 243, 1, 243, 1,
		243, 1, 244, 1, 244, 1, 244, 1, 244, 1, 244, 5, 244, 3113, 8, 244, 10,
		244, 12, 244, 3116, 9, 244, 1, 244, 1, 244, 1, 245, 1, 245, 1, 245, 1,
		246, 1, 246, 1, 246, 1, 246, 1, 247, 1, 247, 1, 247, 1, 247, 1, 248, 1,
		248, 1, 248, 1, 248, 1, 248, 1, 248, 1, 249, 1, 249, 1, 249, 1, 250, 1,
		250, 1, 250, 1, 250, 1, 250, 1, 251, 1, 251, 1, 251, 1, 251, 1, 252, 1,
		252, 1, 252, 1, 252, 1, 252, 1, 253, 1, 253, 1, 253, 3, 253, 3157, 8, 253,
		1, 253, 1, 253, 1, 254, 1, 254, 1, 254, 1, 255, 3, 255, 3165, 8, 255, 1,
		255, 3, 255, 3168, 8, 255, 1, 255, 1, 255, 3, 255, 3172, 8, 255, 1, 256,
		1, 256, 3, 256, 3176, 8, 256, 1, 257, 1, 257, 1, 257, 1, 257, 1, 257, 1,
		257, 5, 257, 3184, 8, 257, 10, 257, 12, 257, 3187, 9, 257, 1, 257, 1, 257,
		1, 257, 1, 257, 1, 257, 1, 257, 1, 257, 1, 257, 5, 257, 3197, 8, 257, 10,
		257, 12, 257, 3200, 9, 257, 1, 257, 1, 257, 1, 257, 1, 257, 1, 257, 1,
		257, 1, 257, 1, 257, 5, 257, 3210, 8, 257, 10, 257, 12, 257, 3213, 9, 257,
		1, 257, 1, 257, 3, 257, 3217, 8, 257, 1, 258, 1, 258, 1, 258, 1, 258, 1,
		258, 1, 258, 1, 258, 1, 258, 5, 258, 3227, 8, 258, 10, 258, 12, 258, 3230,
		9, 258, 1, 258, 1, 258, 1, 258, 1, 258, 1, 258, 1, 258, 5, 258, 3238, 8,
		258, 10, 258, 12, 258, 3241, 9, 258, 1, 258, 1, 258, 3, 258, 3245, 8, 258,
		1, 258, 3, 258, 3248, 8, 258, 1, 259, 1, 259, 3, 259, 3252, 8, 259, 1,
		259, 1, 259, 3, 259, 3256, 8, 259, 1, 260, 1, 260, 3, 260, 3260, 8, 260,
		1, 260, 3, 260, 3263, 8, 260, 1, 261, 1, 261, 1, 262, 1, 262, 1, 263, 1,
		263, 1, 263, 1, 263, 1, 263, 5, 263, 3274, 8, 263, 10, 263, 12, 263, 3277,
		9, 263, 1, 263, 3, 263, 3280, 8, 263, 1, 263, 1, 263, 1, 264, 1, 264, 1,
		264, 1, 264, 1, 265, 1, 265, 1, 265, 1, 265, 3, 265, 3292, 8, 265, 1, 266,
		1, 266, 1, 266, 1, 266, 1, 266, 1, 266, 1, 266, 1, 267, 1, 267, 1, 267,
		5, 267, 3304, 8, 267, 10, 267, 12, 267, 3307, 9, 267, 1, 268, 1, 268, 1,
		268, 1, 268, 1, 269, 1, 269, 1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 1,
		270, 3, 270, 3321, 8, 270, 1, 271, 1, 271, 1, 271, 1, 271, 1, 272, 1, 272,
		1, 272, 1, 272, 1, 272, 1, 272, 1, 272, 1, 272, 1, 272, 3, 272, 3336, 8,
		272, 1, 272, 3, 272, 3339, 8, 272, 1, 273, 1, 273, 1, 273, 1, 273, 1, 274,
		1, 274, 1, 274, 1, 274, 5, 274, 3349, 8, 274, 10, 274, 12, 274, 3352, 9,
		274, 3, 274, 3354, 8, 274, 1, 274, 1, 274, 1, 275, 1, 275, 1, 275, 1, 275,
		1, 276, 1, 276, 1, 277, 1, 277, 1, 277, 1, 277, 5, 277, 3368, 8, 277, 10,
		277, 12, 277, 3371, 9, 277, 1, 277, 1, 277, 1, 277, 3, 277, 3376, 8, 277,
		1, 278, 1, 278, 1, 278, 1, 278, 5, 278, 3382, 8, 278, 10, 278, 12, 278,
		3385, 9, 278, 1, 278, 1, 278, 1, 279, 1, 279, 1, 279, 3, 279, 3392, 8,
		279, 1, 280, 1, 280, 1, 280, 1, 280, 1, 280, 3, 280, 3399, 8, 280, 1, 280,
		1, 280, 3, 280, 3403, 8, 280, 1, 280, 1, 280, 1, 281, 1, 281, 1, 281, 1,
		281, 3, 281, 3411, 8, 281, 1, 282, 1, 282, 1, 282, 1, 282, 3, 282, 3417,
		8, 282, 1, 282, 1, 282, 1, 282, 1, 282, 3, 282, 3423, 8, 282, 1, 283, 1,
		283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 5, 283, 3433, 8, 283,
		10, 283, 12, 283, 3436, 9, 283, 1, 283, 3, 283, 3439, 8, 283, 3, 283, 3441,
		8, 283, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284,
		5, 284, 3451, 8, 284, 10, 284, 12, 284, 3454, 9, 284, 1, 284, 3, 284, 3457,
		8, 284, 1, 284, 1, 284, 1, 284, 3, 284, 3462, 8, 284, 1, 285, 1, 285, 1,
		285, 1, 285, 3, 285, 3468, 8, 285, 1, 285, 1, 285, 1, 285, 5, 285, 3473,
		8, 285, 10, 285, 12, 285, 3476, 9, 285, 1, 285, 3, 285, 3479, 8, 285, 1,
		286, 1, 286, 3, 286, 3483, 8, 286, 1, 287, 3, 287, 3486, 8, 287, 1, 287,
		1, 287, 1, 287, 1, 288, 1, 288, 1, 288, 1, 288, 1, 288, 1, 288, 5, 288,
		3497, 8, 288, 10, 288, 12, 288, 3500, 9, 288, 1, 288, 1, 288, 1, 288, 1,
		288, 5, 288, 3506, 8, 288, 10, 288, 12, 288, 3509, 9, 288, 1, 288, 3, 288,
		3512, 8, 288, 1, 288, 1, 288, 1, 288, 3, 288, 3517, 8, 288, 1, 289, 1,
		289, 1, 289, 1, 289, 3, 289, 3523, 8, 289, 1, 289, 1, 289, 1, 289, 1, 289,
		1, 289, 5, 289, 3530, 8, 289, 10, 289, 12, 289, 3533, 9, 289, 1, 289, 1,
		289, 1, 289, 1, 289, 5, 289, 3539, 8, 289, 10, 289, 12, 289, 3542, 9, 289,
		1, 290, 1, 290, 1, 290, 1, 290, 1, 290, 1, 290, 1, 290, 1, 290, 1, 290,
		1, 290, 1, 290, 1, 290, 1, 290, 1, 290, 3, 290, 3558, 8, 290, 1, 290, 1,
		290, 3, 290, 3562, 8, 290, 1, 290, 1, 290, 3, 290, 3566, 8, 290, 3, 290,
		3568, 8, 290, 1, 291, 1, 291, 3, 291, 3572, 8, 291, 1, 292, 1, 292, 1,
		292, 5, 292, 3577, 8, 292, 10, 292, 12, 292, 3580, 9, 292, 1, 292, 3, 292,
		3583, 8, 292, 1, 292, 1, 292, 3, 292, 3587, 8, 292, 3, 292, 3589, 8, 292,
		1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 294, 1, 294, 1, 294,
		1, 294, 1, 294, 1, 294, 1, 294, 5, 294, 3604, 8, 294, 10, 294, 12, 294,
		3607, 9, 294, 1, 295, 1, 295, 3, 295, 3611, 8, 295, 1, 296, 1, 296, 1,
		296, 1, 296, 1, 296, 1, 297, 1, 297, 1, 297, 1, 297, 1, 297, 1, 297, 1,
		297, 1, 298, 1, 298, 1, 298, 1, 298, 1, 298, 1, 298, 1, 298, 1, 298, 5,
		298, 3633, 8, 298, 10, 298, 12, 298, 3636, 9, 298, 1, 299, 1, 299, 3, 299,
		3640, 8, 299, 1, 300, 1, 300, 1, 300, 1, 300, 1, 300, 1, 300, 1, 301, 1,
		301, 1, 301, 1, 301, 1, 301, 1, 301, 1, 301, 1, 301, 5, 301, 3656, 8, 301,
		10, 301, 12, 301, 3659, 9, 301, 1, 301, 1, 301, 1, 301, 1, 301, 1, 301,
		1, 302, 1, 302, 1, 302, 1, 302, 1, 303, 1, 303, 1, 303, 5, 303, 3673, 8,
		303, 10, 303, 12, 303, 3676, 9, 303, 1, 304, 1, 304, 1, 304, 1, 304, 1,
		305, 1, 305, 1, 305, 1, 305, 1, 305, 1, 305, 1, 305, 5, 305, 3689, 8, 305,
		10, 305, 12, 305, 3692, 9, 305, 1, 306, 1, 306, 1, 307, 1, 307, 1, 307,
		1, 307, 1, 307, 1, 308, 1, 308, 1, 308, 1, 308, 1, 308, 3, 308, 3706, 8,
		308, 1, 309, 1, 309, 1, 309, 5, 309, 3711, 8, 309, 10, 309, 12, 309, 3714,
		9, 309, 1, 310, 1, 310, 1, 310, 1, 310, 1, 310, 3, 310, 3721, 8, 310, 1,
		310, 1, 310, 1, 310, 1, 310, 1, 310, 1, 310, 1, 311, 5, 311, 3730, 8, 311,
		10, 311, 12, 311, 3733, 9, 311, 1, 311, 1, 311, 4, 311, 3737, 8, 311, 11,
		311, 12, 311, 3738, 1, 311, 5, 311, 3742, 8, 311, 10, 311, 12, 311, 3745,
		9, 311, 1, 311, 5, 311, 3748, 8, 311, 10, 311, 12, 311, 3751, 9, 311, 3,
		311, 3753, 8, 311, 1, 312, 3, 312, 3756, 8, 312, 1, 312, 1, 312, 1, 312,
		1, 312, 1, 312, 3, 312, 3763, 8, 312, 1, 313, 3, 313, 3766, 8, 313, 1,
		313, 3, 313, 3769, 8, 313, 1, 313, 1, 313, 1, 313, 1, 313, 1, 313, 1, 313,
		1, 313, 3, 313, 3778, 8, 313, 1, 314, 1, 314, 1, 314, 3, 314, 3783, 8,
		314, 1, 314, 3, 314, 3786, 8, 314, 1, 314, 1, 314, 1, 314, 1, 314, 1, 314,
		1, 314, 5, 314, 3794, 8, 314, 10, 314, 12, 314, 3797, 9, 314, 1, 314, 3,
		314, 3800, 8, 314, 3, 314, 3802, 8, 314, 1, 314, 1, 314, 1, 314, 1, 314,
		1, 314, 3, 314, 3809, 8, 314, 1, 314, 3, 314, 3812, 8, 314, 1, 314, 1,
		314, 3, 314, 3816, 8, 314, 3, 314, 3818, 8, 314, 1, 314, 3, 314, 3821,
		8, 314, 1, 315, 1, 315, 1, 315, 3, 315, 3826, 8, 315, 1, 316, 3, 316, 3829,
		8, 316, 1, 316, 1, 316, 1, 316, 3, 316, 3834, 8, 316, 1, 317, 1, 317, 1,
		317, 1, 317, 1, 317, 1, 317, 5, 317, 3842, 8, 317, 10, 317, 12, 317, 3845,
		9, 317, 1, 317, 1, 317, 3, 317, 3849, 8, 317, 1, 318, 1, 318, 1, 318, 1,
		318, 1, 318, 1, 318, 1, 318, 5, 318, 3858, 8, 318, 10, 318, 12, 318, 3861,
		9, 318, 1, 318, 3, 318, 3864, 8, 318, 1, 318, 1, 318, 3, 318, 3868, 8,
		318, 3, 318, 3870, 8, 318, 1, 318, 1, 318, 3, 318, 3874, 8, 318, 1, 318,
		1, 318, 1, 318, 3, 318, 3879, 8, 318, 1, 318, 1, 318, 1, 318, 1, 318, 5,
		318, 3885, 8, 318, 10, 318, 12, 318, 3888, 9, 318, 3, 318, 3890, 8, 318,
		1, 318, 3, 318, 3893, 8, 318, 1, 318, 3, 318, 3896, 8, 318, 1, 319, 1,
		319, 1, 319, 3, 319, 3901, 8, 319, 1, 319, 1, 319, 1, 320, 1, 320, 3, 320,
		3907, 8, 320, 1, 320, 3, 320, 3910, 8, 320, 1, 321, 1, 321, 3, 321, 3914,
		8, 321, 1, 322, 1, 322, 1, 322, 1, 322, 3, 322, 3920, 8, 322, 1, 323, 1,
		323, 1, 323, 1, 323, 1, 323, 1, 323, 1, 323, 3, 323, 3929, 8, 323, 1, 323,
		3, 323, 3932, 8, 323, 1, 324, 1, 324, 1, 324, 1, 324, 1, 324, 1, 324, 3,
		324, 3940, 8, 324, 1, 324, 1, 324, 3, 324, 3944, 8, 324, 1, 324, 3, 324,
		3947, 8, 324, 1, 325, 1, 325, 3, 325, 3951, 8, 325, 1, 326, 1, 326, 1,
		326, 5, 326, 3956, 8, 326, 10, 326, 12, 326, 3959, 9, 326, 1, 327, 1, 327,
		1, 327, 1, 327, 1, 328, 1, 328, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329,
		1, 329, 1, 330, 1, 330, 1, 330, 1, 330, 5, 330, 3977, 8, 330, 10, 330,
		12, 330, 3980, 9, 330, 1, 330, 1, 330, 1, 331, 1, 331, 1, 331, 1, 331,
		1, 331, 3, 331, 3989, 8, 331, 1, 331, 1, 331, 3, 331, 3993, 8, 331, 1,
		331, 3, 331, 3996, 8, 331, 1, 332, 1, 332, 1, 332, 1, 332, 5, 332, 4002,
		8, 332, 10, 332, 12, 332, 4005, 9, 332, 1, 332, 1, 332, 1, 333, 1, 333,
		1, 334, 1, 334, 1, 334, 1, 334, 1, 334, 1, 335, 1, 335, 1, 335, 1, 335,
		3, 335, 4020, 8, 335, 1, 335, 1, 335, 1, 335, 1, 335, 5, 335, 4026, 8,
		335, 10, 335, 12, 335, 4029, 9, 335, 1, 336, 1, 336, 1, 336, 1, 336, 1,
		336, 3, 336, 4036, 8, 336, 1, 337, 1, 337, 1, 337, 1, 338, 1, 338, 1, 338,
		3, 338, 4044, 8, 338, 1, 339, 1, 339, 1, 339, 1, 339, 1, 339, 1, 340, 1,
		340, 3, 340, 4053, 8, 340, 1, 341, 1, 341, 1, 341, 1, 341, 1, 342, 1, 342,
		1, 342, 1, 342, 1, 342, 1, 343, 1, 343, 1, 343, 1, 343, 1, 343, 5, 343,
		4069, 8, 343, 10, 343, 12, 343, 4072, 9, 343, 1, 343, 1, 343, 1, 344, 1,
		344, 1, 344, 1, 344, 1, 344, 1, 345, 1, 345, 1, 345, 1, 345, 1, 345, 5,
		345, 4086, 8, 345, 10, 345, 12, 345, 4089, 9, 345, 1, 345, 1, 345, 1, 346,
		1, 346, 1, 346, 1, 346, 3, 346, 4097, 8, 346, 1, 346, 1, 346, 1, 347, 1,
		347, 1, 347, 5, 347, 4104, 8, 347, 10, 347, 12, 347, 4107, 9, 347, 1, 348,
		1, 348, 1, 348, 1, 348, 1, 349, 1, 349, 1, 350, 1, 350, 1, 350, 1, 350,
		1, 350, 1, 351, 1, 351, 1, 351, 5, 351, 4123, 8, 351, 10, 351, 12, 351,
		4126, 9, 351, 1, 352, 1, 352, 1, 352, 1, 352, 1, 353, 1, 353, 1, 354, 1,
		354, 1, 354, 3, 354, 4137, 8, 354, 1, 354, 1, 354, 1, 355, 1, 355, 1, 356,
		1, 356, 1, 356, 1, 356, 3, 356, 4147, 8, 356, 1, 357, 1, 357, 1, 357, 1,
		357, 1, 357, 1, 357, 1, 358, 1, 358, 3, 358, 4157, 8, 358, 1, 359, 1, 359,
		1, 360, 1, 360, 1, 360, 1, 361, 1, 361, 1, 361, 5, 361, 4167, 8, 361, 10,
		361, 12, 361, 4170, 9, 361, 1, 362, 1, 362, 1, 362, 1, 362, 1, 363, 1,
		363, 1, 364, 1, 364, 1, 364, 1, 364, 1, 365, 3, 365, 4183, 8, 365, 1, 365,
		3, 365, 4186, 8, 365, 1, 365, 3, 365, 4189, 8, 365, 1, 365, 3, 365, 4192,
		8, 365, 1, 366, 1, 366, 1, 367, 1, 367, 3, 367, 4198, 8, 367, 1, 367, 1,
		367, 1, 367, 1, 368, 1, 368, 1, 369, 1, 369, 1, 369, 3, 369, 4208, 8, 369,
		1, 370, 1, 370, 1, 371, 1, 371, 3, 371, 4214, 8, 371, 1, 372, 1, 372, 1,
		372, 1, 372, 1, 372, 1, 373, 1, 373, 1, 373, 1, 373, 3, 373, 4225, 8, 373,
		1, 373, 3, 373, 4228, 8, 373, 1, 374, 1, 374, 1, 374, 1, 374, 1, 374, 1,
		374, 1, 374, 1, 374, 1, 374, 1, 374, 3, 374, 4240, 8, 374, 1, 375, 1, 375,
		1, 375, 1, 376, 1, 376, 1, 376, 1, 376, 1, 376, 3, 376, 4250, 8, 376, 1,
		377, 1, 377, 1, 377, 1, 377, 3, 377, 4256, 8, 377, 1, 378, 1, 378, 1, 379,
		1, 379, 1, 380, 1, 380, 1, 380, 1, 380, 1, 380, 3, 380, 4267, 8, 380, 1,
		381, 1, 381, 1, 381, 5, 381, 4272, 8, 381, 10, 381, 12, 381, 4275, 9, 381,
		1, 381, 3, 381, 4278, 8, 381, 1, 382, 1, 382, 1, 382, 1, 383, 1, 383, 1,
		384, 1, 384, 3, 384, 4287, 8, 384, 1, 385, 1, 385, 1, 385, 1, 385, 1, 385,
		1, 385, 1, 385, 3, 385, 4296, 8, 385, 1, 386, 1, 386, 1, 386, 1, 386, 1,
		386, 1, 386, 3, 386, 4304, 8, 386, 1, 387, 1, 387, 1, 387, 1, 387, 1, 387,
		3, 387, 4311, 8, 387, 1, 388, 1, 388, 1, 388, 1, 388, 1, 388, 1, 388, 1,
		388, 1, 388, 3, 388, 4321, 8, 388, 1, 389, 1, 389, 1, 389, 1, 389, 1, 389,
		1, 389, 1, 389, 3, 389, 4330, 8, 389, 1, 390, 1, 390, 1, 390, 1, 390, 1,
		390, 1, 390, 1, 390, 3, 390, 4339, 8, 390, 1, 391, 1, 391, 1, 391, 1, 391,
		1, 391, 1, 391, 1, 391, 1, 391, 3, 391, 4349, 8, 391, 1, 392, 1, 392, 3,
		392, 4353, 8, 392, 1, 393, 1, 393, 3, 393, 4357, 8, 393, 1, 394, 1, 394,
		3, 394, 4361, 8, 394, 1, 395, 1, 395, 3, 395, 4365, 8, 395, 1, 396, 1,
		396, 3, 396, 4369, 8, 396, 1, 397, 1, 397, 3, 397, 4373, 8, 397, 1, 398,
		1, 398, 3, 398, 4377, 8, 398, 1, 399, 1, 399, 3, 399, 4381, 8, 399, 1,
		400, 1, 400, 3, 400, 4385, 8, 400, 1, 401, 1, 401, 3, 401, 4389, 8, 401,
		1, 402, 1, 402, 3, 402, 4393, 8, 402, 1, 403, 1, 403, 3, 403, 4397, 8,
		403, 1, 404, 1, 404, 1, 404, 3, 404, 4402, 8, 404, 1, 405, 1, 405, 1, 405,
		3, 405, 4407, 8, 405, 1, 406, 1, 406, 1, 406, 3, 406, 4412, 8, 406, 1,
		406, 1, 406, 3, 406, 4416, 8, 406, 1, 407, 1, 407, 3, 407, 4420, 8, 407,
		1, 408, 1, 408, 1, 408, 3, 408, 4425, 8, 408, 1, 409, 3, 409, 4428, 8,
		409, 1, 409, 1, 409, 1, 410, 1, 410, 3, 410, 4434, 8, 410, 1, 411, 3, 411,
		4437, 8, 411, 1, 411, 1, 411, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1,
		412, 1, 412, 1, 412, 3, 412, 4449, 8, 412, 1, 413, 1, 413, 1, 414, 1, 414,
		1, 415, 1, 415, 1, 416, 1, 416, 1, 417, 1, 417, 1, 418, 1, 418, 1, 419,
		1, 419, 1, 420, 1, 420, 1, 421, 1, 421, 1, 422, 1, 422, 1, 423, 1, 423,
		1, 424, 1, 424, 1, 425, 1, 425, 1, 425, 0, 0, 426, 0, 2, 4, 6, 8, 10, 12,
		14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48,
		50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84,
		86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116,
		118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146,
		148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176,
		178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206,
		208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236,
		238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266,
		268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296,
		298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322, 324, 326,
		328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356,
		358, 360, 362, 364, 366, 368, 370, 372, 374, 376, 378, 380, 382, 384, 386,
		388, 390, 392, 394, 396, 398, 400, 402, 404, 406, 408, 410, 412, 414, 416,
		418, 420, 422, 424, 426, 428, 430, 432, 434, 436, 438, 440, 442, 444, 446,
		448, 450, 452, 454, 456, 458, 460, 462, 464, 466, 468, 470, 472, 474, 476,
		478, 480, 482, 484, 486, 488, 490, 492, 494, 496, 498, 500, 502, 504, 506,
		508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 530, 532, 534, 536,
		538, 540, 542, 544, 546, 548, 550, 552, 554, 556, 558, 560, 562, 564, 566,
		568, 570, 572, 574, 576, 578, 580, 582, 584, 586, 588, 590, 592, 594, 596,
		598, 600, 602, 604, 606, 608, 610, 612, 614, 616, 618, 620, 622, 624, 626,
		628, 630, 632, 634, 636, 638, 640, 642, 644, 646, 648, 650, 652, 654, 656,
		658, 660, 662, 664, 666, 668, 670, 672, 674, 676, 678, 680, 682, 684, 686,
		688, 690, 692, 694, 696, 698, 700, 702, 704, 706, 708, 710, 712, 714, 716,
		718, 720, 722, 724, 726, 728, 730, 732, 734, 736, 738, 740, 742, 744, 746,
		748, 750, 752, 754, 756, 758, 760, 762, 764, 766, 768, 770, 772, 774, 776,
		778, 780, 782, 784, 786, 788, 790, 792, 794, 796, 798, 800, 802, 804, 806,
		808, 810, 812, 814, 816, 818, 820, 822, 824, 826, 828, 830, 832, 834, 836,
		838, 840, 842, 844, 846, 848, 850, 0, 39, 2, 0, 57, 57, 280, 280, 6, 0,
		148, 148, 159, 159, 184, 184, 189, 189, 239, 239, 258, 258, 1, 0, 5, 8,
		1, 0, 16, 17, 2, 0, 19, 20, 22, 22, 2, 0, 16, 18, 200, 200, 2, 0, 118,
		118, 124, 124, 4, 0, 124, 124, 136, 136, 296, 296, 303, 303, 2, 0, 84,
		84, 300, 300, 2, 0, 55, 55, 106, 106, 2, 0, 25, 25, 206, 206, 2, 0, 47,
		47, 113, 113, 2, 0, 167, 167, 267, 267, 3, 0, 109, 109, 186, 186, 212,
		212, 2, 0, 68, 68, 282, 282, 2, 0, 210, 210, 269, 269, 2, 0, 58, 58, 281,
		281, 3, 0, 193, 194, 196, 196, 266, 266, 2, 0, 45, 45, 115, 115, 2, 0,
		151, 151, 308, 308, 2, 0, 61, 61, 284, 284, 2, 0, 123, 123, 305, 305, 3,
		0, 48, 48, 107, 107, 242, 242, 3, 0, 61, 61, 261, 261, 284, 284, 2, 0,
		146, 146, 307, 307, 3, 0, 110, 110, 234, 234, 283, 283, 2, 0, 44, 44, 277,
		277, 2, 0, 81, 81, 265, 265, 3, 0, 153, 153, 236, 236, 262, 262, 2, 0,
		142, 142, 229, 229, 1, 0, 323, 324, 21, 0, 57, 57, 69, 70, 74, 75, 92,
		92, 94, 96, 119, 119, 131, 131, 145, 146, 156, 156, 177, 179, 187, 187,
		200, 200, 202, 202, 233, 233, 237, 237, 253, 254, 260, 260, 268, 268, 280,
		280, 299, 299, 315, 316, 3, 0, 52, 52, 123, 123, 275, 275, 11, 0, 47, 47,
		54, 54, 56, 56, 113, 113, 127, 127, 155, 155, 172, 172, 185, 185, 301,
		301, 317, 317, 319, 319, 57, 0, 43, 46, 48, 51, 53, 53, 55, 55, 58, 62,
		64, 68, 71, 71, 73, 73, 76, 78, 82, 82, 84, 90, 93, 93, 97, 103, 105, 108,
		110, 112, 115, 118, 120, 121, 124, 126, 128, 128, 130, 130, 132, 135, 137,
		140, 142, 144, 147, 148, 150, 152, 154, 154, 157, 168, 170, 171, 173, 174,
		181, 181, 183, 184, 188, 196, 198, 199, 203, 207, 209, 211, 213, 215, 218,
		229, 231, 232, 234, 235, 238, 243, 245, 247, 249, 251, 255, 256, 258, 259,
		261, 261, 264, 264, 266, 267, 271, 274, 277, 279, 281, 286, 288, 295, 298,
		298, 300, 300, 302, 308, 310, 311, 314, 314, 320, 321, 50, 0, 43, 46, 48,
		51, 53, 53, 55, 55, 58, 62, 64, 68, 71, 71, 73, 73, 76, 79, 82, 82, 84,
		91, 93, 93, 97, 108, 110, 112, 114, 118, 120, 121, 124, 126, 128, 130,
		132, 135, 137, 140, 142, 144, 147, 148, 150, 152, 154, 154, 157, 171, 173,
		176, 180, 184, 188, 199, 201, 201, 203, 211, 213, 232, 234, 235, 238, 243,
		245, 247, 249, 252, 255, 259, 261, 261, 263, 264, 266, 267, 269, 269, 271,
		274, 277, 279, 281, 286, 288, 295, 298, 298, 300, 300, 302, 311, 313, 314,
		318, 318, 320, 321, 12, 0, 72, 72, 109, 109, 122, 122, 141, 141, 186, 186,
		212, 212, 248, 248, 270, 270, 276, 276, 287, 287, 297, 297, 312, 312, 2,
		0, 136, 136, 296, 296, 1, 0, 325, 326, 4789, 0, 857, 1, 0, 0, 0, 2, 862,
		1, 0, 0, 0, 4, 888, 1, 0, 0, 0, 6, 896, 1, 0, 0, 0, 8, 920, 1, 0, 0, 0,
		10, 931, 1, 0, 0, 0, 12, 991, 1, 0, 0, 0, 14, 1002, 1, 0, 0, 0, 16, 1004,
		1, 0, 0, 0, 18, 1012, 1, 0, 0, 0, 20, 1020, 1, 0, 0, 0, 22, 1024, 1, 0,
		0, 0, 24, 1082, 1, 0, 0, 0, 26, 1084, 1, 0, 0, 0, 28, 1086, 1, 0, 0, 0,
		30, 1094, 1, 0, 0, 0, 32, 1097, 1, 0, 0, 0, 34, 1101, 1, 0, 0, 0, 36, 1104,
		1, 0, 0, 0, 38, 1130, 1, 0, 0, 0, 40, 1138, 1, 0, 0, 0, 42, 1146, 1, 0,
		0, 0, 44, 1158, 1, 0, 0, 0, 46, 1160, 1, 0, 0, 0, 48, 1174, 1, 0, 0, 0,
		50, 1183, 1, 0, 0, 0, 52, 1189, 1, 0, 0, 0, 54, 1195, 1, 0, 0, 0, 56, 1199,
		1, 0, 0, 0, 58, 1201, 1, 0, 0, 0, 60, 1210, 1, 0, 0, 0, 62, 1226, 1, 0,
		0, 0, 64, 1235, 1, 0, 0, 0, 66, 1248, 1, 0, 0, 0, 68, 1274, 1, 0, 0, 0,
		70, 1296, 1, 0, 0, 0, 72, 1298, 1, 0, 0, 0, 74, 1305, 1, 0, 0, 0, 76, 1312,
		1, 0, 0, 0, 78, 1320, 1, 0, 0, 0, 80, 1335, 1, 0, 0, 0, 82, 1349, 1, 0,
		0, 0, 84, 1354, 1, 0, 0, 0, 86, 1356, 1, 0, 0, 0, 88, 1360, 1, 0, 0, 0,
		90, 1362, 1, 0, 0, 0, 92, 1366, 1, 0, 0, 0, 94, 1374, 1, 0, 0, 0, 96, 1385,
		1, 0, 0, 0, 98, 1387, 1, 0, 0, 0, 100, 1405, 1, 0, 0, 0, 102, 1409, 1,
		0, 0, 0, 104, 1428, 1, 0, 0, 0, 106, 1436, 1, 0, 0, 0, 108, 1438, 1, 0,
		0, 0, 110, 1460, 1, 0, 0, 0, 112, 1469, 1, 0, 0, 0, 114, 1477, 1, 0, 0,
		0, 116, 1490, 1, 0, 0, 0, 118, 1492, 1, 0, 0, 0, 120, 1503, 1, 0, 0, 0,
		122, 1511, 1, 0, 0, 0, 124, 1513, 1, 0, 0, 0, 126, 1524, 1, 0, 0, 0, 128,
		1535, 1, 0, 0, 0, 130, 1540, 1, 0, 0, 0, 132, 1548, 1, 0, 0, 0, 134, 1562,
		1, 0, 0, 0, 136, 1576, 1, 0, 0, 0, 138, 1580, 1, 0, 0, 0, 140, 1584, 1,
		0, 0, 0, 142, 1599, 1, 0, 0, 0, 144, 1601, 1, 0, 0, 0, 146, 1607, 1, 0,
		0, 0, 148, 1611, 1, 0, 0, 0, 150, 1619, 1, 0, 0, 0, 152, 1624, 1, 0, 0,
		0, 154, 1633, 1, 0, 0, 0, 156, 1639, 1, 0, 0, 0, 158, 1643, 1, 0, 0, 0,
		160, 1648, 1, 0, 0, 0, 162, 1650, 1, 0, 0, 0, 164, 1666, 1, 0, 0, 0, 166,
		1671, 1, 0, 0, 0, 168, 1675, 1, 0, 0, 0, 170, 1681, 1, 0, 0, 0, 172, 1689,
		1, 0, 0, 0, 174, 1696, 1, 0, 0, 0, 176, 1701, 1, 0, 0, 0, 178, 1720, 1,
		0, 0, 0, 180, 1739, 1, 0, 0, 0, 182, 1754, 1, 0, 0, 0, 184, 1759, 1, 0,
		0, 0, 186, 1764, 1, 0, 0, 0, 188, 1769, 1, 0, 0, 0, 190, 1776, 1, 0, 0,
		0, 192, 1781, 1, 0, 0, 0, 194, 1796, 1, 0, 0, 0, 196, 1801, 1, 0, 0, 0,
		198, 1808, 1, 0, 0, 0, 200, 1841, 1, 0, 0, 0, 202, 1860, 1, 0, 0, 0, 204,
		1864, 1, 0, 0, 0, 206, 1866, 1, 0, 0, 0, 208, 1891, 1, 0, 0, 0, 210, 1893,
		1, 0, 0, 0, 212, 1902, 1, 0, 0, 0, 214, 1912, 1, 0, 0, 0, 216, 1917, 1,
		0, 0, 0, 218, 1922, 1, 0, 0, 0, 220, 1930, 1, 0, 0, 0, 222, 1935, 1, 0,
		0, 0, 224, 1940, 1, 0, 0, 0, 226, 1963, 1, 0, 0, 0, 228, 1965, 1, 0, 0,
		0, 230, 1969, 1, 0, 0, 0, 232, 1977, 1, 0, 0, 0, 234, 1986, 1, 0, 0, 0,
		236, 2000, 1, 0, 0, 0, 238, 2008, 1, 0, 0, 0, 240, 2010, 1, 0, 0, 0, 242,
		2020, 1, 0, 0, 0, 244, 2032, 1, 0, 0, 0, 246, 2068, 1, 0, 0, 0, 248, 2072,
		1, 0, 0, 0, 250, 2080, 1, 0, 0, 0, 252, 2117, 1, 0, 0, 0, 254, 2121, 1,
		0, 0, 0, 256, 2164, 1, 0, 0, 0, 258, 2192, 1, 0, 0, 0, 260, 2203, 1, 0,
		0, 0, 262, 2205, 1, 0, 0, 0, 264, 2208, 1, 0, 0, 0, 266, 2216, 1, 0, 0,
		0, 268, 2223, 1, 0, 0, 0, 270, 2257, 1, 0, 0, 0, 272, 2259, 1, 0, 0, 0,
		274, 2261, 1, 0, 0, 0, 276, 2263, 1, 0, 0, 0, 278, 2272, 1, 0, 0, 0, 280,
		2276, 1, 0, 0, 0, 282, 2308, 1, 0, 0, 0, 284, 2325, 1, 0, 0, 0, 286, 2327,
		1, 0, 0, 0, 288, 2329, 1, 0, 0, 0, 290, 2341, 1, 0, 0, 0, 292, 2344, 1,
		0, 0, 0, 294, 2352, 1, 0, 0, 0, 296, 2358, 1, 0, 0, 0, 298, 2360, 1, 0,
		0, 0, 300, 2368, 1, 0, 0, 0, 302, 2370, 1, 0, 0, 0, 304, 2378, 1, 0, 0,
		0, 306, 2382, 1, 0, 0, 0, 308, 2384, 1, 0, 0, 0, 310, 2386, 1, 0, 0, 0,
		312, 2388, 1, 0, 0, 0, 314, 2390, 1, 0, 0, 0, 316, 2395, 1, 0, 0, 0, 318,
		2399, 1, 0, 0, 0, 320, 2410, 1, 0, 0, 0, 322, 2423, 1, 0, 0, 0, 324, 2425,
		1, 0, 0, 0, 326, 2427, 1, 0, 0, 0, 328, 2435, 1, 0, 0, 0, 330, 2440, 1,
		0, 0, 0, 332, 2445, 1, 0, 0, 0, 334, 2451, 1, 0, 0, 0, 336, 2471, 1, 0,
		0, 0, 338, 2474, 1, 0, 0, 0, 340, 2490, 1, 0, 0, 0, 342, 2503, 1, 0, 0,
		0, 344, 2505, 1, 0, 0, 0, 346, 2517, 1, 0, 0, 0, 348, 2544, 1, 0, 0, 0,
		350, 2546, 1, 0, 0, 0, 352, 2549, 1, 0, 0, 0, 354, 2557, 1, 0, 0, 0, 356,
		2559, 1, 0, 0, 0, 358, 2588, 1, 0, 0, 0, 360, 2594, 1, 0, 0, 0, 362, 2596,
		1, 0, 0, 0, 364, 2620, 1, 0, 0, 0, 366, 2634, 1, 0, 0, 0, 368, 2636, 1,
		0, 0, 0, 370, 2641, 1, 0, 0, 0, 372, 2643, 1, 0, 0, 0, 374, 2651, 1, 0,
		0, 0, 376, 2657, 1, 0, 0, 0, 378, 2659, 1, 0, 0, 0, 380, 2675, 1, 0, 0,
		0, 382, 2691, 1, 0, 0, 0, 384, 2693, 1, 0, 0, 0, 386, 2703, 1, 0, 0, 0,
		388, 2712, 1, 0, 0, 0, 390, 2716, 1, 0, 0, 0, 392, 2726, 1, 0, 0, 0, 394,
		2741, 1, 0, 0, 0, 396, 2744, 1, 0, 0, 0, 398, 2753, 1, 0, 0, 0, 400, 2756,
		1, 0, 0, 0, 402, 2770, 1, 0, 0, 0, 404, 2777, 1, 0, 0, 0, 406, 2779, 1,
		0, 0, 0, 408, 2783, 1, 0, 0, 0, 410, 2787, 1, 0, 0, 0, 412, 2801, 1, 0,
		0, 0, 414, 2803, 1, 0, 0, 0, 416, 2805, 1, 0, 0, 0, 418, 2860, 1, 0, 0,
		0, 420, 2862, 1, 0, 0, 0, 422, 2871, 1, 0, 0, 0, 424, 2877, 1, 0, 0, 0,
		426, 2882, 1, 0, 0, 0, 428, 2884, 1, 0, 0, 0, 430, 2894, 1, 0, 0, 0, 432,
		2904, 1, 0, 0, 0, 434, 2906, 1, 0, 0, 0, 436, 2924, 1, 0, 0, 0, 438, 2926,
		1, 0, 0, 0, 440, 2930, 1, 0, 0, 0, 442, 2938, 1, 0, 0, 0, 444, 2942, 1,
		0, 0, 0, 446, 2947, 1, 0, 0, 0, 448, 2953, 1, 0, 0, 0, 450, 2965, 1, 0,
		0, 0, 452, 2970, 1, 0, 0, 0, 454, 2982, 1, 0, 0, 0, 456, 2985, 1, 0, 0,
		0, 458, 2989, 1, 0, 0, 0, 460, 2992, 1, 0, 0, 0, 462, 3020, 1, 0, 0, 0,
		464, 3022, 1, 0, 0, 0, 466, 3039, 1, 0, 0, 0, 468, 3041, 1, 0, 0, 0, 470,
		3054, 1, 0, 0, 0, 472, 3056, 1, 0, 0, 0, 474, 3062, 1, 0, 0, 0, 476, 3068,
		1, 0, 0, 0, 478, 3074, 1, 0, 0, 0, 480, 3081, 1, 0, 0, 0, 482, 3084, 1,
		0, 0, 0, 484, 3091, 1, 0, 0, 0, 486, 3095, 1, 0, 0, 0, 488, 3107, 1, 0,
		0, 0, 490, 3119, 1, 0, 0, 0, 492, 3122, 1, 0, 0, 0, 494, 3126, 1, 0, 0,
		0, 496, 3130, 1, 0, 0, 0, 498, 3136, 1, 0, 0, 0, 500, 3139, 1, 0, 0, 0,
		502, 3144, 1, 0, 0, 0, 504, 3148, 1, 0, 0, 0, 506, 3153, 1, 0, 0, 0, 508,
		3160, 1, 0, 0, 0, 510, 3167, 1, 0, 0, 0, 512, 3173, 1, 0, 0, 0, 514, 3216,
		1, 0, 0, 0, 516, 3218, 1, 0, 0, 0, 518, 3251, 1, 0, 0, 0, 520, 3257, 1,
		0, 0, 0, 522, 3264, 1, 0, 0, 0, 524, 3266, 1, 0, 0, 0, 526, 3268, 1, 0,
		0, 0, 528, 3283, 1, 0, 0, 0, 530, 3291, 1, 0, 0, 0, 532, 3293, 1, 0, 0,
		0, 534, 3300, 1, 0, 0, 0, 536, 3308, 1, 0, 0, 0, 538, 3312, 1, 0, 0, 0,
		540, 3320, 1, 0, 0, 0, 542, 3322, 1, 0, 0, 0, 544, 3338, 1, 0, 0, 0, 546,
		3340, 1, 0, 0, 0, 548, 3344, 1, 0, 0, 0, 550, 3357, 1, 0, 0, 0, 552, 3361,
		1, 0, 0, 0, 554, 3375, 1, 0, 0, 0, 556, 3377, 1, 0, 0, 0, 558, 3391, 1,
		0, 0, 0, 560, 3393, 1, 0, 0, 0, 562, 3406, 1, 0, 0, 0, 564, 3412, 1, 0,
		0, 0, 566, 3424, 1, 0, 0, 0, 568, 3442, 1, 0, 0, 0, 570, 3463, 1, 0, 0,
		0, 572, 3482, 1, 0, 0, 0, 574, 3485, 1, 0, 0, 0, 576, 3490, 1, 0, 0, 0,
		578, 3518, 1, 0, 0, 0, 580, 3567, 1, 0, 0, 0, 582, 3571, 1, 0, 0, 0, 584,
		3588, 1, 0, 0, 0, 586, 3590, 1, 0, 0, 0, 588, 3596, 1, 0, 0, 0, 590, 3610,
		1, 0, 0, 0, 592, 3612, 1, 0, 0, 0, 594, 3617, 1, 0, 0, 0, 596, 3624, 1,
		0, 0, 0, 598, 3639, 1, 0, 0, 0, 600, 3641, 1, 0, 0, 0, 602, 3647, 1, 0,
		0, 0, 604, 3665, 1, 0, 0, 0, 606, 3669, 1, 0, 0, 0, 608, 3677, 1, 0, 0,
		0, 610, 3681, 1, 0, 0, 0, 612, 3693, 1, 0, 0, 0, 614, 3695, 1, 0, 0, 0,
		616, 3700, 1, 0, 0, 0, 618, 3707, 1, 0, 0, 0, 620, 3715, 1, 0, 0, 0, 622,
		3731, 1, 0, 0, 0, 624, 3755, 1, 0, 0, 0, 626, 3765, 1, 0, 0, 0, 628, 3782,
		1, 0, 0, 0, 630, 3822, 1, 0, 0, 0, 632, 3828, 1, 0, 0, 0, 634, 3835, 1,
		0, 0, 0, 636, 3895, 1, 0, 0, 0, 638, 3900, 1, 0, 0, 0, 640, 3909, 1, 0,
		0, 0, 642, 3911, 1, 0, 0, 0, 644, 3915, 1, 0, 0, 0, 646, 3921, 1, 0, 0,
		0, 648, 3933, 1, 0, 0, 0, 650, 3950, 1, 0, 0, 0, 652, 3952, 1, 0, 0, 0,
		654, 3960, 1, 0, 0, 0, 656, 3964, 1, 0, 0, 0, 658, 3966, 1, 0, 0, 0, 660,
		3972, 1, 0, 0, 0, 662, 3983, 1, 0, 0, 0, 664, 3997, 1, 0, 0, 0, 666, 4008,
		1, 0, 0, 0, 668, 4010, 1, 0, 0, 0, 670, 4015, 1, 0, 0, 0, 672, 4035, 1,
		0, 0, 0, 674, 4037, 1, 0, 0, 0, 676, 4040, 1, 0, 0, 0, 678, 4045, 1, 0,
		0, 0, 680, 4052, 1, 0, 0, 0, 682, 4054, 1, 0, 0, 0, 684, 4058, 1, 0, 0,
		0, 686, 4063, 1, 0, 0, 0, 688, 4075, 1, 0, 0, 0, 690, 4080, 1, 0, 0, 0,
		692, 4092, 1, 0, 0, 0, 694, 4100, 1, 0, 0, 0, 696, 4108, 1, 0, 0, 0, 698,
		4112, 1, 0, 0, 0, 700, 4114, 1, 0, 0, 0, 702, 4119, 1, 0, 0, 0, 704, 4127,
		1, 0, 0, 0, 706, 4131, 1, 0, 0, 0, 708, 4136, 1, 0, 0, 0, 710, 4140, 1,
		0, 0, 0, 712, 4146, 1, 0, 0, 0, 714, 4148, 1, 0, 0, 0, 716, 4156, 1, 0,
		0, 0, 718, 4158, 1, 0, 0, 0, 720, 4160, 1, 0, 0, 0, 722, 4163, 1, 0, 0,
		0, 724, 4171, 1, 0, 0, 0, 726, 4175, 1, 0, 0, 0, 728, 4177, 1, 0, 0, 0,
		730, 4182, 1, 0, 0, 0, 732, 4193, 1, 0, 0, 0, 734, 4195, 1, 0, 0, 0, 736,
		4202, 1, 0, 0, 0, 738, 4204, 1, 0, 0, 0, 740, 4209, 1, 0, 0, 0, 742, 4213,
		1, 0, 0, 0, 744, 4215, 1, 0, 0, 0, 746, 4227, 1, 0, 0, 0, 748, 4239, 1,
		0, 0, 0, 750, 4241, 1, 0, 0, 0, 752, 4249, 1, 0, 0, 0, 754, 4251, 1, 0,
		0, 0, 756, 4257, 1, 0, 0, 0, 758, 4259, 1, 0, 0, 0, 760, 4261, 1, 0, 0,
		0, 762, 4268, 1, 0, 0, 0, 764, 4279, 1, 0, 0, 0, 766, 4282, 1, 0, 0, 0,
		768, 4286, 1, 0, 0, 0, 770, 4295, 1, 0, 0, 0, 772, 4303, 1, 0, 0, 0, 774,
		4310, 1, 0, 0, 0, 776, 4320, 1, 0, 0, 0, 778, 4329, 1, 0, 0, 0, 780, 4338,
		1, 0, 0, 0, 782, 4348, 1, 0, 0, 0, 784, 4352, 1, 0, 0, 0, 786, 4356, 1,
		0, 0, 0, 788, 4360, 1, 0, 0, 0, 790, 4364, 1, 0, 0, 0, 792, 4368, 1, 0,
		0, 0, 794, 4372, 1, 0, 0, 0, 796, 4376, 1, 0, 0, 0, 798, 4380, 1, 0, 0,
		0, 800, 4384, 1, 0, 0, 0, 802, 4388, 1, 0, 0, 0, 804, 4392, 1, 0, 0, 0,
		806, 4396, 1, 0, 0, 0, 808, 4401, 1, 0, 0, 0, 810, 4406, 1, 0, 0, 0, 812,
		4411, 1, 0, 0, 0, 814, 4419, 1, 0, 0, 0, 816, 4424, 1, 0, 0, 0, 818, 4427,
		1, 0, 0, 0, 820, 4433, 1, 0, 0, 0, 822, 4436, 1, 0, 0, 0, 824, 4448, 1,
		0, 0, 0, 826, 4450, 1, 0, 0, 0, 828, 4452, 1, 0, 0, 0, 830, 4454, 1, 0,
		0, 0, 832, 4456, 1, 0, 0, 0, 834, 4458, 1, 0, 0, 0, 836, 4460, 1, 0, 0,
		0, 838, 4462, 1, 0, 0, 0, 840, 4464, 1, 0, 0, 0, 842, 4466, 1, 0, 0, 0,
		844, 4468, 1, 0, 0, 0, 846, 4470, 1, 0, 0, 0, 848, 4472, 1, 0, 0, 0, 850,
		4474, 1, 0, 0, 0, 852, 858, 3, 2, 1, 0, 853, 854, 5, 228, 0, 0, 854, 855,
		5, 51, 0, 0, 855, 856, 5, 325, 0, 0, 856, 858, 3, 4, 2, 0, 857, 852, 1,
		0, 0, 0, 857, 853, 1, 0, 0, 0, 858, 1, 1, 0, 0, 0, 859, 861, 5, 23, 0,
		0, 860, 859, 1, 0, 0, 0, 861, 864, 1, 0, 0, 0, 862, 860, 1, 0, 0, 0, 862,
		863, 1, 0, 0, 0, 863, 865, 1, 0, 0, 0, 864, 862, 1, 0, 0, 0, 865, 874,
		3, 10, 5, 0, 866, 868, 5, 23, 0, 0, 867, 866, 1, 0, 0, 0, 868, 869, 1,
		0, 0, 0, 869, 867, 1, 0, 0, 0, 869, 870, 1, 0, 0, 0, 870, 871, 1, 0, 0,
		0, 871, 873, 3, 10, 5, 0, 872, 867, 1, 0, 0, 0, 873, 876, 1, 0, 0, 0, 874,
		872, 1, 0, 0, 0, 874, 875, 1, 0, 0, 0, 875, 880, 1, 0, 0, 0, 876, 874,
		1, 0, 0, 0, 877, 879, 5, 23, 0, 0, 878, 877, 1, 0, 0, 0, 879, 882, 1, 0,
		0, 0, 880, 878, 1, 0, 0, 0, 880, 881, 1, 0, 0, 0, 881, 883, 1, 0, 0, 0,
		882, 880, 1, 0, 0, 0, 883, 884, 5, 0, 0, 1, 884, 3, 1, 0, 0, 0, 885, 887,
		5, 23, 0, 0, 886, 885, 1, 0, 0, 0, 887, 890, 1, 0, 0, 0, 888, 886, 1, 0,
		0, 0, 888, 889, 1, 0, 0, 0, 889, 891, 1, 0, 0, 0, 890, 888, 1, 0, 0, 0,
		891, 892, 5, 0, 0, 1, 892, 5, 1, 0, 0, 0, 893, 895, 5, 23, 0, 0, 894, 893,
		1, 0, 0, 0, 895, 898, 1, 0, 0, 0, 896, 894, 1, 0, 0, 0, 896, 897, 1, 0,
		0, 0, 897, 907, 1, 0, 0, 0, 898, 896, 1, 0, 0, 0, 899, 901, 3, 8, 4, 0,
		900, 902, 5, 23, 0, 0, 901, 900, 1, 0, 0, 0, 902, 903, 1, 0, 0, 0, 903,
		901, 1, 0, 0, 0, 903, 904, 1, 0, 0, 0, 904, 906, 1, 0, 0, 0, 905, 899,
		1, 0, 0, 0, 906, 909, 1, 0, 0, 0, 907, 905, 1, 0, 0, 0, 907, 908, 1, 0,
		0, 0, 908, 910, 1, 0, 0, 0, 909, 907, 1, 0, 0, 0, 910, 911, 5, 253, 0,
		0, 911, 915, 3, 14, 7, 0, 912, 914, 5, 23, 0, 0, 913, 912, 1, 0, 0, 0,
		914, 917, 1, 0, 0, 0, 915, 913, 1, 0, 0, 0, 915, 916, 1, 0, 0, 0, 916,
		7, 1, 0, 0, 0, 917, 915, 1, 0, 0, 0, 918, 921, 3, 754, 377, 0, 919, 921,
		3, 214, 107, 0, 920, 918, 1, 0, 0, 0, 920, 919, 1, 0, 0, 0, 921, 9, 1,
		0, 0, 0, 922, 929, 5, 132, 0, 0, 923, 924, 5, 329, 0, 0, 924, 925, 5, 330,
		0, 0, 925, 926, 5, 331, 0, 0, 926, 927, 5, 332, 0, 0, 927, 928, 5, 333,
		0, 0, 928, 930, 5, 226, 0, 0, 929, 923, 1, 0, 0, 0, 929, 930, 1, 0, 0,
		0, 930, 932, 1, 0, 0, 0, 931, 922, 1, 0, 0, 0, 931, 932, 1, 0, 0, 0, 932,
		933, 1, 0, 0, 0, 933, 934, 3, 12, 6, 0, 934, 11, 1, 0, 0, 0, 935, 992,
		3, 224, 112, 0, 936, 992, 3, 232, 116, 0, 937, 992, 3, 754, 377, 0, 938,
		992, 3, 416, 208, 0, 939, 992, 3, 560, 280, 0, 940, 992, 3, 750, 375, 0,
		941, 992, 3, 364, 182, 0, 942, 992, 3, 756, 378, 0, 943, 992, 3, 648, 324,
		0, 944, 992, 3, 646, 323, 0, 945, 992, 3, 758, 379, 0, 946, 992, 3, 210,
		105, 0, 947, 992, 3, 214, 107, 0, 948, 992, 3, 216, 108, 0, 949, 992, 3,
		460, 230, 0, 950, 992, 3, 464, 232, 0, 951, 992, 3, 222, 111, 0, 952, 992,
		3, 620, 310, 0, 953, 992, 3, 624, 312, 0, 954, 992, 3, 626, 313, 0, 955,
		992, 3, 368, 184, 0, 956, 992, 3, 562, 281, 0, 957, 992, 3, 564, 282, 0,
		958, 992, 3, 566, 283, 0, 959, 992, 3, 568, 284, 0, 960, 992, 3, 570, 285,
		0, 961, 992, 3, 392, 196, 0, 962, 992, 3, 396, 198, 0, 963, 992, 3, 400,
		200, 0, 964, 992, 3, 378, 189, 0, 965, 992, 3, 380, 190, 0, 966, 992, 3,
		384, 192, 0, 967, 992, 3, 602, 301, 0, 968, 992, 3, 616, 308, 0, 969, 992,
		3, 662, 331, 0, 970, 992, 3, 670, 335, 0, 971, 992, 3, 692, 346, 0, 972,
		992, 3, 576, 288, 0, 973, 992, 3, 578, 289, 0, 974, 992, 3, 468, 234, 0,
		975, 992, 3, 390, 195, 0, 976, 992, 3, 386, 193, 0, 977, 992, 3, 388, 194,
		0, 978, 992, 3, 610, 305, 0, 979, 992, 3, 586, 293, 0, 980, 992, 3, 588,
		294, 0, 981, 992, 3, 592, 296, 0, 982, 992, 3, 420, 210, 0, 983, 992, 3,
		422, 211, 0, 984, 992, 3, 424, 212, 0, 985, 992, 3, 764, 382, 0, 986, 992,
		3, 594, 297, 0, 987, 992, 3, 596, 298, 0, 988, 992, 3, 600, 300, 0, 989,
		992, 3, 444, 222, 0, 990, 992, 3, 446, 223, 0, 991, 935, 1, 0, 0, 0, 991,
		936, 1, 0, 0, 0, 991, 937, 1, 0, 0, 0, 991, 938, 1, 0, 0, 0, 991, 939,
		1, 0, 0, 0, 991, 940, 1, 0, 0, 0, 991, 941, 1, 0, 0, 0, 991, 942, 1, 0,
		0, 0, 991, 943, 1, 0, 0, 0, 991, 944, 1, 0, 0, 0, 991, 945, 1, 0, 0, 0,
		991, 946, 1, 0, 0, 0, 991, 947, 1, 0, 0, 0, 991, 948, 1, 0, 0, 0, 991,
		949, 1, 0, 0, 0, 991, 950, 1, 0, 0, 0, 991, 951, 1, 0, 0, 0, 991, 952,
		1, 0, 0, 0, 991, 953, 1, 0, 0, 0, 991, 954, 1, 0, 0, 0, 991, 955, 1, 0,
		0, 0, 991, 956, 1, 0, 0, 0, 991, 957, 1, 0, 0, 0, 991, 958, 1, 0, 0, 0,
		991, 959, 1, 0, 0, 0, 991, 960, 1, 0, 0, 0, 991, 961, 1, 0, 0, 0, 991,
		962, 1, 0, 0, 0, 991, 963, 1, 0, 0, 0, 991, 964, 1, 0, 0, 0, 991, 965,
		1, 0, 0, 0, 991, 966, 1, 0, 0, 0, 991, 967, 1, 0, 0, 0, 991, 968, 1, 0,
		0, 0, 991, 969, 1, 0, 0, 0, 991, 970, 1, 0, 0, 0, 991, 971, 1, 0, 0, 0,
		991, 972, 1, 0, 0, 0, 991, 973, 1, 0, 0, 0, 991, 974, 1, 0, 0, 0, 991,
		975, 1, 0, 0, 0, 991, 976, 1, 0, 0, 0, 991, 977, 1, 0, 0, 0, 991, 978,
		1, 0, 0, 0, 991, 979, 1, 0, 0, 0, 991, 980, 1, 0, 0, 0, 991, 981, 1, 0,
		0, 0, 991, 982, 1, 0, 0, 0, 991, 983, 1, 0, 0, 0, 991, 984, 1, 0, 0, 0,
		991, 985, 1, 0, 0, 0, 991, 986, 1, 0, 0, 0, 991, 987, 1, 0, 0, 0, 991,
		988, 1, 0, 0, 0, 991, 989, 1, 0, 0, 0, 991, 990, 1, 0, 0, 0, 992, 13, 1,
		0, 0, 0, 993, 998, 3, 16, 8, 0, 994, 995, 5, 213, 0, 0, 995, 997, 3, 16,
		8, 0, 996, 994, 1, 0, 0, 0, 997, 1000, 1, 0, 0, 0, 998, 996, 1, 0, 0, 0,
		998, 999, 1, 0, 0, 0, 999, 1003, 1, 0, 0, 0, 1000, 998, 1, 0, 0, 0, 1001,
		1003, 3, 200, 100, 0, 1002, 993, 1, 0, 0, 0, 1002, 1001, 1, 0, 0, 0, 1003,
		15, 1, 0, 0, 0, 1004, 1009, 3, 18, 9, 0, 1005, 1006, 5, 50, 0, 0, 1006,
		1008, 3, 18, 9, 0, 1007, 1005, 1, 0, 0, 0, 1008, 1011, 1, 0, 0, 0, 1009,
		1007, 1, 0, 0, 0, 1009, 1010, 1, 0, 0, 0, 1010, 17, 1, 0, 0, 0, 1011, 1009,
		1, 0, 0, 0, 1012, 1017, 3, 20, 10, 0, 1013, 1014, 5, 321, 0, 0, 1014, 1016,
		3, 20, 10, 0, 1015, 1013, 1, 0, 0, 0, 1016, 1019, 1, 0, 0, 0, 1017, 1015,
		1, 0, 0, 0, 1017, 1018, 1, 0, 0, 0, 1018, 19, 1, 0, 0, 0, 1019, 1017, 1,
		0, 0, 0, 1020, 1022, 3, 28, 14, 0, 1021, 1023, 3, 24, 12, 0, 1022, 1021,
		1, 0, 0, 0, 1022, 1023, 1, 0, 0, 0, 1023, 21, 1, 0, 0, 0, 1024, 1026, 5,
		174, 0, 0, 1025, 1027, 5, 200, 0, 0, 1026, 1025, 1, 0, 0, 0, 1026, 1027,
		1, 0, 0, 0, 1027, 1028, 1, 0, 0, 0, 1028, 1029, 5, 113, 0, 0, 1029, 1030,
		5, 145, 0, 0, 1030, 23, 1, 0, 0, 0, 1031, 1033, 5, 200, 0, 0, 1032, 1031,
		1, 0, 0, 0, 1032, 1033, 1, 0, 0, 0, 1033, 1034, 1, 0, 0, 0, 1034, 1035,
		3, 26, 13, 0, 1035, 1038, 3, 28, 14, 0, 1036, 1037, 5, 125, 0, 0, 1037,
		1039, 3, 28, 14, 0, 1038, 1036, 1, 0, 0, 0, 1038, 1039, 1, 0, 0, 0, 1039,
		1083, 1, 0, 0, 0, 1040, 1042, 5, 200, 0, 0, 1041, 1040, 1, 0, 0, 0, 1041,
		1042, 1, 0, 0, 0, 1042, 1043, 1, 0, 0, 0, 1043, 1045, 5, 162, 0, 0, 1044,
		1046, 5, 83, 0, 0, 1045, 1044, 1, 0, 0, 0, 1045, 1046, 1, 0, 0, 0, 1046,
		1047, 1, 0, 0, 0, 1047, 1083, 3, 82, 41, 0, 1048, 1058, 5, 175, 0, 0, 1049,
		1058, 5, 201, 0, 0, 1050, 1051, 5, 174, 0, 0, 1051, 1058, 5, 202, 0, 0,
		1052, 1054, 5, 174, 0, 0, 1053, 1052, 1, 0, 0, 0, 1053, 1054, 1, 0, 0,
		0, 1054, 1055, 1, 0, 0, 0, 1055, 1056, 5, 200, 0, 0, 1056, 1058, 5, 202,
		0, 0, 1057, 1048, 1, 0, 0, 0, 1057, 1049, 1, 0, 0, 0, 1057, 1050, 1, 0,
		0, 0, 1057, 1053, 1, 0, 0, 0, 1058, 1083, 1, 0, 0, 0, 1059, 1061, 5, 200,
		0, 0, 1060, 1059, 1, 0, 0, 0, 1060, 1061, 1, 0, 0, 0, 1061, 1062, 1, 0,
		0, 0, 1062, 1064, 5, 69, 0, 0, 1063, 1065, 7, 0, 0, 0, 1064, 1063, 1, 0,
		0, 0, 1064, 1065, 1, 0, 0, 0, 1065, 1066, 1, 0, 0, 0, 1066, 1067, 3, 28,
		14, 0, 1067, 1068, 5, 50, 0, 0, 1068, 1069, 3, 28, 14, 0, 1069, 1083, 1,
		0, 0, 0, 1070, 1076, 5, 1, 0, 0, 1071, 1076, 5, 2, 0, 0, 1072, 1076, 5,
		3, 0, 0, 1073, 1076, 5, 4, 0, 0, 1074, 1076, 3, 22, 11, 0, 1075, 1070,
		1, 0, 0, 0, 1075, 1071, 1, 0, 0, 0, 1075, 1072, 1, 0, 0, 0, 1075, 1073,
		1, 0, 0, 0, 1075, 1074, 1, 0, 0, 0, 1076, 1077, 1, 0, 0, 0, 1077, 1079,
		3, 28, 14, 0, 1078, 1075, 1, 0, 0, 0, 1079, 1080, 1, 0, 0, 0, 1080, 1078,
		1, 0, 0, 0, 1080, 1081, 1, 0, 0, 0, 1081, 1083, 1, 0, 0, 0, 1082, 1032,
		1, 0, 0, 0, 1082, 1041, 1, 0, 0, 0, 1082, 1057, 1, 0, 0, 0, 1082, 1060,
		1, 0, 0, 0, 1082, 1078, 1, 0, 0, 0, 1083, 25, 1, 0, 0, 0, 1084, 1085, 7,
		1, 0, 0, 1085, 27, 1, 0, 0, 0, 1086, 1091, 3, 36, 18, 0, 1087, 1088, 7,
		2, 0, 0, 1088, 1090, 3, 36, 18, 0, 1089, 1087, 1, 0, 0, 0, 1090, 1093,
		1, 0, 0, 0, 1091, 1089, 1, 0, 0, 0, 1091, 1092, 1, 0, 0, 0, 1092, 29, 1,
		0, 0, 0, 1093, 1091, 1, 0, 0, 0, 1094, 1095, 5, 7, 0, 0, 1095, 1096, 5,
		7, 0, 0, 1096, 31, 1, 0, 0, 0, 1097, 1098, 5, 7, 0, 0, 1098, 1099, 5, 7,
		0, 0, 1099, 1100, 5, 12, 0, 0, 1100, 33, 1, 0, 0, 0, 1101, 1102, 5, 28,
		0, 0, 1102, 1103, 5, 28, 0, 0, 1103, 35, 1, 0, 0, 0, 1104, 1117, 3, 38,
		19, 0, 1105, 1113, 5, 9, 0, 0, 1106, 1113, 3, 30, 15, 0, 1107, 1113, 5,
		10, 0, 0, 1108, 1113, 3, 32, 16, 0, 1109, 1113, 5, 11, 0, 0, 1110, 1113,
		5, 12, 0, 0, 1111, 1113, 5, 38, 0, 0, 1112, 1105, 1, 0, 0, 0, 1112, 1106,
		1, 0, 0, 0, 1112, 1107, 1, 0, 0, 0, 1112, 1108, 1, 0, 0, 0, 1112, 1109,
		1, 0, 0, 0, 1112, 1110, 1, 0, 0, 0, 1112, 1111, 1, 0, 0, 0, 1113, 1114,
		1, 0, 0, 0, 1114, 1116, 3, 38, 19, 0, 1115, 1112, 1, 0, 0, 0, 1116, 1119,
		1, 0, 0, 0, 1117, 1115, 1, 0, 0, 0, 1117, 1118, 1, 0, 0, 0, 1118, 1128,
		1, 0, 0, 0, 1119, 1117, 1, 0, 0, 0, 1120, 1121, 3, 34, 17, 0, 1121, 1122,
		3, 36, 18, 0, 1122, 1129, 1, 0, 0, 0, 1123, 1125, 5, 28, 0, 0, 1124, 1123,
		1, 0, 0, 0, 1125, 1126, 1, 0, 0, 0, 1126, 1124, 1, 0, 0, 0, 1126, 1127,
		1, 0, 0, 0, 1127, 1129, 1, 0, 0, 0, 1128, 1120, 1, 0, 0, 0, 1128, 1124,
		1, 0, 0, 0, 1128, 1129, 1, 0, 0, 0, 1129, 37, 1, 0, 0, 0, 1130, 1135, 3,
		40, 20, 0, 1131, 1132, 7, 3, 0, 0, 1132, 1134, 3, 40, 20, 0, 1133, 1131,
		1, 0, 0, 0, 1134, 1137, 1, 0, 0, 0, 1135, 1133, 1, 0, 0, 0, 1135, 1136,
		1, 0, 0, 0, 1136, 39, 1, 0, 0, 0, 1137, 1135, 1, 0, 0, 0, 1138, 1143, 3,
		42, 21, 0, 1139, 1140, 7, 4, 0, 0, 1140, 1142, 3, 42, 21, 0, 1141, 1139,
		1, 0, 0, 0, 1142, 1145, 1, 0, 0, 0, 1143, 1141, 1, 0, 0, 0, 1143, 1144,
		1, 0, 0, 0, 1144, 41, 1, 0, 0, 0, 1145, 1143, 1, 0, 0, 0, 1146, 1151, 3,
		44, 22, 0, 1147, 1148, 5, 13, 0, 0, 1148, 1150, 3, 44, 22, 0, 1149, 1147,
		1, 0, 0, 0, 1150, 1153, 1, 0, 0, 0, 1151, 1149, 1, 0, 0, 0, 1151, 1152,
		1, 0, 0, 0, 1152, 43, 1, 0, 0, 0, 1153, 1151, 1, 0, 0, 0, 1154, 1159, 3,
		54, 27, 0, 1155, 1156, 3, 46, 23, 0, 1156, 1157, 3, 54, 27, 0, 1157, 1159,
		1, 0, 0, 0, 1158, 1154, 1, 0, 0, 0, 1158, 1155, 1, 0, 0, 0, 1159, 45, 1,
		0, 0, 0, 1160, 1161, 7, 5, 0, 0, 1161, 47, 1, 0, 0, 0, 1162, 1171, 3, 138,
		69, 0, 1163, 1171, 3, 132, 66, 0, 1164, 1168, 5, 24, 0, 0, 1165, 1169,
		3, 144, 72, 0, 1166, 1169, 5, 325, 0, 0, 1167, 1169, 3, 788, 394, 0, 1168,
		1165, 1, 0, 0, 0, 1168, 1166, 1, 0, 0, 0, 1168, 1167, 1, 0, 0, 0, 1169,
		1171, 1, 0, 0, 0, 1170, 1162, 1, 0, 0, 0, 1170, 1163, 1, 0, 0, 0, 1170,
		1164, 1, 0, 0, 0, 1171, 1173, 1, 0, 0, 0, 1172, 1170, 1, 0, 0, 0, 1173,
		1176, 1, 0, 0, 0, 1174, 1172, 1, 0, 0, 0, 1174, 1175, 1, 0, 0, 0, 1175,
		1179, 1, 0, 0, 0, 1176, 1174, 1, 0, 0, 0, 1177, 1178, 5, 79, 0, 0, 1178,
		1180, 3, 786, 393, 0, 1179, 1177, 1, 0, 0, 0, 1179, 1180, 1, 0, 0, 0, 1180,
		49, 1, 0, 0, 0, 1181, 1184, 3, 772, 386, 0, 1182, 1184, 3, 68, 34, 0, 1183,
		1181, 1, 0, 0, 0, 1183, 1182, 1, 0, 0, 0, 1184, 1185, 1, 0, 0, 0, 1185,
		1186, 3, 48, 24, 0, 1186, 51, 1, 0, 0, 0, 1187, 1190, 3, 774, 387, 0, 1188,
		1190, 3, 70, 35, 0, 1189, 1187, 1, 0, 0, 0, 1189, 1188, 1, 0, 0, 0, 1190,
		1191, 1, 0, 0, 0, 1191, 1192, 3, 48, 24, 0, 1192, 53, 1, 0, 0, 0, 1193,
		1196, 3, 50, 25, 0, 1194, 1196, 3, 84, 42, 0, 1195, 1193, 1, 0, 0, 0, 1195,
		1194, 1, 0, 0, 0, 1196, 55, 1, 0, 0, 0, 1197, 1200, 3, 52, 26, 0, 1198,
		1200, 3, 84, 42, 0, 1199, 1197, 1, 0, 0, 0, 1199, 1198, 1, 0, 0, 0, 1200,
		57, 1, 0, 0, 0, 1201, 1203, 5, 42, 0, 0, 1202, 1204, 3, 112, 56, 0, 1203,
		1202, 1, 0, 0, 0, 1203, 1204, 1, 0, 0, 0, 1204, 1206, 1, 0, 0, 0, 1205,
		1207, 5, 25, 0, 0, 1206, 1205, 1, 0, 0, 0, 1206, 1207, 1, 0, 0, 0, 1207,
		1208, 1, 0, 0, 0, 1208, 1209, 5, 41, 0, 0, 1209, 59, 1, 0, 0, 0, 1210,
		1213, 3, 14, 7, 0, 1211, 1212, 5, 29, 0, 0, 1212, 1214, 3, 14, 7, 0, 1213,
		1211, 1, 0, 0, 0, 1213, 1214, 1, 0, 0, 0, 1214, 1223, 1, 0, 0, 0, 1215,
		1216, 5, 25, 0, 0, 1216, 1219, 3, 14, 7, 0, 1217, 1218, 5, 29, 0, 0, 1218,
		1220, 3, 14, 7, 0, 1219, 1217, 1, 0, 0, 0, 1219, 1220, 1, 0, 0, 0, 1220,
		1222, 1, 0, 0, 0, 1221, 1215, 1, 0, 0, 0, 1222, 1225, 1, 0, 0, 0, 1223,
		1221, 1, 0, 0, 0, 1223, 1224, 1, 0, 0, 0, 1224, 61, 1, 0, 0, 0, 1225, 1223,
		1, 0, 0, 0, 1226, 1228, 5, 36, 0, 0, 1227, 1229, 3, 60, 30, 0, 1228, 1227,
		1, 0, 0, 0, 1228, 1229, 1, 0, 0, 0, 1229, 1231, 1, 0, 0, 0, 1230, 1232,
		5, 25, 0, 0, 1231, 1230, 1, 0, 0, 0, 1231, 1232, 1, 0, 0, 0, 1232, 1233,
		1, 0, 0, 0, 1233, 1234, 5, 37, 0, 0, 1234, 63, 1, 0, 0, 0, 1235, 1236,
		3, 14, 7, 0, 1236, 1237, 5, 29, 0, 0, 1237, 1245, 3, 14, 7, 0, 1238, 1239,
		5, 25, 0, 0, 1239, 1240, 3, 14, 7, 0, 1240, 1241, 5, 29, 0, 0, 1241, 1242,
		3, 14, 7, 0, 1242, 1244, 1, 0, 0, 0, 1243, 1238, 1, 0, 0, 0, 1244, 1247,
		1, 0, 0, 0, 1245, 1243, 1, 0, 0, 0, 1245, 1246, 1, 0, 0, 0, 1246, 65, 1,
		0, 0, 0, 1247, 1245, 1, 0, 0, 0, 1248, 1250, 5, 14, 0, 0, 1249, 1251, 3,
		64, 32, 0, 1250, 1249, 1, 0, 0, 0, 1250, 1251, 1, 0, 0, 0, 1251, 1253,
		1, 0, 0, 0, 1252, 1254, 5, 25, 0, 0, 1253, 1252, 1, 0, 0, 0, 1253, 1254,
		1, 0, 0, 0, 1254, 1255, 1, 0, 0, 0, 1255, 1256, 5, 15, 0, 0, 1256, 67,
		1, 0, 0, 0, 1257, 1275, 3, 142, 71, 0, 1258, 1275, 3, 144, 72, 0, 1259,
		1275, 3, 80, 40, 0, 1260, 1275, 3, 72, 36, 0, 1261, 1275, 3, 76, 38, 0,
		1262, 1275, 3, 78, 39, 0, 1263, 1264, 3, 788, 394, 0, 1264, 1267, 5, 39,
		0, 0, 1265, 1268, 3, 814, 407, 0, 1266, 1268, 5, 322, 0, 0, 1267, 1265,
		1, 0, 0, 0, 1267, 1266, 1, 0, 0, 0, 1268, 1275, 1, 0, 0, 0, 1269, 1275,
		3, 208, 104, 0, 1270, 1275, 3, 74, 37, 0, 1271, 1275, 3, 58, 29, 0, 1272,
		1275, 3, 62, 31, 0, 1273, 1275, 3, 66, 33, 0, 1274, 1257, 1, 0, 0, 0, 1274,
		1258, 1, 0, 0, 0, 1274, 1259, 1, 0, 0, 0, 1274, 1260, 1, 0, 0, 0, 1274,
		1261, 1, 0, 0, 0, 1274, 1262, 1, 0, 0, 0, 1274, 1263, 1, 0, 0, 0, 1274,
		1269, 1, 0, 0, 0, 1274, 1270, 1, 0, 0, 0, 1274, 1271, 1, 0, 0, 0, 1274,
		1272, 1, 0, 0, 0, 1274, 1273, 1, 0, 0, 0, 1275, 69, 1, 0, 0, 0, 1276, 1297,
		3, 142, 71, 0, 1277, 1297, 3, 144, 72, 0, 1278, 1297, 3, 80, 40, 0, 1279,
		1297, 3, 72, 36, 0, 1280, 1297, 3, 78, 39, 0, 1281, 1282, 3, 788, 394,
		0, 1282, 1285, 5, 39, 0, 0, 1283, 1286, 3, 814, 407, 0, 1284, 1286, 5,
		322, 0, 0, 1285, 1283, 1, 0, 0, 0, 1285, 1284, 1, 0, 0, 0, 1286, 1297,
		1, 0, 0, 0, 1287, 1288, 5, 26, 0, 0, 1288, 1289, 3, 232, 116, 0, 1289,
		1290, 5, 27, 0, 0, 1290, 1297, 1, 0, 0, 0, 1291, 1297, 3, 208, 104, 0,
		1292, 1297, 3, 74, 37, 0, 1293, 1297, 3, 58, 29, 0, 1294, 1297, 3, 62,
		31, 0, 1295, 1297, 3, 66, 33, 0, 1296, 1276, 1, 0, 0, 0, 1296, 1277, 1,
		0, 0, 0, 1296, 1278, 1, 0, 0, 0, 1296, 1279, 1, 0, 0, 0, 1296, 1280, 1,
		0, 0, 0, 1296, 1281, 1, 0, 0, 0, 1296, 1287, 1, 0, 0, 0, 1296, 1291, 1,
		0, 0, 0, 1296, 1292, 1, 0, 0, 0, 1296, 1293, 1, 0, 0, 0, 1296, 1294, 1,
		0, 0, 0, 1296, 1295, 1, 0, 0, 0, 1297, 71, 1, 0, 0, 0, 1298, 1299, 5, 75,
		0, 0, 1299, 1300, 5, 26, 0, 0, 1300, 1301, 3, 14, 7, 0, 1301, 1302, 5,
		54, 0, 0, 1302, 1303, 3, 204, 102, 0, 1303, 1304, 5, 27, 0, 0, 1304, 73,
		1, 0, 0, 0, 1305, 1306, 5, 70, 0, 0, 1306, 1307, 5, 26, 0, 0, 1307, 1308,
		3, 14, 7, 0, 1308, 1309, 5, 54, 0, 0, 1309, 1310, 3, 156, 78, 0, 1310,
		1311, 5, 27, 0, 0, 1311, 75, 1, 0, 0, 0, 1312, 1313, 5, 131, 0, 0, 1313,
		1316, 5, 26, 0, 0, 1314, 1317, 3, 232, 116, 0, 1315, 1317, 3, 368, 184,
		0, 1316, 1314, 1, 0, 0, 0, 1316, 1315, 1, 0, 0, 0, 1317, 1318, 1, 0, 0,
		0, 1318, 1319, 5, 27, 0, 0, 1319, 77, 1, 0, 0, 0, 1320, 1322, 5, 74, 0,
		0, 1321, 1323, 3, 14, 7, 0, 1322, 1321, 1, 0, 0, 0, 1322, 1323, 1, 0, 0,
		0, 1323, 1325, 1, 0, 0, 0, 1324, 1326, 3, 140, 70, 0, 1325, 1324, 1, 0,
		0, 0, 1326, 1327, 1, 0, 0, 0, 1327, 1325, 1, 0, 0, 0, 1327, 1328, 1, 0,
		0, 0, 1328, 1331, 1, 0, 0, 0, 1329, 1330, 5, 117, 0, 0, 1330, 1332, 3,
		14, 7, 0, 1331, 1329, 1, 0, 0, 0, 1331, 1332, 1, 0, 0, 0, 1332, 1333, 1,
		0, 0, 0, 1333, 1334, 5, 121, 0, 0, 1334, 79, 1, 0, 0, 0, 1335, 1347, 3,
		110, 55, 0, 1336, 1345, 5, 40, 0, 0, 1337, 1338, 5, 26, 0, 0, 1338, 1339,
		3, 14, 7, 0, 1339, 1340, 5, 27, 0, 0, 1340, 1346, 1, 0, 0, 0, 1341, 1342,
		5, 36, 0, 0, 1342, 1343, 3, 6, 3, 0, 1343, 1344, 5, 37, 0, 0, 1344, 1346,
		1, 0, 0, 0, 1345, 1337, 1, 0, 0, 0, 1345, 1341, 1, 0, 0, 0, 1346, 1348,
		1, 0, 0, 0, 1347, 1336, 1, 0, 0, 0, 1347, 1348, 1, 0, 0, 0, 1348, 81, 1,
		0, 0, 0, 1349, 1350, 3, 56, 28, 0, 1350, 83, 1, 0, 0, 0, 1351, 1355, 3,
		98, 49, 0, 1352, 1355, 3, 102, 51, 0, 1353, 1355, 3, 108, 54, 0, 1354,
		1351, 1, 0, 0, 0, 1354, 1352, 1, 0, 0, 0, 1354, 1353, 1, 0, 0, 0, 1355,
		85, 1, 0, 0, 0, 1356, 1357, 5, 322, 0, 0, 1357, 87, 1, 0, 0, 0, 1358, 1361,
		3, 772, 386, 0, 1359, 1361, 5, 322, 0, 0, 1360, 1358, 1, 0, 0, 0, 1360,
		1359, 1, 0, 0, 0, 1361, 89, 1, 0, 0, 0, 1362, 1363, 3, 14, 7, 0, 1363,
		1364, 5, 54, 0, 0, 1364, 1365, 3, 88, 44, 0, 1365, 91, 1, 0, 0, 0, 1366,
		1371, 3, 90, 45, 0, 1367, 1368, 5, 25, 0, 0, 1368, 1370, 3, 90, 45, 0,
		1369, 1367, 1, 0, 0, 0, 1370, 1373, 1, 0, 0, 0, 1371, 1369, 1, 0, 0, 0,
		1371, 1372, 1, 0, 0, 0, 1372, 93, 1, 0, 0, 0, 1373, 1371, 1, 0, 0, 0, 1374,
		1375, 3, 14, 7, 0, 1375, 1376, 5, 25, 0, 0, 1376, 1379, 3, 86, 43, 0, 1377,
		1378, 5, 220, 0, 0, 1378, 1380, 3, 92, 46, 0, 1379, 1377, 1, 0, 0, 0, 1379,
		1380, 1, 0, 0, 0, 1380, 95, 1, 0, 0, 0, 1381, 1386, 5, 124, 0, 0, 1382,
		1386, 5, 202, 0, 0, 1383, 1384, 5, 101, 0, 0, 1384, 1386, 3, 14, 7, 0,
		1385, 1381, 1, 0, 0, 0, 1385, 1382, 1, 0, 0, 0, 1385, 1383, 1, 0, 0, 0,
		1386, 97, 1, 0, 0, 0, 1387, 1388, 5, 179, 0, 0, 1388, 1389, 5, 26, 0, 0,
		1389, 1392, 3, 94, 47, 0, 1390, 1391, 5, 254, 0, 0, 1391, 1393, 3, 156,
		78, 0, 1392, 1390, 1, 0, 0, 0, 1392, 1393, 1, 0, 0, 0, 1393, 1400, 1, 0,
		0, 0, 1394, 1395, 3, 96, 48, 0, 1395, 1396, 5, 208, 0, 0, 1396, 1397, 7,
		6, 0, 0, 1397, 1399, 1, 0, 0, 0, 1398, 1394, 1, 0, 0, 0, 1399, 1402, 1,
		0, 0, 0, 1400, 1398, 1, 0, 0, 0, 1400, 1401, 1, 0, 0, 0, 1401, 1403, 1,
		0, 0, 0, 1402, 1400, 1, 0, 0, 0, 1403, 1404, 5, 27, 0, 0, 1404, 99, 1,
		0, 0, 0, 1405, 1406, 7, 7, 0, 0, 1406, 1407, 5, 208, 0, 0, 1407, 1408,
		5, 124, 0, 0, 1408, 101, 1, 0, 0, 0, 1409, 1410, 5, 177, 0, 0, 1410, 1411,
		5, 26, 0, 0, 1411, 1413, 3, 94, 47, 0, 1412, 1414, 3, 100, 50, 0, 1413,
		1412, 1, 0, 0, 0, 1413, 1414, 1, 0, 0, 0, 1414, 1415, 1, 0, 0, 0, 1415,
		1416, 5, 27, 0, 0, 1416, 103, 1, 0, 0, 0, 1417, 1419, 5, 319, 0, 0, 1418,
		1420, 5, 53, 0, 0, 1419, 1418, 1, 0, 0, 0, 1419, 1420, 1, 0, 0, 0, 1420,
		1429, 1, 0, 0, 0, 1421, 1423, 5, 318, 0, 0, 1422, 1424, 7, 8, 0, 0, 1423,
		1422, 1, 0, 0, 0, 1423, 1424, 1, 0, 0, 0, 1424, 1426, 1, 0, 0, 0, 1425,
		1427, 5, 53, 0, 0, 1426, 1425, 1, 0, 0, 0, 1426, 1427, 1, 0, 0, 0, 1427,
		1429, 1, 0, 0, 0, 1428, 1417, 1, 0, 0, 0, 1428, 1421, 1, 0, 0, 0, 1429,
		105, 1, 0, 0, 0, 1430, 1437, 5, 124, 0, 0, 1431, 1437, 5, 202, 0, 0, 1432,
		1433, 5, 118, 0, 0, 1433, 1437, 5, 53, 0, 0, 1434, 1435, 5, 118, 0, 0,
		1435, 1437, 5, 204, 0, 0, 1436, 1430, 1, 0, 0, 0, 1436, 1431, 1, 0, 0,
		0, 1436, 1432, 1, 0, 0, 0, 1436, 1434, 1, 0, 0, 0, 1437, 107, 1, 0, 0,
		0, 1438, 1439, 5, 178, 0, 0, 1439, 1440, 5, 26, 0, 0, 1440, 1444, 3, 94,
		47, 0, 1441, 1442, 3, 104, 52, 0, 1442, 1443, 5, 320, 0, 0, 1443, 1445,
		1, 0, 0, 0, 1444, 1441, 1, 0, 0, 0, 1444, 1445, 1, 0, 0, 0, 1445, 1450,
		1, 0, 0, 0, 1446, 1447, 3, 106, 53, 0, 1447, 1448, 5, 208, 0, 0, 1448,
		1449, 5, 118, 0, 0, 1449, 1451, 1, 0, 0, 0, 1450, 1446, 1, 0, 0, 0, 1450,
		1451, 1, 0, 0, 0, 1451, 1456, 1, 0, 0, 0, 1452, 1453, 3, 106, 53, 0, 1453,
		1454, 5, 208, 0, 0, 1454, 1455, 5, 124, 0, 0, 1455, 1457, 1, 0, 0, 0, 1456,
		1452, 1, 0, 0, 0, 1456, 1457, 1, 0, 0, 0, 1457, 1458, 1, 0, 0, 0, 1458,
		1459, 5, 27, 0, 0, 1459, 109, 1, 0, 0, 0, 1460, 1462, 5, 26, 0, 0, 1461,
		1463, 3, 130, 65, 0, 1462, 1461, 1, 0, 0, 0, 1462, 1463, 1, 0, 0, 0, 1463,
		1465, 1, 0, 0, 0, 1464, 1466, 5, 25, 0, 0, 1465, 1464, 1, 0, 0, 0, 1465,
		1466, 1, 0, 0, 0, 1466, 1467, 1, 0, 0, 0, 1467, 1468, 5, 27, 0, 0, 1468,
		111, 1, 0, 0, 0, 1469, 1474, 3, 14, 7, 0, 1470, 1471, 5, 25, 0, 0, 1471,
		1473, 3, 14, 7, 0, 1472, 1470, 1, 0, 0, 0, 1473, 1476, 1, 0, 0, 0, 1474,
		1472, 1, 0, 0, 0, 1474, 1475, 1, 0, 0, 0, 1475, 113, 1, 0, 0, 0, 1476,
		1474, 1, 0, 0, 0, 1477, 1478, 5, 26, 0, 0, 1478, 1483, 3, 786, 393, 0,
		1479, 1480, 5, 25, 0, 0, 1480, 1482, 3, 786, 393, 0, 1481, 1479, 1, 0,
		0, 0, 1482, 1485, 1, 0, 0, 0, 1483, 1481, 1, 0, 0, 0, 1483, 1484, 1, 0,
		0, 0, 1484, 1486, 1, 0, 0, 0, 1485, 1483, 1, 0, 0, 0, 1486, 1487, 5, 27,
		0, 0, 1487, 115, 1, 0, 0, 0, 1488, 1491, 3, 144, 72, 0, 1489, 1491, 3,
		786, 393, 0, 1490, 1488, 1, 0, 0, 0, 1490, 1489, 1, 0, 0, 0, 1491, 117,
		1, 0, 0, 0, 1492, 1493, 5, 26, 0, 0, 1493, 1498, 3, 116, 58, 0, 1494, 1495,
		5, 25, 0, 0, 1495, 1497, 3, 116, 58, 0, 1496, 1494, 1, 0, 0, 0, 1497, 1500,
		1, 0, 0, 0, 1498, 1496, 1, 0, 0, 0, 1498, 1499, 1, 0, 0, 0, 1499, 1501,
		1, 0, 0, 0, 1500, 1498, 1, 0, 0, 0, 1501, 1502, 5, 27, 0, 0, 1502, 119,
		1, 0, 0, 0, 1503, 1504, 3, 810, 405, 0, 1504, 1505, 3, 786, 393, 0, 1505,
		121, 1, 0, 0, 0, 1506, 1507, 3, 786, 393, 0, 1507, 1508, 5, 24, 0, 0, 1508,
		1509, 3, 786, 393, 0, 1509, 1512, 1, 0, 0, 0, 1510, 1512, 3, 800, 400,
		0, 1511, 1506, 1, 0, 0, 0, 1511, 1510, 1, 0, 0, 0, 1512, 123, 1, 0, 0,
		0, 1513, 1518, 3, 120, 60, 0, 1514, 1515, 5, 25, 0, 0, 1515, 1517, 3, 120,
		60, 0, 1516, 1514, 1, 0, 0, 0, 1517, 1520, 1, 0, 0, 0, 1518, 1516, 1, 0,
		0, 0, 1518, 1519, 1, 0, 0, 0, 1519, 1522, 1, 0, 0, 0, 1520, 1518, 1, 0,
		0, 0, 1521, 1523, 5, 25, 0, 0, 1522, 1521, 1, 0, 0, 0, 1522, 1523, 1, 0,
		0, 0, 1523, 125, 1, 0, 0, 0, 1524, 1529, 3, 122, 61, 0, 1525, 1526, 5,
		25, 0, 0, 1526, 1528, 3, 122, 61, 0, 1527, 1525, 1, 0, 0, 0, 1528, 1531,
		1, 0, 0, 0, 1529, 1527, 1, 0, 0, 0, 1529, 1530, 1, 0, 0, 0, 1530, 1533,
		1, 0, 0, 0, 1531, 1529, 1, 0, 0, 0, 1532, 1534, 5, 25, 0, 0, 1533, 1532,
		1, 0, 0, 0, 1533, 1534, 1, 0, 0, 0, 1534, 127, 1, 0, 0, 0, 1535, 1538,
		3, 14, 7, 0, 1536, 1537, 5, 54, 0, 0, 1537, 1539, 3, 788, 394, 0, 1538,
		1536, 1, 0, 0, 0, 1538, 1539, 1, 0, 0, 0, 1539, 129, 1, 0, 0, 0, 1540,
		1545, 3, 128, 64, 0, 1541, 1542, 5, 25, 0, 0, 1542, 1544, 3, 128, 64, 0,
		1543, 1541, 1, 0, 0, 0, 1544, 1547, 1, 0, 0, 0, 1545, 1543, 1, 0, 0, 0,
		1545, 1546, 1, 0, 0, 0, 1546, 131, 1, 0, 0, 0, 1547, 1545, 1, 0, 0, 0,
		1548, 1555, 5, 26, 0, 0, 1549, 1550, 3, 252, 126, 0, 1550, 1552, 3, 130,
		65, 0, 1551, 1553, 5, 25, 0, 0, 1552, 1551, 1, 0, 0, 0, 1552, 1553, 1,
		0, 0, 0, 1553, 1556, 1, 0, 0, 0, 1554, 1556, 5, 19, 0, 0, 1555, 1549, 1,
		0, 0, 0, 1555, 1554, 1, 0, 0, 0, 1555, 1556, 1, 0, 0, 0, 1556, 1557, 1,
		0, 0, 0, 1557, 1558, 5, 27, 0, 0, 1558, 1559, 3, 134, 67, 0, 1559, 133,
		1, 0, 0, 0, 1560, 1563, 3, 712, 356, 0, 1561, 1563, 3, 714, 357, 0, 1562,
		1560, 1, 0, 0, 0, 1562, 1561, 1, 0, 0, 0, 1562, 1563, 1, 0, 0, 0, 1563,
		1566, 1, 0, 0, 0, 1564, 1565, 5, 217, 0, 0, 1565, 1567, 3, 716, 358, 0,
		1566, 1564, 1, 0, 0, 0, 1566, 1567, 1, 0, 0, 0, 1567, 135, 1, 0, 0, 0,
		1568, 1569, 3, 788, 394, 0, 1569, 1570, 5, 39, 0, 0, 1570, 1571, 3, 788,
		394, 0, 1571, 1577, 1, 0, 0, 0, 1572, 1577, 3, 792, 396, 0, 1573, 1577,
		3, 144, 72, 0, 1574, 1575, 5, 134, 0, 0, 1575, 1577, 5, 147, 0, 0, 1576,
		1568, 1, 0, 0, 0, 1576, 1572, 1, 0, 0, 0, 1576, 1573, 1, 0, 0, 0, 1576,
		1574, 1, 0, 0, 0, 1577, 1578, 1, 0, 0, 0, 1578, 1579, 3, 132, 66, 0, 1579,
		137, 1, 0, 0, 0, 1580, 1581, 5, 42, 0, 0, 1581, 1582, 3, 14, 7, 0, 1582,
		1583, 5, 41, 0, 0, 1583, 139, 1, 0, 0, 0, 1584, 1585, 5, 315, 0, 0, 1585,
		1586, 3, 14, 7, 0, 1586, 1587, 5, 290, 0, 0, 1587, 1588, 3, 14, 7, 0, 1588,
		141, 1, 0, 0, 0, 1589, 1600, 3, 850, 425, 0, 1590, 1600, 3, 848, 424, 0,
		1591, 1600, 5, 322, 0, 0, 1592, 1600, 5, 328, 0, 0, 1593, 1600, 5, 202,
		0, 0, 1594, 1600, 5, 95, 0, 0, 1595, 1600, 5, 94, 0, 0, 1596, 1600, 5,
		96, 0, 0, 1597, 1600, 3, 846, 423, 0, 1598, 1600, 5, 119, 0, 0, 1599, 1589,
		1, 0, 0, 0, 1599, 1590, 1, 0, 0, 0, 1599, 1591, 1, 0, 0, 0, 1599, 1592,
		1, 0, 0, 0, 1599, 1593, 1, 0, 0, 0, 1599, 1594, 1, 0, 0, 0, 1599, 1595,
		1, 0, 0, 0, 1599, 1596, 1, 0, 0, 0, 1599, 1597, 1, 0, 0, 0, 1599, 1598,
		1, 0, 0, 0, 1600, 143, 1, 0, 0, 0, 1601, 1605, 5, 32, 0, 0, 1602, 1606,
		3, 788, 394, 0, 1603, 1606, 5, 296, 0, 0, 1604, 1606, 5, 136, 0, 0, 1605,
		1602, 1, 0, 0, 0, 1605, 1603, 1, 0, 0, 0, 1605, 1604, 1, 0, 0, 0, 1606,
		145, 1, 0, 0, 0, 1607, 1609, 3, 144, 72, 0, 1608, 1610, 5, 28, 0, 0, 1609,
		1608, 1, 0, 0, 0, 1609, 1610, 1, 0, 0, 0, 1610, 147, 1, 0, 0, 0, 1611,
		1616, 3, 144, 72, 0, 1612, 1613, 5, 25, 0, 0, 1613, 1615, 3, 144, 72, 0,
		1614, 1612, 1, 0, 0, 0, 1615, 1618, 1, 0, 0, 0, 1616, 1614, 1, 0, 0, 0,
		1616, 1617, 1, 0, 0, 0, 1617, 149, 1, 0, 0, 0, 1618, 1616, 1, 0, 0, 0,
		1619, 1622, 3, 144, 72, 0, 1620, 1621, 5, 54, 0, 0, 1621, 1623, 3, 144,
		72, 0, 1622, 1620, 1, 0, 0, 0, 1622, 1623, 1, 0, 0, 0, 1623, 151, 1, 0,
		0, 0, 1624, 1629, 3, 150, 75, 0, 1625, 1626, 5, 25, 0, 0, 1626, 1628, 3,
		150, 75, 0, 1627, 1625, 1, 0, 0, 0, 1628, 1631, 1, 0, 0, 0, 1629, 1627,
		1, 0, 0, 0, 1629, 1630, 1, 0, 0, 0, 1630, 153, 1, 0, 0, 0, 1631, 1629,
		1, 0, 0, 0, 1632, 1634, 7, 3, 0, 0, 1633, 1632, 1, 0, 0, 0, 1633, 1634,
		1, 0, 0, 0, 1634, 1637, 1, 0, 0, 0, 1635, 1638, 3, 850, 425, 0, 1636, 1638,
		3, 848, 424, 0, 1637, 1635, 1, 0, 0, 0, 1637, 1636, 1, 0, 0, 0, 1638, 155,
		1, 0, 0, 0, 1639, 1640, 3, 804, 402, 0, 1640, 157, 1, 0, 0, 0, 1641, 1644,
		3, 850, 425, 0, 1642, 1644, 3, 144, 72, 0, 1643, 1641, 1, 0, 0, 0, 1643,
		1642, 1, 0, 0, 0, 1644, 159, 1, 0, 0, 0, 1645, 1649, 3, 768, 384, 0, 1646,
		1649, 5, 322, 0, 0, 1647, 1649, 3, 144, 72, 0, 1648, 1645, 1, 0, 0, 0,
		1648, 1646, 1, 0, 0, 0, 1648, 1647, 1, 0, 0, 0, 1649, 161, 1, 0, 0, 0,
		1650, 1651, 3, 160, 80, 0, 1651, 1652, 5, 29, 0, 0, 1652, 1653, 3, 204,
		102, 0, 1653, 163, 1, 0, 0, 0, 1654, 1655, 3, 160, 80, 0, 1655, 1660, 3,
		204, 102, 0, 1656, 1658, 5, 200, 0, 0, 1657, 1656, 1, 0, 0, 0, 1657, 1658,
		1, 0, 0, 0, 1658, 1659, 1, 0, 0, 0, 1659, 1661, 5, 202, 0, 0, 1660, 1657,
		1, 0, 0, 0, 1660, 1661, 1, 0, 0, 0, 1661, 1667, 1, 0, 0, 0, 1662, 1663,
		3, 204, 102, 0, 1663, 1664, 5, 54, 0, 0, 1664, 1665, 3, 160, 80, 0, 1665,
		1667, 1, 0, 0, 0, 1666, 1654, 1, 0, 0, 0, 1666, 1662, 1, 0, 0, 0, 1667,
		165, 1, 0, 0, 0, 1668, 1669, 3, 160, 80, 0, 1669, 1670, 5, 29, 0, 0, 1670,
		1672, 1, 0, 0, 0, 1671, 1668, 1, 0, 0, 0, 1671, 1672, 1, 0, 0, 0, 1672,
		1673, 1, 0, 0, 0, 1673, 1674, 3, 204, 102, 0, 1674, 167, 1, 0, 0, 0, 1675,
		1679, 3, 166, 83, 0, 1676, 1677, 5, 36, 0, 0, 1677, 1678, 5, 63, 0, 0,
		1678, 1680, 5, 37, 0, 0, 1679, 1676, 1, 0, 0, 0, 1679, 1680, 1, 0, 0, 0,
		1680, 169, 1, 0, 0, 0, 1681, 1686, 3, 168, 84, 0, 1682, 1683, 5, 25, 0,
		0, 1683, 1685, 3, 168, 84, 0, 1684, 1682, 1, 0, 0, 0, 1685, 1688, 1, 0,
		0, 0, 1686, 1684, 1, 0, 0, 0, 1686, 1687, 1, 0, 0, 0, 1687, 171, 1, 0,
		0, 0, 1688, 1686, 1, 0, 0, 0, 1689, 1690, 5, 99, 0, 0, 1690, 1691, 5, 26,
		0, 0, 1691, 1692, 3, 158, 79, 0, 1692, 1693, 5, 25, 0, 0, 1693, 1694, 3,
		158, 79, 0, 1694, 1695, 5, 27, 0, 0, 1695, 173, 1, 0, 0, 0, 1696, 1697,
		5, 212, 0, 0, 1697, 1698, 5, 5, 0, 0, 1698, 1699, 3, 204, 102, 0, 1699,
		1700, 5, 7, 0, 0, 1700, 175, 1, 0, 0, 0, 1701, 1718, 5, 297, 0, 0, 1702,
		1714, 5, 5, 0, 0, 1703, 1708, 3, 204, 102, 0, 1704, 1705, 5, 25, 0, 0,
		1705, 1707, 3, 204, 102, 0, 1706, 1704, 1, 0, 0, 0, 1707, 1710, 1, 0, 0,
		0, 1708, 1706, 1, 0, 0, 0, 1708, 1709, 1, 0, 0, 0, 1709, 1712, 1, 0, 0,
		0, 1710, 1708, 1, 0, 0, 0, 1711, 1713, 5, 25, 0, 0, 1712, 1711, 1, 0, 0,
		0, 1712, 1713, 1, 0, 0, 0, 1713, 1715, 1, 0, 0, 0, 1714, 1703, 1, 0, 0,
		0, 1714, 1715, 1, 0, 0, 0, 1715, 1716, 1, 0, 0, 0, 1716, 1719, 5, 7, 0,
		0, 1717, 1719, 5, 4, 0, 0, 1718, 1702, 1, 0, 0, 0, 1718, 1717, 1, 0, 0,
		0, 1719, 177, 1, 0, 0, 0, 1720, 1737, 5, 276, 0, 0, 1721, 1733, 5, 5, 0,
		0, 1722, 1727, 3, 162, 81, 0, 1723, 1724, 5, 25, 0, 0, 1724, 1726, 3, 162,
		81, 0, 1725, 1723, 1, 0, 0, 0, 1726, 1729, 1, 0, 0, 0, 1727, 1725, 1, 0,
		0, 0, 1727, 1728, 1, 0, 0, 0, 1728, 1731, 1, 0, 0, 0, 1729, 1727, 1, 0,
		0, 0, 1730, 1732, 5, 25, 0, 0, 1731, 1730, 1, 0, 0, 0, 1731, 1732, 1, 0,
		0, 0, 1732, 1734, 1, 0, 0, 0, 1733, 1722, 1, 0, 0, 0, 1733, 1734, 1, 0,
		0, 0, 1734, 1735, 1, 0, 0, 0, 1735, 1738, 5, 7, 0, 0, 1736, 1738, 5, 4,
		0, 0, 1737, 1721, 1, 0, 0, 0, 1737, 1736, 1, 0, 0, 0, 1738, 179, 1, 0,
		0, 0, 1739, 1740, 5, 312, 0, 0, 1740, 1741, 5, 5, 0, 0, 1741, 1746, 3,
		166, 83, 0, 1742, 1743, 5, 25, 0, 0, 1743, 1745, 3, 166, 83, 0, 1744, 1742,
		1, 0, 0, 0, 1745, 1748, 1, 0, 0, 0, 1746, 1744, 1, 0, 0, 0, 1746, 1747,
		1, 0, 0, 0, 1747, 1750, 1, 0, 0, 0, 1748, 1746, 1, 0, 0, 0, 1749, 1751,
		5, 25, 0, 0, 1750, 1749, 1, 0, 0, 0, 1750, 1751, 1, 0, 0, 0, 1751, 1752,
		1, 0, 0, 0, 1752, 1753, 5, 7, 0, 0, 1753, 181, 1, 0, 0, 0, 1754, 1755,
		5, 186, 0, 0, 1755, 1756, 5, 5, 0, 0, 1756, 1757, 3, 204, 102, 0, 1757,
		1758, 5, 7, 0, 0, 1758, 183, 1, 0, 0, 0, 1759, 1760, 5, 275, 0, 0, 1760,
		1761, 5, 5, 0, 0, 1761, 1762, 3, 204, 102, 0, 1762, 1763, 5, 7, 0, 0, 1763,
		185, 1, 0, 0, 0, 1764, 1765, 5, 141, 0, 0, 1765, 1766, 5, 5, 0, 0, 1766,
		1767, 3, 204, 102, 0, 1767, 1768, 5, 7, 0, 0, 1768, 187, 1, 0, 0, 0, 1769,
		1770, 5, 109, 0, 0, 1770, 1771, 5, 5, 0, 0, 1771, 1772, 3, 204, 102, 0,
		1772, 1773, 5, 25, 0, 0, 1773, 1774, 3, 204, 102, 0, 1774, 1775, 5, 7,
		0, 0, 1775, 189, 1, 0, 0, 0, 1776, 1777, 5, 270, 0, 0, 1777, 1778, 5, 5,
		0, 0, 1778, 1779, 3, 204, 102, 0, 1779, 1780, 5, 7, 0, 0, 1780, 191, 1,
		0, 0, 0, 1781, 1782, 5, 122, 0, 0, 1782, 1783, 5, 5, 0, 0, 1783, 1788,
		3, 160, 80, 0, 1784, 1785, 5, 25, 0, 0, 1785, 1787, 3, 160, 80, 0, 1786,
		1784, 1, 0, 0, 0, 1787, 1790, 1, 0, 0, 0, 1788, 1786, 1, 0, 0, 0, 1788,
		1789, 1, 0, 0, 0, 1789, 1792, 1, 0, 0, 0, 1790, 1788, 1, 0, 0, 0, 1791,
		1793, 5, 25, 0, 0, 1792, 1791, 1, 0, 0, 0, 1792, 1793, 1, 0, 0, 0, 1793,
		1794, 1, 0, 0, 0, 1794, 1795, 5, 7, 0, 0, 1795, 193, 1, 0, 0, 0, 1796,
		1797, 5, 248, 0, 0, 1797, 1798, 5, 5, 0, 0, 1798, 1799, 3, 160, 80, 0,
		1799, 1800, 5, 7, 0, 0, 1800, 195, 1, 0, 0, 0, 1801, 1802, 5, 287, 0, 0,
		1802, 1803, 5, 5, 0, 0, 1803, 1804, 3, 204, 102, 0, 1804, 1805, 5, 25,
		0, 0, 1805, 1806, 3, 160, 80, 0, 1806, 1807, 5, 7, 0, 0, 1807, 197, 1,
		0, 0, 0, 1808, 1809, 5, 72, 0, 0, 1809, 1810, 5, 5, 0, 0, 1810, 1812, 5,
		26, 0, 0, 1811, 1813, 3, 170, 85, 0, 1812, 1811, 1, 0, 0, 0, 1812, 1813,
		1, 0, 0, 0, 1813, 1815, 1, 0, 0, 0, 1814, 1816, 5, 25, 0, 0, 1815, 1814,
		1, 0, 0, 0, 1815, 1816, 1, 0, 0, 0, 1816, 1821, 1, 0, 0, 0, 1817, 1818,
		5, 42, 0, 0, 1818, 1819, 3, 170, 85, 0, 1819, 1820, 5, 41, 0, 0, 1820,
		1822, 1, 0, 0, 0, 1821, 1817, 1, 0, 0, 0, 1821, 1822, 1, 0, 0, 0, 1822,
		1823, 1, 0, 0, 0, 1823, 1824, 5, 27, 0, 0, 1824, 1825, 5, 40, 0, 0, 1825,
		1826, 3, 204, 102, 0, 1826, 1827, 5, 7, 0, 0, 1827, 199, 1, 0, 0, 0, 1828,
		1842, 3, 174, 87, 0, 1829, 1842, 3, 176, 88, 0, 1830, 1842, 3, 178, 89,
		0, 1831, 1842, 3, 180, 90, 0, 1832, 1842, 3, 182, 91, 0, 1833, 1842, 3,
		184, 92, 0, 1834, 1842, 3, 186, 93, 0, 1835, 1842, 3, 188, 94, 0, 1836,
		1842, 3, 190, 95, 0, 1837, 1842, 3, 192, 96, 0, 1838, 1842, 3, 194, 97,
		0, 1839, 1842, 3, 196, 98, 0, 1840, 1842, 3, 198, 99, 0, 1841, 1828, 1,
		0, 0, 0, 1841, 1829, 1, 0, 0, 0, 1841, 1830, 1, 0, 0, 0, 1841, 1831, 1,
		0, 0, 0, 1841, 1832, 1, 0, 0, 0, 1841, 1833, 1, 0, 0, 0, 1841, 1834, 1,
		0, 0, 0, 1841, 1835, 1, 0, 0, 0, 1841, 1836, 1, 0, 0, 0, 1841, 1837, 1,
		0, 0, 0, 1841, 1838, 1, 0, 0, 0, 1841, 1839, 1, 0, 0, 0, 1841, 1840, 1,
		0, 0, 0, 1842, 1846, 1, 0, 0, 0, 1843, 1845, 5, 28, 0, 0, 1844, 1843, 1,
		0, 0, 0, 1845, 1848, 1, 0, 0, 0, 1846, 1844, 1, 0, 0, 0, 1846, 1847, 1,
		0, 0, 0, 1847, 201, 1, 0, 0, 0, 1848, 1846, 1, 0, 0, 0, 1849, 1861, 3,
		200, 100, 0, 1850, 1853, 3, 172, 86, 0, 1851, 1853, 3, 156, 78, 0, 1852,
		1850, 1, 0, 0, 0, 1852, 1851, 1, 0, 0, 0, 1853, 1857, 1, 0, 0, 0, 1854,
		1856, 5, 28, 0, 0, 1855, 1854, 1, 0, 0, 0, 1856, 1859, 1, 0, 0, 0, 1857,
		1855, 1, 0, 0, 0, 1857, 1858, 1, 0, 0, 0, 1858, 1861, 1, 0, 0, 0, 1859,
		1857, 1, 0, 0, 0, 1860, 1849, 1, 0, 0, 0, 1860, 1852, 1, 0, 0, 0, 1861,
		203, 1, 0, 0, 0, 1862, 1865, 3, 202, 101, 0, 1863, 1865, 3, 144, 72, 0,
		1864, 1862, 1, 0, 0, 0, 1864, 1863, 1, 0, 0, 0, 1865, 205, 1, 0, 0, 0,
		1866, 1867, 5, 322, 0, 0, 1867, 207, 1, 0, 0, 0, 1868, 1869, 5, 312, 0,
		0, 1869, 1870, 5, 26, 0, 0, 1870, 1871, 3, 14, 7, 0, 1871, 1872, 5, 25,
		0, 0, 1872, 1873, 3, 14, 7, 0, 1873, 1874, 5, 25, 0, 0, 1874, 1875, 3,
		14, 7, 0, 1875, 1876, 5, 27, 0, 0, 1876, 1892, 1, 0, 0, 0, 1877, 1878,
		5, 122, 0, 0, 1878, 1879, 5, 26, 0, 0, 1879, 1880, 3, 14, 7, 0, 1880, 1881,
		5, 25, 0, 0, 1881, 1882, 3, 14, 7, 0, 1882, 1883, 5, 27, 0, 0, 1883, 1892,
		1, 0, 0, 0, 1884, 1885, 5, 72, 0, 0, 1885, 1886, 5, 26, 0, 0, 1886, 1887,
		3, 14, 7, 0, 1887, 1888, 5, 25, 0, 0, 1888, 1889, 3, 14, 7, 0, 1889, 1890,
		5, 27, 0, 0, 1890, 1892, 1, 0, 0, 0, 1891, 1868, 1, 0, 0, 0, 1891, 1877,
		1, 0, 0, 0, 1891, 1884, 1, 0, 0, 0, 1892, 209, 1, 0, 0, 0, 1893, 1894,
		5, 100, 0, 0, 1894, 1895, 3, 144, 72, 0, 1895, 1896, 5, 54, 0, 0, 1896,
		1899, 3, 202, 101, 0, 1897, 1898, 5, 1, 0, 0, 1898, 1900, 3, 142, 71, 0,
		1899, 1897, 1, 0, 0, 0, 1899, 1900, 1, 0, 0, 0, 1900, 211, 1, 0, 0, 0,
		1901, 1903, 5, 24, 0, 0, 1902, 1901, 1, 0, 0, 0, 1902, 1903, 1, 0, 0, 0,
		1903, 1904, 1, 0, 0, 0, 1904, 1909, 3, 786, 393, 0, 1905, 1906, 5, 24,
		0, 0, 1906, 1908, 3, 786, 393, 0, 1907, 1905, 1, 0, 0, 0, 1908, 1911, 1,
		0, 0, 0, 1909, 1907, 1, 0, 0, 0, 1909, 1910, 1, 0, 0, 0, 1910, 213, 1,
		0, 0, 0, 1911, 1909, 1, 0, 0, 0, 1912, 1913, 5, 161, 0, 0, 1913, 1914,
		3, 212, 106, 0, 1914, 1915, 5, 279, 0, 0, 1915, 1916, 3, 152, 76, 0, 1916,
		215, 1, 0, 0, 0, 1917, 1918, 5, 133, 0, 0, 1918, 1919, 3, 148, 74, 0, 1919,
		217, 1, 0, 0, 0, 1920, 1923, 3, 144, 72, 0, 1921, 1923, 5, 119, 0, 0, 1922,
		1920, 1, 0, 0, 0, 1922, 1921, 1, 0, 0, 0, 1923, 1924, 1, 0, 0, 0, 1924,
		1926, 5, 26, 0, 0, 1925, 1927, 3, 112, 56, 0, 1926, 1925, 1, 0, 0, 0, 1926,
		1927, 1, 0, 0, 0, 1927, 1928, 1, 0, 0, 0, 1928, 1929, 5, 27, 0, 0, 1929,
		219, 1, 0, 0, 0, 1930, 1931, 5, 67, 0, 0, 1931, 1932, 3, 622, 311, 0, 1932,
		1933, 5, 121, 0, 0, 1933, 1934, 5, 114, 0, 0, 1934, 221, 1, 0, 0, 0, 1935,
		1938, 5, 114, 0, 0, 1936, 1939, 3, 218, 109, 0, 1937, 1939, 3, 220, 110,
		0, 1938, 1936, 1, 0, 0, 0, 1938, 1937, 1, 0, 0, 0, 1939, 223, 1, 0, 0,
		0, 1940, 1941, 5, 228, 0, 0, 1941, 1942, 3, 816, 408, 0, 1942, 1956, 3,
		786, 393, 0, 1943, 1944, 5, 1, 0, 0, 1944, 1957, 3, 226, 113, 0, 1945,
		1946, 5, 26, 0, 0, 1946, 1951, 3, 226, 113, 0, 1947, 1948, 5, 25, 0, 0,
		1948, 1950, 3, 226, 113, 0, 1949, 1947, 1, 0, 0, 0, 1950, 1953, 1, 0, 0,
		0, 1951, 1949, 1, 0, 0, 0, 1951, 1952, 1, 0, 0, 0, 1952, 1954, 1, 0, 0,
		0, 1953, 1951, 1, 0, 0, 0, 1954, 1955, 5, 27, 0, 0, 1955, 1957, 1, 0, 0,
		0, 1956, 1943, 1, 0, 0, 0, 1956, 1945, 1, 0, 0, 0, 1956, 1957, 1, 0, 0,
		0, 1957, 225, 1, 0, 0, 0, 1958, 1964, 3, 154, 77, 0, 1959, 1964, 3, 768,
		384, 0, 1960, 1964, 5, 322, 0, 0, 1961, 1964, 3, 846, 423, 0, 1962, 1964,
		3, 144, 72, 0, 1963, 1958, 1, 0, 0, 0, 1963, 1959, 1, 0, 0, 0, 1963, 1960,
		1, 0, 0, 0, 1963, 1961, 1, 0, 0, 0, 1963, 1962, 1, 0, 0, 0, 1964, 227,
		1, 0, 0, 0, 1965, 1967, 3, 14, 7, 0, 1966, 1968, 7, 9, 0, 0, 1967, 1966,
		1, 0, 0, 0, 1967, 1968, 1, 0, 0, 0, 1968, 229, 1, 0, 0, 0, 1969, 1974,
		3, 228, 114, 0, 1970, 1971, 5, 25, 0, 0, 1971, 1973, 3, 228, 114, 0, 1972,
		1970, 1, 0, 0, 0, 1973, 1976, 1, 0, 0, 0, 1974, 1972, 1, 0, 0, 0, 1974,
		1975, 1, 0, 0, 0, 1975, 231, 1, 0, 0, 0, 1976, 1974, 1, 0, 0, 0, 1977,
		1983, 3, 236, 118, 0, 1978, 1979, 3, 238, 119, 0, 1979, 1980, 3, 236, 118,
		0, 1980, 1982, 1, 0, 0, 0, 1981, 1978, 1, 0, 0, 0, 1982, 1985, 1, 0, 0,
		0, 1983, 1981, 1, 0, 0, 0, 1983, 1984, 1, 0, 0, 0, 1984, 233, 1, 0, 0,
		0, 1985, 1983, 1, 0, 0, 0, 1986, 1992, 3, 240, 120, 0, 1987, 1988, 3, 238,
		119, 0, 1988, 1989, 3, 236, 118, 0, 1989, 1991, 1, 0, 0, 0, 1990, 1987,
		1, 0, 0, 0, 1991, 1994, 1, 0, 0, 0, 1992, 1990, 1, 0, 0, 0, 1992, 1993,
		1, 0, 0, 0, 1993, 235, 1, 0, 0, 0, 1994, 1992, 1, 0, 0, 0, 1995, 2001,
		3, 240, 120, 0, 1996, 1997, 5, 26, 0, 0, 1997, 1998, 3, 240, 120, 0, 1998,
		1999, 5, 27, 0, 0, 1999, 2001, 1, 0, 0, 0, 2000, 1995, 1, 0, 0, 0, 2000,
		1996, 1, 0, 0, 0, 2001, 237, 1, 0, 0, 0, 2002, 2004, 5, 301, 0, 0, 2003,
		2005, 5, 47, 0, 0, 2004, 2003, 1, 0, 0, 0, 2004, 2005, 1, 0, 0, 0, 2005,
		2009, 1, 0, 0, 0, 2006, 2009, 5, 172, 0, 0, 2007, 2009, 5, 127, 0, 0, 2008,
		2002, 1, 0, 0, 0, 2008, 2006, 1, 0, 0, 0, 2008, 2007, 1, 0, 0, 0, 2009,
		239, 1, 0, 0, 0, 2010, 2017, 3, 242, 121, 0, 2011, 2012, 5, 185, 0, 0,
		2012, 2015, 3, 14, 7, 0, 2013, 2014, 7, 10, 0, 0, 2014, 2016, 3, 14, 7,
		0, 2015, 2013, 1, 0, 0, 0, 2015, 2016, 1, 0, 0, 0, 2016, 2018, 1, 0, 0,
		0, 2017, 2011, 1, 0, 0, 0, 2017, 2018, 1, 0, 0, 0, 2018, 241, 1, 0, 0,
		0, 2019, 2021, 5, 112, 0, 0, 2020, 2019, 1, 0, 0, 0, 2020, 2021, 1, 0,
		0, 0, 2021, 2025, 1, 0, 0, 0, 2022, 2026, 3, 244, 122, 0, 2023, 2026, 3,
		250, 125, 0, 2024, 2026, 3, 254, 127, 0, 2025, 2022, 1, 0, 0, 0, 2025,
		2023, 1, 0, 0, 0, 2025, 2024, 1, 0, 0, 0, 2026, 2030, 1, 0, 0, 0, 2027,
		2028, 5, 173, 0, 0, 2028, 2029, 5, 252, 0, 0, 2029, 2031, 3, 116, 58, 0,
		2030, 2027, 1, 0, 0, 0, 2030, 2031, 1, 0, 0, 0, 2031, 243, 1, 0, 0, 0,
		2032, 2034, 5, 233, 0, 0, 2033, 2035, 5, 275, 0, 0, 2034, 2033, 1, 0, 0,
		0, 2034, 2035, 1, 0, 0, 0, 2035, 2036, 1, 0, 0, 0, 2036, 2041, 3, 346,
		173, 0, 2037, 2038, 5, 25, 0, 0, 2038, 2040, 3, 346, 173, 0, 2039, 2037,
		1, 0, 0, 0, 2040, 2043, 1, 0, 0, 0, 2041, 2039, 1, 0, 0, 0, 2041, 2042,
		1, 0, 0, 0, 2042, 2066, 1, 0, 0, 0, 2043, 2041, 1, 0, 0, 0, 2044, 2045,
		5, 309, 0, 0, 2045, 2048, 3, 136, 68, 0, 2046, 2047, 5, 54, 0, 0, 2047,
		2049, 3, 786, 393, 0, 2048, 2046, 1, 0, 0, 0, 2048, 2049, 1, 0, 0, 0, 2049,
		2052, 1, 0, 0, 0, 2050, 2051, 5, 318, 0, 0, 2051, 2053, 3, 248, 124, 0,
		2052, 2050, 1, 0, 0, 0, 2052, 2053, 1, 0, 0, 0, 2053, 2056, 1, 0, 0, 0,
		2054, 2055, 5, 316, 0, 0, 2055, 2057, 3, 14, 7, 0, 2056, 2054, 1, 0, 0,
		0, 2056, 2057, 1, 0, 0, 0, 2057, 2060, 1, 0, 0, 0, 2058, 2059, 5, 155,
		0, 0, 2059, 2061, 3, 14, 7, 0, 2060, 2058, 1, 0, 0, 0, 2060, 2061, 1, 0,
		0, 0, 2061, 2064, 1, 0, 0, 0, 2062, 2063, 5, 56, 0, 0, 2063, 2065, 3, 314,
		157, 0, 2064, 2062, 1, 0, 0, 0, 2064, 2065, 1, 0, 0, 0, 2065, 2067, 1,
		0, 0, 0, 2066, 2044, 1, 0, 0, 0, 2066, 2067, 1, 0, 0, 0, 2067, 245, 1,
		0, 0, 0, 2068, 2069, 3, 786, 393, 0, 2069, 2070, 5, 1, 0, 0, 2070, 2071,
		3, 14, 7, 0, 2071, 247, 1, 0, 0, 0, 2072, 2077, 3, 246, 123, 0, 2073, 2074,
		5, 25, 0, 0, 2074, 2076, 3, 246, 123, 0, 2075, 2073, 1, 0, 0, 0, 2076,
		2079, 1, 0, 0, 0, 2077, 2075, 1, 0, 0, 0, 2077, 2078, 1, 0, 0, 0, 2078,
		249, 1, 0, 0, 0, 2079, 2077, 1, 0, 0, 0, 2080, 2081, 5, 237, 0, 0, 2081,
		2086, 3, 346, 173, 0, 2082, 2083, 5, 25, 0, 0, 2083, 2085, 3, 346, 173,
		0, 2084, 2082, 1, 0, 0, 0, 2085, 2088, 1, 0, 0, 0, 2086, 2084, 1, 0, 0,
		0, 2086, 2087, 1, 0, 0, 0, 2087, 2091, 1, 0, 0, 0, 2088, 2086, 1, 0, 0,
		0, 2089, 2090, 5, 230, 0, 0, 2090, 2092, 3, 230, 115, 0, 2091, 2089, 1,
		0, 0, 0, 2091, 2092, 1, 0, 0, 0, 2092, 2093, 1, 0, 0, 0, 2093, 2094, 5,
		208, 0, 0, 2094, 2095, 3, 124, 62, 0, 2095, 2097, 5, 309, 0, 0, 2096, 2098,
		5, 47, 0, 0, 2097, 2096, 1, 0, 0, 0, 2097, 2098, 1, 0, 0, 0, 2098, 2099,
		1, 0, 0, 0, 2099, 2102, 3, 136, 68, 0, 2100, 2101, 5, 54, 0, 0, 2101, 2103,
		3, 786, 393, 0, 2102, 2100, 1, 0, 0, 0, 2102, 2103, 1, 0, 0, 0, 2103, 2106,
		1, 0, 0, 0, 2104, 2105, 5, 316, 0, 0, 2105, 2107, 3, 14, 7, 0, 2106, 2104,
		1, 0, 0, 0, 2106, 2107, 1, 0, 0, 0, 2107, 2110, 1, 0, 0, 0, 2108, 2109,
		5, 155, 0, 0, 2109, 2111, 3, 14, 7, 0, 2110, 2108, 1, 0, 0, 0, 2110, 2111,
		1, 0, 0, 0, 2111, 2114, 1, 0, 0, 0, 2112, 2113, 5, 56, 0, 0, 2113, 2115,
		3, 314, 157, 0, 2114, 2112, 1, 0, 0, 0, 2114, 2115, 1, 0, 0, 0, 2115, 251,
		1, 0, 0, 0, 2116, 2118, 7, 11, 0, 0, 2117, 2116, 1, 0, 0, 0, 2117, 2118,
		1, 0, 0, 0, 2118, 253, 1, 0, 0, 0, 2119, 2120, 5, 145, 0, 0, 2120, 2122,
		3, 338, 169, 0, 2121, 2119, 1, 0, 0, 0, 2121, 2122, 1, 0, 0, 0, 2122, 2123,
		1, 0, 0, 0, 2123, 2125, 5, 268, 0, 0, 2124, 2126, 5, 275, 0, 0, 2125, 2124,
		1, 0, 0, 0, 2125, 2126, 1, 0, 0, 0, 2126, 2127, 1, 0, 0, 0, 2127, 2128,
		3, 252, 126, 0, 2128, 2133, 3, 336, 168, 0, 2129, 2130, 5, 25, 0, 0, 2130,
		2132, 3, 336, 168, 0, 2131, 2129, 1, 0, 0, 0, 2132, 2135, 1, 0, 0, 0, 2133,
		2131, 1, 0, 0, 0, 2133, 2134, 1, 0, 0, 0, 2134, 2137, 1, 0, 0, 0, 2135,
		2133, 1, 0, 0, 0, 2136, 2138, 5, 25, 0, 0, 2137, 2136, 1, 0, 0, 0, 2137,
		2138, 1, 0, 0, 0, 2138, 2141, 1, 0, 0, 0, 2139, 2140, 5, 319, 0, 0, 2140,
		2142, 3, 126, 63, 0, 2141, 2139, 1, 0, 0, 0, 2141, 2142, 1, 0, 0, 0, 2142,
		2145, 1, 0, 0, 0, 2143, 2144, 5, 145, 0, 0, 2144, 2146, 3, 338, 169, 0,
		2145, 2143, 1, 0, 0, 0, 2145, 2146, 1, 0, 0, 0, 2146, 2149, 1, 0, 0, 0,
		2147, 2148, 5, 316, 0, 0, 2148, 2150, 3, 14, 7, 0, 2149, 2147, 1, 0, 0,
		0, 2149, 2150, 1, 0, 0, 0, 2150, 2152, 1, 0, 0, 0, 2151, 2153, 3, 318,
		159, 0, 2152, 2151, 1, 0, 0, 0, 2152, 2153, 1, 0, 0, 0, 2153, 2156, 1,
		0, 0, 0, 2154, 2155, 5, 155, 0, 0, 2155, 2157, 3, 14, 7, 0, 2156, 2154,
		1, 0, 0, 0, 2156, 2157, 1, 0, 0, 0, 2157, 2159, 1, 0, 0, 0, 2158, 2160,
		3, 720, 360, 0, 2159, 2158, 1, 0, 0, 0, 2159, 2160, 1, 0, 0, 0, 2160, 2162,
		1, 0, 0, 0, 2161, 2163, 3, 316, 158, 0, 2162, 2161, 1, 0, 0, 0, 2162, 2163,
		1, 0, 0, 0, 2163, 255, 1, 0, 0, 0, 2164, 2165, 5, 191, 0, 0, 2165, 2167,
		5, 26, 0, 0, 2166, 2168, 3, 734, 367, 0, 2167, 2166, 1, 0, 0, 0, 2167,
		2168, 1, 0, 0, 0, 2168, 2170, 1, 0, 0, 0, 2169, 2171, 3, 314, 157, 0, 2170,
		2169, 1, 0, 0, 0, 2170, 2171, 1, 0, 0, 0, 2171, 2173, 1, 0, 0, 0, 2172,
		2174, 3, 262, 131, 0, 2173, 2172, 1, 0, 0, 0, 2173, 2174, 1, 0, 0, 0, 2174,
		2176, 1, 0, 0, 0, 2175, 2177, 3, 258, 129, 0, 2176, 2175, 1, 0, 0, 0, 2176,
		2177, 1, 0, 0, 0, 2177, 2178, 1, 0, 0, 0, 2178, 2179, 3, 268, 134, 0, 2179,
		2180, 5, 27, 0, 0, 2180, 257, 1, 0, 0, 0, 2181, 2182, 5, 209, 0, 0, 2182,
		2183, 5, 261, 0, 0, 2183, 2184, 5, 224, 0, 0, 2184, 2193, 5, 189, 0, 0,
		2185, 2186, 5, 47, 0, 0, 2186, 2187, 5, 262, 0, 0, 2187, 2188, 5, 224,
		0, 0, 2188, 2190, 5, 189, 0, 0, 2189, 2191, 3, 260, 130, 0, 2190, 2189,
		1, 0, 0, 0, 2190, 2191, 1, 0, 0, 0, 2191, 2193, 1, 0, 0, 0, 2192, 2181,
		1, 0, 0, 0, 2192, 2185, 1, 0, 0, 0, 2193, 259, 1, 0, 0, 0, 2194, 2195,
		5, 272, 0, 0, 2195, 2196, 5, 118, 0, 0, 2196, 2204, 5, 190, 0, 0, 2197,
		2198, 5, 207, 0, 0, 2198, 2199, 5, 118, 0, 0, 2199, 2204, 5, 190, 0, 0,
		2200, 2201, 5, 318, 0, 0, 2201, 2202, 5, 304, 0, 0, 2202, 2204, 5, 262,
		0, 0, 2203, 2194, 1, 0, 0, 0, 2203, 2197, 1, 0, 0, 0, 2203, 2200, 1, 0,
		0, 0, 2204, 261, 1, 0, 0, 0, 2205, 2206, 5, 192, 0, 0, 2206, 2207, 3, 264,
		132, 0, 2207, 263, 1, 0, 0, 0, 2208, 2213, 3, 266, 133, 0, 2209, 2210,
		5, 25, 0, 0, 2210, 2212, 3, 266, 133, 0, 2211, 2209, 1, 0, 0, 0, 2212,
		2215, 1, 0, 0, 0, 2213, 2211, 1, 0, 0, 0, 2213, 2214, 1, 0, 0, 0, 2214,
		265, 1, 0, 0, 0, 2215, 2213, 1, 0, 0, 0, 2216, 2217, 3, 14, 7, 0, 2217,
		2218, 5, 54, 0, 0, 2218, 2219, 3, 786, 393, 0, 2219, 267, 1, 0, 0, 0, 2220,
		2221, 5, 46, 0, 0, 2221, 2222, 5, 189, 0, 0, 2222, 2224, 3, 270, 135, 0,
		2223, 2220, 1, 0, 0, 0, 2223, 2224, 1, 0, 0, 0, 2224, 2226, 1, 0, 0, 0,
		2225, 2227, 3, 274, 137, 0, 2226, 2225, 1, 0, 0, 0, 2226, 2227, 1, 0, 0,
		0, 2227, 2228, 1, 0, 0, 0, 2228, 2229, 5, 223, 0, 0, 2229, 2230, 5, 26,
		0, 0, 2230, 2231, 3, 276, 138, 0, 2231, 2233, 5, 27, 0, 0, 2232, 2234,
		3, 290, 145, 0, 2233, 2232, 1, 0, 0, 0, 2233, 2234, 1, 0, 0, 0, 2234, 2235,
		1, 0, 0, 0, 2235, 2236, 5, 104, 0, 0, 2236, 2237, 3, 302, 151, 0, 2237,
		269, 1, 0, 0, 0, 2238, 2239, 5, 273, 0, 0, 2239, 2240, 5, 292, 0, 0, 2240,
		2241, 5, 198, 0, 0, 2241, 2258, 5, 261, 0, 0, 2242, 2243, 5, 273, 0, 0,
		2243, 2244, 5, 222, 0, 0, 2244, 2245, 5, 181, 0, 0, 2245, 2258, 5, 261,
		0, 0, 2246, 2247, 5, 273, 0, 0, 2247, 2248, 5, 292, 0, 0, 2248, 2249, 5,
		139, 0, 0, 2249, 2258, 3, 272, 136, 0, 2250, 2251, 5, 273, 0, 0, 2251,
		2252, 5, 292, 0, 0, 2252, 2253, 5, 181, 0, 0, 2253, 2258, 3, 272, 136,
		0, 2254, 2255, 5, 273, 0, 0, 2255, 2256, 5, 292, 0, 0, 2256, 2258, 3, 272,
		136, 0, 2257, 2238, 1, 0, 0, 0, 2257, 2242, 1, 0, 0, 0, 2257, 2246, 1,
		0, 0, 0, 2257, 2250, 1, 0, 0, 0, 2257, 2254, 1, 0, 0, 0, 2258, 271, 1,
		0, 0, 0, 2259, 2260, 3, 312, 156, 0, 2260, 273, 1, 0, 0, 0, 2261, 2262,
		7, 12, 0, 0, 2262, 275, 1, 0, 0, 0, 2263, 2268, 3, 278, 139, 0, 2264, 2265,
		5, 12, 0, 0, 2265, 2267, 3, 278, 139, 0, 2266, 2264, 1, 0, 0, 0, 2267,
		2270, 1, 0, 0, 0, 2268, 2266, 1, 0, 0, 0, 2268, 2269, 1, 0, 0, 0, 2269,
		277, 1, 0, 0, 0, 2270, 2268, 1, 0, 0, 0, 2271, 2273, 3, 280, 140, 0, 2272,
		2271, 1, 0, 0, 0, 2273, 2274, 1, 0, 0, 0, 2274, 2272, 1, 0, 0, 0, 2274,
		2275, 1, 0, 0, 0, 2275, 279, 1, 0, 0, 0, 2276, 2278, 3, 284, 142, 0, 2277,
		2279, 3, 282, 141, 0, 2278, 2277, 1, 0, 0, 0, 2278, 2279, 1, 0, 0, 0, 2279,
		281, 1, 0, 0, 0, 2280, 2282, 5, 19, 0, 0, 2281, 2283, 5, 28, 0, 0, 2282,
		2281, 1, 0, 0, 0, 2282, 2283, 1, 0, 0, 0, 2283, 2309, 1, 0, 0, 0, 2284,
		2286, 5, 16, 0, 0, 2285, 2287, 5, 28, 0, 0, 2286, 2285, 1, 0, 0, 0, 2286,
		2287, 1, 0, 0, 0, 2287, 2309, 1, 0, 0, 0, 2288, 2290, 5, 28, 0, 0, 2289,
		2291, 5, 28, 0, 0, 2290, 2289, 1, 0, 0, 0, 2290, 2291, 1, 0, 0, 0, 2291,
		2309, 1, 0, 0, 0, 2292, 2294, 5, 36, 0, 0, 2293, 2295, 3, 850, 425, 0,
		2294, 2293, 1, 0, 0, 0, 2294, 2295, 1, 0, 0, 0, 2295, 2296, 1, 0, 0, 0,
		2296, 2298, 5, 25, 0, 0, 2297, 2299, 3, 850, 425, 0, 2298, 2297, 1, 0,
		0, 0, 2298, 2299, 1, 0, 0, 0, 2299, 2300, 1, 0, 0, 0, 2300, 2302, 5, 37,
		0, 0, 2301, 2303, 5, 28, 0, 0, 2302, 2301, 1, 0, 0, 0, 2302, 2303, 1, 0,
		0, 0, 2303, 2309, 1, 0, 0, 0, 2304, 2305, 5, 36, 0, 0, 2305, 2306, 3, 850,
		425, 0, 2306, 2307, 5, 37, 0, 0, 2307, 2309, 1, 0, 0, 0, 2308, 2280, 1,
		0, 0, 0, 2308, 2284, 1, 0, 0, 0, 2308, 2288, 1, 0, 0, 0, 2308, 2292, 1,
		0, 0, 0, 2308, 2304, 1, 0, 0, 0, 2309, 283, 1, 0, 0, 0, 2310, 2326, 3,
		286, 143, 0, 2311, 2326, 5, 32, 0, 0, 2312, 2326, 5, 38, 0, 0, 2313, 2315,
		5, 26, 0, 0, 2314, 2316, 3, 276, 138, 0, 2315, 2314, 1, 0, 0, 0, 2315,
		2316, 1, 0, 0, 0, 2316, 2317, 1, 0, 0, 0, 2317, 2326, 5, 27, 0, 0, 2318,
		2319, 5, 36, 0, 0, 2319, 2320, 5, 17, 0, 0, 2320, 2321, 3, 276, 138, 0,
		2321, 2322, 5, 17, 0, 0, 2322, 2323, 5, 37, 0, 0, 2323, 2326, 1, 0, 0,
		0, 2324, 2326, 3, 288, 144, 0, 2325, 2310, 1, 0, 0, 0, 2325, 2311, 1, 0,
		0, 0, 2325, 2312, 1, 0, 0, 0, 2325, 2313, 1, 0, 0, 0, 2325, 2318, 1, 0,
		0, 0, 2325, 2324, 1, 0, 0, 0, 2326, 285, 1, 0, 0, 0, 2327, 2328, 3, 312,
		156, 0, 2328, 287, 1, 0, 0, 0, 2329, 2330, 5, 225, 0, 0, 2330, 2331, 5,
		26, 0, 0, 2331, 2336, 3, 276, 138, 0, 2332, 2333, 5, 25, 0, 0, 2333, 2335,
		3, 276, 138, 0, 2334, 2332, 1, 0, 0, 0, 2335, 2338, 1, 0, 0, 0, 2336, 2334,
		1, 0, 0, 0, 2336, 2337, 1, 0, 0, 0, 2337, 2339, 1, 0, 0, 0, 2338, 2336,
		1, 0, 0, 0, 2339, 2340, 5, 27, 0, 0, 2340, 289, 1, 0, 0, 0, 2341, 2342,
		5, 278, 0, 0, 2342, 2343, 3, 292, 146, 0, 2343, 291, 1, 0, 0, 0, 2344,
		2349, 3, 294, 147, 0, 2345, 2346, 5, 25, 0, 0, 2346, 2348, 3, 294, 147,
		0, 2347, 2345, 1, 0, 0, 0, 2348, 2351, 1, 0, 0, 0, 2349, 2347, 1, 0, 0,
		0, 2349, 2350, 1, 0, 0, 0, 2350, 293, 1, 0, 0, 0, 2351, 2349, 1, 0, 0,
		0, 2352, 2353, 3, 296, 148, 0, 2353, 2354, 5, 1, 0, 0, 2354, 2355, 5, 26,
		0, 0, 2355, 2356, 3, 298, 149, 0, 2356, 2357, 5, 27, 0, 0, 2357, 295, 1,
		0, 0, 0, 2358, 2359, 3, 312, 156, 0, 2359, 297, 1, 0, 0, 0, 2360, 2365,
		3, 300, 150, 0, 2361, 2362, 5, 25, 0, 0, 2362, 2364, 3, 300, 150, 0, 2363,
		2361, 1, 0, 0, 0, 2364, 2367, 1, 0, 0, 0, 2365, 2363, 1, 0, 0, 0, 2365,
		2366, 1, 0, 0, 0, 2366, 299, 1, 0, 0, 0, 2367, 2365, 1, 0, 0, 0, 2368,
		2369, 3, 312, 156, 0, 2369, 301, 1, 0, 0, 0, 2370, 2375, 3, 304, 152, 0,
		2371, 2372, 5, 25, 0, 0, 2372, 2374, 3, 304, 152, 0, 2373, 2371, 1, 0,
		0, 0, 2374, 2377, 1, 0, 0, 0, 2375, 2373, 1, 0, 0, 0, 2375, 2376, 1, 0,
		0, 0, 2376, 303, 1, 0, 0, 0, 2377, 2375, 1, 0, 0, 0, 2378, 2379, 3, 306,
		153, 0, 2379, 2380, 5, 54, 0, 0, 2380, 2381, 3, 308, 154, 0, 2381, 305,
		1, 0, 0, 0, 2382, 2383, 3, 312, 156, 0, 2383, 307, 1, 0, 0, 0, 2384, 2385,
		3, 310, 155, 0, 2385, 309, 1, 0, 0, 0, 2386, 2387, 3, 14, 7, 0, 2387, 311,
		1, 0, 0, 0, 2388, 2389, 3, 766, 383, 0, 2389, 313, 1, 0, 0, 0, 2390, 2391,
		5, 214, 0, 0, 2391, 2392, 5, 71, 0, 0, 2392, 2393, 3, 230, 115, 0, 2393,
		315, 1, 0, 0, 0, 2394, 2396, 5, 56, 0, 0, 2395, 2394, 1, 0, 0, 0, 2395,
		2396, 1, 0, 0, 0, 2396, 2397, 1, 0, 0, 0, 2397, 2398, 3, 314, 157, 0, 2398,
		317, 1, 0, 0, 0, 2399, 2401, 5, 151, 0, 0, 2400, 2402, 5, 83, 0, 0, 2401,
		2400, 1, 0, 0, 0, 2401, 2402, 1, 0, 0, 0, 2402, 2403, 1, 0, 0, 0, 2403,
		2404, 5, 71, 0, 0, 2404, 2405, 3, 252, 126, 0, 2405, 2408, 3, 320, 160,
		0, 2406, 2407, 5, 318, 0, 0, 2407, 2409, 3, 786, 393, 0, 2408, 2406, 1,
		0, 0, 0, 2408, 2409, 1, 0, 0, 0, 2409, 319, 1, 0, 0, 0, 2410, 2415, 3,
		322, 161, 0, 2411, 2412, 5, 25, 0, 0, 2412, 2414, 3, 322, 161, 0, 2413,
		2411, 1, 0, 0, 0, 2414, 2417, 1, 0, 0, 0, 2415, 2413, 1, 0, 0, 0, 2415,
		2416, 1, 0, 0, 0, 2416, 321, 1, 0, 0, 0, 2417, 2415, 1, 0, 0, 0, 2418,
		2424, 3, 324, 162, 0, 2419, 2424, 3, 328, 164, 0, 2420, 2424, 3, 330, 165,
		0, 2421, 2424, 3, 332, 166, 0, 2422, 2424, 3, 334, 167, 0, 2423, 2418,
		1, 0, 0, 0, 2423, 2419, 1, 0, 0, 0, 2423, 2420, 1, 0, 0, 0, 2423, 2421,
		1, 0, 0, 0, 2423, 2422, 1, 0, 0, 0, 2424, 323, 1, 0, 0, 0, 2425, 2426,
		3, 128, 64, 0, 2426, 325, 1, 0, 0, 0, 2427, 2432, 3, 324, 162, 0, 2428,
		2429, 5, 25, 0, 0, 2429, 2431, 3, 324, 162, 0, 2430, 2428, 1, 0, 0, 0,
		2431, 2434, 1, 0, 0, 0, 2432, 2430, 1, 0, 0, 0, 2432, 2433, 1, 0, 0, 0,
		2433, 327, 1, 0, 0, 0, 2434, 2432, 1, 0, 0, 0, 2435, 2436, 5, 260, 0, 0,
		2436, 2437, 5, 26, 0, 0, 2437, 2438, 3, 326, 163, 0, 2438, 2439, 5, 27,
		0, 0, 2439, 329, 1, 0, 0, 0, 2440, 2441, 5, 92, 0, 0, 2441, 2442, 5, 26,
		0, 0, 2442, 2443, 3, 326, 163, 0, 2443, 2444, 5, 27, 0, 0, 2444, 331, 1,
		0, 0, 0, 2445, 2446, 5, 152, 0, 0, 2446, 2447, 5, 271, 0, 0, 2447, 2448,
		5, 26, 0, 0, 2448, 2449, 3, 320, 160, 0, 2449, 2450, 5, 27, 0, 0, 2450,
		333, 1, 0, 0, 0, 2451, 2452, 5, 156, 0, 0, 2452, 2453, 5, 26, 0, 0, 2453,
		2454, 3, 14, 7, 0, 2454, 2455, 5, 25, 0, 0, 2455, 2456, 3, 14, 7, 0, 2456,
		2457, 5, 25, 0, 0, 2457, 2458, 3, 14, 7, 0, 2458, 2459, 5, 25, 0, 0, 2459,
		2460, 3, 14, 7, 0, 2460, 2461, 5, 27, 0, 0, 2461, 335, 1, 0, 0, 0, 2462,
		2463, 3, 810, 405, 0, 2463, 2464, 5, 19, 0, 0, 2464, 2472, 1, 0, 0, 0,
		2465, 2469, 3, 14, 7, 0, 2466, 2467, 5, 54, 0, 0, 2467, 2470, 3, 788, 394,
		0, 2468, 2470, 3, 806, 403, 0, 2469, 2466, 1, 0, 0, 0, 2469, 2468, 1, 0,
		0, 0, 2469, 2470, 1, 0, 0, 0, 2470, 2472, 1, 0, 0, 0, 2471, 2462, 1, 0,
		0, 0, 2471, 2465, 1, 0, 0, 0, 2472, 337, 1, 0, 0, 0, 2473, 2475, 5, 52,
		0, 0, 2474, 2473, 1, 0, 0, 0, 2474, 2475, 1, 0, 0, 0, 2475, 2476, 1, 0,
		0, 0, 2476, 2487, 3, 344, 172, 0, 2477, 2479, 3, 358, 179, 0, 2478, 2480,
		5, 52, 0, 0, 2479, 2478, 1, 0, 0, 0, 2479, 2480, 1, 0, 0, 0, 2480, 2481,
		1, 0, 0, 0, 2481, 2483, 3, 344, 172, 0, 2482, 2484, 3, 360, 180, 0, 2483,
		2482, 1, 0, 0, 0, 2483, 2484, 1, 0, 0, 0, 2484, 2486, 1, 0, 0, 0, 2485,
		2477, 1, 0, 0, 0, 2486, 2489, 1, 0, 0, 0, 2487, 2485, 1, 0, 0, 0, 2487,
		2488, 1, 0, 0, 0, 2488, 339, 1, 0, 0, 0, 2489, 2487, 1, 0, 0, 0, 2490,
		2493, 3, 120, 60, 0, 2491, 2492, 5, 54, 0, 0, 2492, 2494, 3, 786, 393,
		0, 2493, 2491, 1, 0, 0, 0, 2493, 2494, 1, 0, 0, 0, 2494, 341, 1, 0, 0,
		0, 2495, 2504, 3, 340, 170, 0, 2496, 2497, 5, 26, 0, 0, 2497, 2499, 3,
		130, 65, 0, 2498, 2500, 5, 25, 0, 0, 2499, 2498, 1, 0, 0, 0, 2499, 2500,
		1, 0, 0, 0, 2500, 2501, 1, 0, 0, 0, 2501, 2502, 5, 27, 0, 0, 2502, 2504,
		1, 0, 0, 0, 2503, 2495, 1, 0, 0, 0, 2503, 2496, 1, 0, 0, 0, 2504, 343,
		1, 0, 0, 0, 2505, 2515, 3, 346, 173, 0, 2506, 2513, 5, 140, 0, 0, 2507,
		2509, 7, 13, 0, 0, 2508, 2507, 1, 0, 0, 0, 2508, 2509, 1, 0, 0, 0, 2509,
		2510, 1, 0, 0, 0, 2510, 2511, 5, 71, 0, 0, 2511, 2514, 3, 342, 171, 0,
		2512, 2514, 5, 81, 0, 0, 2513, 2508, 1, 0, 0, 0, 2513, 2512, 1, 0, 0, 0,
		2514, 2516, 1, 0, 0, 0, 2515, 2506, 1, 0, 0, 0, 2515, 2516, 1, 0, 0, 0,
		2516, 345, 1, 0, 0, 0, 2517, 2519, 3, 348, 174, 0, 2518, 2520, 3, 256,
		128, 0, 2519, 2518, 1, 0, 0, 0, 2519, 2520, 1, 0, 0, 0, 2520, 2529, 1,
		0, 0, 0, 2521, 2522, 5, 54, 0, 0, 2522, 2525, 3, 786, 393, 0, 2523, 2525,
		3, 806, 403, 0, 2524, 2521, 1, 0, 0, 0, 2524, 2523, 1, 0, 0, 0, 2525, 2527,
		1, 0, 0, 0, 2526, 2528, 3, 114, 57, 0, 2527, 2526, 1, 0, 0, 0, 2527, 2528,
		1, 0, 0, 0, 2528, 2530, 1, 0, 0, 0, 2529, 2524, 1, 0, 0, 0, 2529, 2530,
		1, 0, 0, 0, 2530, 2533, 1, 0, 0, 0, 2531, 2534, 3, 350, 175, 0, 2532, 2534,
		3, 352, 176, 0, 2533, 2531, 1, 0, 0, 0, 2533, 2532, 1, 0, 0, 0, 2533, 2534,
		1, 0, 0, 0, 2534, 347, 1, 0, 0, 0, 2535, 2545, 3, 628, 314, 0, 2536, 2537,
		5, 26, 0, 0, 2537, 2538, 3, 232, 116, 0, 2538, 2539, 5, 27, 0, 0, 2539,
		2545, 1, 0, 0, 0, 2540, 2541, 5, 26, 0, 0, 2541, 2542, 3, 368, 184, 0,
		2542, 2543, 5, 27, 0, 0, 2543, 2545, 1, 0, 0, 0, 2544, 2535, 1, 0, 0, 0,
		2544, 2536, 1, 0, 0, 0, 2544, 2540, 1, 0, 0, 0, 2545, 349, 1, 0, 0, 0,
		2546, 2547, 5, 263, 0, 0, 2547, 2548, 3, 14, 7, 0, 2548, 351, 1, 0, 0,
		0, 2549, 2550, 5, 285, 0, 0, 2550, 2551, 3, 354, 177, 0, 2551, 2552, 5,
		26, 0, 0, 2552, 2553, 3, 14, 7, 0, 2553, 2555, 5, 27, 0, 0, 2554, 2556,
		3, 356, 178, 0, 2555, 2554, 1, 0, 0, 0, 2555, 2556, 1, 0, 0, 0, 2556, 353,
		1, 0, 0, 0, 2557, 2558, 7, 14, 0, 0, 2558, 355, 1, 0, 0, 0, 2559, 2560,
		5, 244, 0, 0, 2560, 2561, 5, 26, 0, 0, 2561, 2562, 3, 14, 7, 0, 2562, 2563,
		5, 27, 0, 0, 2563, 357, 1, 0, 0, 0, 2564, 2589, 5, 25, 0, 0, 2565, 2567,
		5, 197, 0, 0, 2566, 2565, 1, 0, 0, 0, 2566, 2567, 1, 0, 0, 0, 2567, 2585,
		1, 0, 0, 0, 2568, 2570, 5, 182, 0, 0, 2569, 2571, 7, 15, 0, 0, 2570, 2569,
		1, 0, 0, 0, 2570, 2571, 1, 0, 0, 0, 2571, 2579, 1, 0, 0, 0, 2572, 2574,
		5, 257, 0, 0, 2573, 2575, 7, 15, 0, 0, 2574, 2573, 1, 0, 0, 0, 2574, 2575,
		1, 0, 0, 0, 2575, 2579, 1, 0, 0, 0, 2576, 2579, 5, 129, 0, 0, 2577, 2579,
		5, 146, 0, 0, 2578, 2568, 1, 0, 0, 0, 2578, 2572, 1, 0, 0, 0, 2578, 2576,
		1, 0, 0, 0, 2578, 2577, 1, 0, 0, 0, 2578, 2579, 1, 0, 0, 0, 2579, 2581,
		1, 0, 0, 0, 2580, 2582, 5, 216, 0, 0, 2581, 2580, 1, 0, 0, 0, 2581, 2582,
		1, 0, 0, 0, 2582, 2586, 1, 0, 0, 0, 2583, 2586, 5, 169, 0, 0, 2584, 2586,
		5, 91, 0, 0, 2585, 2578, 1, 0, 0, 0, 2585, 2583, 1, 0, 0, 0, 2585, 2584,
		1, 0, 0, 0, 2586, 2587, 1, 0, 0, 0, 2587, 2589, 5, 176, 0, 0, 2588, 2564,
		1, 0, 0, 0, 2588, 2566, 1, 0, 0, 0, 2589, 359, 1, 0, 0, 0, 2590, 2591,
		5, 208, 0, 0, 2591, 2595, 3, 14, 7, 0, 2592, 2593, 5, 309, 0, 0, 2593,
		2595, 3, 118, 59, 0, 2594, 2590, 1, 0, 0, 0, 2594, 2592, 1, 0, 0, 0, 2595,
		361, 1, 0, 0, 0, 2596, 2606, 5, 254, 0, 0, 2597, 2607, 5, 19, 0, 0, 2598,
		2603, 3, 786, 393, 0, 2599, 2600, 5, 25, 0, 0, 2600, 2602, 3, 786, 393,
		0, 2601, 2599, 1, 0, 0, 0, 2602, 2605, 1, 0, 0, 0, 2603, 2601, 1, 0, 0,
		0, 2603, 2604, 1, 0, 0, 0, 2604, 2607, 1, 0, 0, 0, 2605, 2603, 1, 0, 0,
		0, 2606, 2597, 1, 0, 0, 0, 2606, 2598, 1, 0, 0, 0, 2607, 363, 1, 0, 0,
		0, 2608, 2621, 5, 170, 0, 0, 2609, 2610, 5, 170, 0, 0, 2610, 2611, 5, 213,
		0, 0, 2611, 2621, 5, 43, 0, 0, 2612, 2613, 5, 170, 0, 0, 2613, 2614, 5,
		213, 0, 0, 2614, 2621, 5, 255, 0, 0, 2615, 2616, 5, 170, 0, 0, 2616, 2617,
		5, 213, 0, 0, 2617, 2621, 5, 158, 0, 0, 2618, 2621, 5, 306, 0, 0, 2619,
		2621, 5, 245, 0, 0, 2620, 2608, 1, 0, 0, 0, 2620, 2609, 1, 0, 0, 0, 2620,
		2612, 1, 0, 0, 0, 2620, 2615, 1, 0, 0, 0, 2620, 2618, 1, 0, 0, 0, 2620,
		2619, 1, 0, 0, 0, 2621, 2622, 1, 0, 0, 0, 2622, 2623, 5, 173, 0, 0, 2623,
		2624, 3, 644, 322, 0, 2624, 2626, 3, 366, 183, 0, 2625, 2627, 3, 362, 181,
		0, 2626, 2625, 1, 0, 0, 0, 2626, 2627, 1, 0, 0, 0, 2627, 365, 1, 0, 0,
		0, 2628, 2630, 3, 114, 57, 0, 2629, 2628, 1, 0, 0, 0, 2629, 2630, 1, 0,
		0, 0, 2630, 2631, 1, 0, 0, 0, 2631, 2635, 3, 370, 185, 0, 2632, 2633, 5,
		101, 0, 0, 2633, 2635, 5, 311, 0, 0, 2634, 2629, 1, 0, 0, 0, 2634, 2632,
		1, 0, 0, 0, 2635, 367, 1, 0, 0, 0, 2636, 2637, 5, 311, 0, 0, 2637, 2638,
		3, 372, 186, 0, 2638, 369, 1, 0, 0, 0, 2639, 2642, 3, 368, 184, 0, 2640,
		2642, 3, 232, 116, 0, 2641, 2639, 1, 0, 0, 0, 2641, 2640, 1, 0, 0, 0, 2642,
		371, 1, 0, 0, 0, 2643, 2648, 3, 374, 187, 0, 2644, 2645, 5, 25, 0, 0, 2645,
		2647, 3, 374, 187, 0, 2646, 2644, 1, 0, 0, 0, 2647, 2650, 1, 0, 0, 0, 2648,
		2646, 1, 0, 0, 0, 2648, 2649, 1, 0, 0, 0, 2649, 373, 1, 0, 0, 0, 2650,
		2648, 1, 0, 0, 0, 2651, 2652, 5, 26, 0, 0, 2652, 2653, 3, 112, 56, 0, 2653,
		2654, 5, 27, 0, 0, 2654, 375, 1, 0, 0, 0, 2655, 2658, 3, 112, 56, 0, 2656,
		2658, 3, 232, 116, 0, 2657, 2655, 1, 0, 0, 0, 2657, 2656, 1, 0, 0, 0, 2658,
		377, 1, 0, 0, 0, 2659, 2662, 5, 90, 0, 0, 2660, 2661, 5, 213, 0, 0, 2661,
		2663, 5, 245, 0, 0, 2662, 2660, 1, 0, 0, 0, 2662, 2663, 1, 0, 0, 0, 2663,
		2664, 1, 0, 0, 0, 2664, 2665, 5, 134, 0, 0, 2665, 2666, 5, 97, 0, 0, 2666,
		2670, 5, 274, 0, 0, 2667, 2668, 5, 157, 0, 0, 2668, 2669, 5, 200, 0, 0,
		2669, 2671, 5, 131, 0, 0, 2670, 2667, 1, 0, 0, 0, 2670, 2671, 1, 0, 0,
		0, 2671, 2672, 1, 0, 0, 0, 2672, 2673, 3, 638, 319, 0, 2673, 2674, 3, 452,
		226, 0, 2674, 379, 1, 0, 0, 0, 2675, 2676, 5, 48, 0, 0, 2676, 2677, 5,
		134, 0, 0, 2677, 2678, 5, 97, 0, 0, 2678, 2679, 5, 274, 0, 0, 2679, 2680,
		3, 638, 319, 0, 2680, 2685, 3, 382, 191, 0, 2681, 2682, 5, 25, 0, 0, 2682,
		2684, 3, 382, 191, 0, 2683, 2681, 1, 0, 0, 0, 2684, 2687, 1, 0, 0, 0, 2685,
		2683, 1, 0, 0, 0, 2685, 2686, 1, 0, 0, 0, 2686, 381, 1, 0, 0, 0, 2687,
		2685, 1, 0, 0, 0, 2688, 2692, 3, 484, 242, 0, 2689, 2692, 3, 486, 243,
		0, 2690, 2692, 3, 488, 244, 0, 2691, 2688, 1, 0, 0, 0, 2691, 2689, 1, 0,
		0, 0, 2691, 2690, 1, 0, 0, 0, 2692, 383, 1, 0, 0, 0, 2693, 2694, 5, 115,
		0, 0, 2694, 2695, 5, 134, 0, 0, 2695, 2696, 5, 97, 0, 0, 2696, 2699, 5,
		274, 0, 0, 2697, 2698, 5, 157, 0, 0, 2698, 2700, 5, 131, 0, 0, 2699, 2697,
		1, 0, 0, 0, 2699, 2700, 1, 0, 0, 0, 2700, 2701, 1, 0, 0, 0, 2701, 2702,
		3, 638, 319, 0, 2702, 385, 1, 0, 0, 0, 2703, 2704, 5, 90, 0, 0, 2704, 2705,
		5, 313, 0, 0, 2705, 2707, 3, 638, 319, 0, 2706, 2708, 3, 394, 197, 0, 2707,
		2706, 1, 0, 0, 0, 2707, 2708, 1, 0, 0, 0, 2708, 2709, 1, 0, 0, 0, 2709,
		2710, 5, 54, 0, 0, 2710, 2711, 3, 232, 116, 0, 2711, 387, 1, 0, 0, 0, 2712,
		2713, 5, 115, 0, 0, 2713, 2714, 5, 313, 0, 0, 2714, 2715, 3, 638, 319,
		0, 2715, 389, 1, 0, 0, 0, 2716, 2717, 5, 306, 0, 0, 2717, 2718, 5, 204,
		0, 0, 2718, 2719, 3, 638, 319, 0, 2719, 2720, 5, 26, 0, 0, 2720, 2721,
		5, 298, 0, 0, 2721, 2722, 3, 414, 207, 0, 2722, 2724, 5, 27, 0, 0, 2723,
		2725, 3, 394, 197, 0, 2724, 2723, 1, 0, 0, 0, 2724, 2725, 1, 0, 0, 0, 2725,
		391, 1, 0, 0, 0, 2726, 2727, 5, 90, 0, 0, 2727, 2731, 5, 204, 0, 0, 2728,
		2729, 5, 157, 0, 0, 2729, 2730, 5, 200, 0, 0, 2730, 2732, 5, 131, 0, 0,
		2731, 2728, 1, 0, 0, 0, 2731, 2732, 1, 0, 0, 0, 2732, 2733, 1, 0, 0, 0,
		2733, 2734, 3, 638, 319, 0, 2734, 2735, 5, 26, 0, 0, 2735, 2736, 5, 298,
		0, 0, 2736, 2737, 3, 414, 207, 0, 2737, 2739, 5, 27, 0, 0, 2738, 2740,
		3, 394, 197, 0, 2739, 2738, 1, 0, 0, 0, 2739, 2740, 1, 0, 0, 0, 2740, 393,
		1, 0, 0, 0, 2741, 2742, 5, 318, 0, 0, 2742, 2743, 3, 412, 206, 0, 2743,
		395, 1, 0, 0, 0, 2744, 2745, 5, 48, 0, 0, 2745, 2746, 5, 204, 0, 0, 2746,
		2747, 3, 638, 319, 0, 2747, 2748, 5, 26, 0, 0, 2748, 2749, 5, 298, 0, 0,
		2749, 2750, 3, 414, 207, 0, 2750, 2751, 5, 27, 0, 0, 2751, 2752, 3, 398,
		199, 0, 2752, 397, 1, 0, 0, 0, 2753, 2754, 5, 270, 0, 0, 2754, 2755, 3,
		412, 206, 0, 2755, 399, 1, 0, 0, 0, 2756, 2757, 5, 115, 0, 0, 2757, 2760,
		5, 204, 0, 0, 2758, 2759, 5, 157, 0, 0, 2759, 2761, 5, 131, 0, 0, 2760,
		2758, 1, 0, 0, 0, 2760, 2761, 1, 0, 0, 0, 2761, 2762, 1, 0, 0, 0, 2762,
		2763, 3, 638, 319, 0, 2763, 2764, 5, 26, 0, 0, 2764, 2765, 5, 298, 0, 0,
		2765, 2766, 3, 414, 207, 0, 2766, 2768, 5, 27, 0, 0, 2767, 2769, 3, 402,
		201, 0, 2768, 2767, 1, 0, 0, 0, 2768, 2769, 1, 0, 0, 0, 2769, 401, 1, 0,
		0, 0, 2770, 2771, 5, 318, 0, 0, 2771, 2772, 3, 412, 206, 0, 2772, 403,
		1, 0, 0, 0, 2773, 2778, 3, 814, 407, 0, 2774, 2778, 3, 144, 72, 0, 2775,
		2778, 5, 322, 0, 0, 2776, 2778, 3, 846, 423, 0, 2777, 2773, 1, 0, 0, 0,
		2777, 2774, 1, 0, 0, 0, 2777, 2775, 1, 0, 0, 0, 2777, 2776, 1, 0, 0, 0,
		2778, 405, 1, 0, 0, 0, 2779, 2780, 3, 788, 394, 0, 2780, 2781, 5, 1, 0,
		0, 2781, 2782, 3, 404, 202, 0, 2782, 407, 1, 0, 0, 0, 2783, 2784, 3, 788,
		394, 0, 2784, 409, 1, 0, 0, 0, 2785, 2788, 3, 406, 203, 0, 2786, 2788,
		3, 408, 204, 0, 2787, 2785, 1, 0, 0, 0, 2787, 2786, 1, 0, 0, 0, 2788, 411,
		1, 0, 0, 0, 2789, 2802, 3, 410, 205, 0, 2790, 2791, 5, 26, 0, 0, 2791,
		2796, 3, 410, 205, 0, 2792, 2793, 5, 25, 0, 0, 2793, 2795, 3, 410, 205,
		0, 2794, 2792, 1, 0, 0, 0, 2795, 2798, 1, 0, 0, 0, 2796, 2794, 1, 0, 0,
		0, 2796, 2797, 1, 0, 0, 0, 2797, 2799, 1, 0, 0, 0, 2798, 2796, 1, 0, 0,
		0, 2799, 2800, 5, 27, 0, 0, 2800, 2802, 1, 0, 0, 0, 2801, 2789, 1, 0, 0,
		0, 2801, 2790, 1, 0, 0, 0, 2802, 413, 1, 0, 0, 0, 2803, 2804, 3, 788, 394,
		0, 2804, 415, 1, 0, 0, 0, 2805, 2808, 5, 90, 0, 0, 2806, 2807, 5, 213,
		0, 0, 2807, 2809, 5, 245, 0, 0, 2808, 2806, 1, 0, 0, 0, 2808, 2809, 1,
		0, 0, 0, 2809, 2818, 1, 0, 0, 0, 2810, 2819, 5, 283, 0, 0, 2811, 2819,
		5, 286, 0, 0, 2812, 2813, 5, 134, 0, 0, 2813, 2819, 5, 283, 0, 0, 2814,
		2815, 5, 288, 0, 0, 2815, 2819, 5, 283, 0, 0, 2816, 2817, 5, 289, 0, 0,
		2817, 2819, 5, 283, 0, 0, 2818, 2810, 1, 0, 0, 0, 2818, 2811, 1, 0, 0,
		0, 2818, 2812, 1, 0, 0, 0, 2818, 2814, 1, 0, 0, 0, 2818, 2816, 1, 0, 0,
		0, 2819, 2823, 1, 0, 0, 0, 2820, 2821, 5, 157, 0, 0, 2821, 2822, 5, 200,
		0, 0, 2822, 2824, 5, 131, 0, 0, 2823, 2820, 1, 0, 0, 0, 2823, 2824, 1,
		0, 0, 0, 2824, 2825, 1, 0, 0, 0, 2825, 2826, 3, 642, 321, 0, 2826, 2827,
		5, 26, 0, 0, 2827, 2832, 3, 418, 209, 0, 2828, 2829, 5, 25, 0, 0, 2829,
		2831, 3, 418, 209, 0, 2830, 2828, 1, 0, 0, 0, 2831, 2834, 1, 0, 0, 0, 2832,
		2830, 1, 0, 0, 0, 2832, 2833, 1, 0, 0, 0, 2833, 2836, 1, 0, 0, 0, 2834,
		2832, 1, 0, 0, 0, 2835, 2837, 5, 25, 0, 0, 2836, 2835, 1, 0, 0, 0, 2836,
		2837, 1, 0, 0, 0, 2837, 2838, 1, 0, 0, 0, 2838, 2840, 5, 27, 0, 0, 2839,
		2841, 3, 448, 224, 0, 2840, 2839, 1, 0, 0, 0, 2840, 2841, 1, 0, 0, 0, 2841,
		2843, 1, 0, 0, 0, 2842, 2844, 3, 450, 225, 0, 2843, 2842, 1, 0, 0, 0, 2843,
		2844, 1, 0, 0, 0, 2844, 2846, 1, 0, 0, 0, 2845, 2847, 3, 452, 226, 0, 2846,
		2845, 1, 0, 0, 0, 2846, 2847, 1, 0, 0, 0, 2847, 2849, 1, 0, 0, 0, 2848,
		2850, 3, 454, 227, 0, 2849, 2848, 1, 0, 0, 0, 2849, 2850, 1, 0, 0, 0, 2850,
		2852, 1, 0, 0, 0, 2851, 2853, 3, 458, 229, 0, 2852, 2851, 1, 0, 0, 0, 2852,
		2853, 1, 0, 0, 0, 2853, 417, 1, 0, 0, 0, 2854, 2861, 3, 506, 253, 0, 2855,
		2861, 3, 514, 257, 0, 2856, 2861, 3, 516, 258, 0, 2857, 2861, 3, 546, 273,
		0, 2858, 2861, 3, 532, 266, 0, 2859, 2861, 3, 790, 395, 0, 2860, 2854,
		1, 0, 0, 0, 2860, 2855, 1, 0, 0, 0, 2860, 2856, 1, 0, 0, 0, 2860, 2857,
		1, 0, 0, 0, 2860, 2858, 1, 0, 0, 0, 2860, 2859, 1, 0, 0, 0, 2861, 419,
		1, 0, 0, 0, 2862, 2863, 5, 90, 0, 0, 2863, 2864, 3, 438, 219, 0, 2864,
		2865, 5, 318, 0, 0, 2865, 2866, 5, 26, 0, 0, 2866, 2867, 3, 440, 220, 0,
		2867, 2869, 5, 27, 0, 0, 2868, 2870, 3, 426, 213, 0, 2869, 2868, 1, 0,
		0, 0, 2869, 2870, 1, 0, 0, 0, 2870, 421, 1, 0, 0, 0, 2871, 2872, 5, 48,
		0, 0, 2872, 2875, 3, 438, 219, 0, 2873, 2876, 3, 430, 215, 0, 2874, 2876,
		3, 434, 217, 0, 2875, 2873, 1, 0, 0, 0, 2875, 2874, 1, 0, 0, 0, 2876, 423,
		1, 0, 0, 0, 2877, 2878, 5, 115, 0, 0, 2878, 2879, 3, 438, 219, 0, 2879,
		425, 1, 0, 0, 0, 2880, 2883, 5, 98, 0, 0, 2881, 2883, 3, 428, 214, 0, 2882,
		2880, 1, 0, 0, 0, 2882, 2881, 1, 0, 0, 0, 2883, 427, 1, 0, 0, 0, 2884,
		2885, 5, 283, 0, 0, 2885, 2891, 3, 798, 399, 0, 2886, 2887, 5, 25, 0, 0,
		2887, 2888, 5, 283, 0, 0, 2888, 2890, 3, 798, 399, 0, 2889, 2886, 1, 0,
		0, 0, 2890, 2893, 1, 0, 0, 0, 2891, 2889, 1, 0, 0, 0, 2891, 2892, 1, 0,
		0, 0, 2892, 429, 1, 0, 0, 0, 2893, 2891, 1, 0, 0, 0, 2894, 2899, 3, 432,
		216, 0, 2895, 2896, 5, 25, 0, 0, 2896, 2898, 3, 432, 216, 0, 2897, 2895,
		1, 0, 0, 0, 2898, 2901, 1, 0, 0, 0, 2899, 2897, 1, 0, 0, 0, 2899, 2900,
		1, 0, 0, 0, 2900, 431, 1, 0, 0, 0, 2901, 2899, 1, 0, 0, 0, 2902, 2905,
		3, 486, 243, 0, 2903, 2905, 3, 488, 244, 0, 2904, 2902, 1, 0, 0, 0, 2904,
		2903, 1, 0, 0, 0, 2905, 433, 1, 0, 0, 0, 2906, 2911, 3, 436, 218, 0, 2907,
		2908, 5, 25, 0, 0, 2908, 2910, 3, 436, 218, 0, 2909, 2907, 1, 0, 0, 0,
		2910, 2913, 1, 0, 0, 0, 2911, 2909, 1, 0, 0, 0, 2911, 2912, 1, 0, 0, 0,
		2912, 435, 1, 0, 0, 0, 2913, 2911, 1, 0, 0, 0, 2914, 2915, 5, 45, 0, 0,
		2915, 2925, 5, 98, 0, 0, 2916, 2917, 5, 115, 0, 0, 2917, 2925, 5, 98, 0,
		0, 2918, 2919, 5, 45, 0, 0, 2919, 2920, 5, 283, 0, 0, 2920, 2925, 3, 798,
		399, 0, 2921, 2922, 5, 115, 0, 0, 2922, 2923, 5, 283, 0, 0, 2923, 2925,
		3, 798, 399, 0, 2924, 2914, 1, 0, 0, 0, 2924, 2916, 1, 0, 0, 0, 2924, 2918,
		1, 0, 0, 0, 2924, 2921, 1, 0, 0, 0, 2925, 437, 1, 0, 0, 0, 2926, 2927,
		5, 64, 0, 0, 2927, 2928, 5, 65, 0, 0, 2928, 2929, 3, 638, 319, 0, 2929,
		439, 1, 0, 0, 0, 2930, 2935, 3, 442, 221, 0, 2931, 2932, 5, 25, 0, 0, 2932,
		2934, 3, 442, 221, 0, 2933, 2931, 1, 0, 0, 0, 2934, 2937, 1, 0, 0, 0, 2935,
		2933, 1, 0, 0, 0, 2935, 2936, 1, 0, 0, 0, 2936, 441, 1, 0, 0, 0, 2937,
		2935, 1, 0, 0, 0, 2938, 2939, 3, 786, 393, 0, 2939, 2940, 5, 1, 0, 0, 2940,
		2941, 3, 544, 272, 0, 2941, 443, 1, 0, 0, 0, 2942, 2943, 5, 64, 0, 0, 2943,
		2945, 3, 638, 319, 0, 2944, 2946, 5, 163, 0, 0, 2945, 2944, 1, 0, 0, 0,
		2945, 2946, 1, 0, 0, 0, 2946, 445, 1, 0, 0, 0, 2947, 2948, 5, 250, 0, 0,
		2948, 2951, 3, 638, 319, 0, 2949, 2950, 5, 59, 0, 0, 2950, 2952, 5, 322,
		0, 0, 2951, 2949, 1, 0, 0, 0, 2951, 2952, 1, 0, 0, 0, 2952, 447, 1, 0,
		0, 0, 2953, 2954, 5, 166, 0, 0, 2954, 2955, 5, 26, 0, 0, 2955, 2960, 3,
		640, 320, 0, 2956, 2957, 5, 25, 0, 0, 2957, 2959, 3, 640, 320, 0, 2958,
		2956, 1, 0, 0, 0, 2959, 2962, 1, 0, 0, 0, 2960, 2958, 1, 0, 0, 0, 2960,
		2961, 1, 0, 0, 0, 2961, 2963, 1, 0, 0, 0, 2962, 2960, 1, 0, 0, 0, 2963,
		2964, 5, 27, 0, 0, 2964, 449, 1, 0, 0, 0, 2965, 2966, 5, 219, 0, 0, 2966,
		2967, 5, 71, 0, 0, 2967, 2968, 5, 154, 0, 0, 2968, 2969, 3, 114, 57, 0,
		2969, 451, 1, 0, 0, 0, 2970, 2971, 5, 318, 0, 0, 2971, 2972, 5, 26, 0,
		0, 2972, 2977, 3, 456, 228, 0, 2973, 2974, 5, 25, 0, 0, 2974, 2976, 3,
		456, 228, 0, 2975, 2973, 1, 0, 0, 0, 2976, 2979, 1, 0, 0, 0, 2977, 2975,
		1, 0, 0, 0, 2977, 2978, 1, 0, 0, 0, 2978, 2980, 1, 0, 0, 0, 2979, 2977,
		1, 0, 0, 0, 2980, 2981, 5, 27, 0, 0, 2981, 453, 1, 0, 0, 0, 2982, 2983,
		5, 286, 0, 0, 2983, 2984, 3, 640, 320, 0, 2984, 455, 1, 0, 0, 0, 2985,
		2986, 3, 786, 393, 0, 2986, 2987, 5, 1, 0, 0, 2987, 2988, 3, 544, 272,
		0, 2988, 457, 1, 0, 0, 0, 2989, 2990, 5, 54, 0, 0, 2990, 2991, 3, 370,
		185, 0, 2991, 459, 1, 0, 0, 0, 2992, 2993, 5, 48, 0, 0, 2993, 2994, 5,
		283, 0, 0, 2994, 2995, 3, 642, 321, 0, 2995, 3000, 3, 462, 231, 0, 2996,
		2997, 5, 25, 0, 0, 2997, 2999, 3, 462, 231, 0, 2998, 2996, 1, 0, 0, 0,
		2999, 3002, 1, 0, 0, 0, 3000, 2998, 1, 0, 0, 0, 3000, 3001, 1, 0, 0, 0,
		3001, 461, 1, 0, 0, 0, 3002, 3000, 1, 0, 0, 0, 3003, 3021, 3, 472, 236,
		0, 3004, 3021, 3, 474, 237, 0, 3005, 3021, 3, 476, 238, 0, 3006, 3021,
		3, 480, 240, 0, 3007, 3021, 3, 482, 241, 0, 3008, 3021, 3, 484, 242, 0,
		3009, 3021, 3, 486, 243, 0, 3010, 3021, 3, 488, 244, 0, 3011, 3021, 3,
		490, 245, 0, 3012, 3021, 3, 492, 246, 0, 3013, 3021, 3, 494, 247, 0, 3014,
		3021, 3, 498, 249, 0, 3015, 3021, 3, 500, 250, 0, 3016, 3021, 3, 502, 251,
		0, 3017, 3021, 3, 496, 248, 0, 3018, 3021, 3, 504, 252, 0, 3019, 3021,
		3, 478, 239, 0, 3020, 3003, 1, 0, 0, 0, 3020, 3004, 1, 0, 0, 0, 3020, 3005,
		1, 0, 0, 0, 3020, 3006, 1, 0, 0, 0, 3020, 3007, 1, 0, 0, 0, 3020, 3008,
		1, 0, 0, 0, 3020, 3009, 1, 0, 0, 0, 3020, 3010, 1, 0, 0, 0, 3020, 3011,
		1, 0, 0, 0, 3020, 3012, 1, 0, 0, 0, 3020, 3013, 1, 0, 0, 0, 3020, 3014,
		1, 0, 0, 0, 3020, 3015, 1, 0, 0, 0, 3020, 3016, 1, 0, 0, 0, 3020, 3017,
		1, 0, 0, 0, 3020, 3018, 1, 0, 0, 0, 3020, 3019, 1, 0, 0, 0, 3021, 463,
		1, 0, 0, 0, 3022, 3023, 5, 48, 0, 0, 3023, 3024, 5, 134, 0, 0, 3024, 3025,
		5, 283, 0, 0, 3025, 3026, 3, 642, 321, 0, 3026, 3031, 3, 466, 233, 0, 3027,
		3028, 5, 25, 0, 0, 3028, 3030, 3, 466, 233, 0, 3029, 3027, 1, 0, 0, 0,
		3030, 3033, 1, 0, 0, 0, 3031, 3029, 1, 0, 0, 0, 3031, 3032, 1, 0, 0, 0,
		3032, 465, 1, 0, 0, 0, 3033, 3031, 1, 0, 0, 0, 3034, 3040, 3, 472, 236,
		0, 3035, 3040, 3, 474, 237, 0, 3036, 3040, 3, 484, 242, 0, 3037, 3040,
		3, 486, 243, 0, 3038, 3040, 3, 488, 244, 0, 3039, 3034, 1, 0, 0, 0, 3039,
		3035, 1, 0, 0, 0, 3039, 3036, 1, 0, 0, 0, 3039, 3037, 1, 0, 0, 0, 3039,
		3038, 1, 0, 0, 0, 3040, 467, 1, 0, 0, 0, 3041, 3042, 5, 48, 0, 0, 3042,
		3043, 5, 286, 0, 0, 3043, 3044, 3, 638, 319, 0, 3044, 3049, 3, 470, 235,
		0, 3045, 3046, 5, 25, 0, 0, 3046, 3048, 3, 470, 235, 0, 3047, 3045, 1,
		0, 0, 0, 3048, 3051, 1, 0, 0, 0, 3049, 3047, 1, 0, 0, 0, 3049, 3050, 1,
		0, 0, 0, 3050, 469, 1, 0, 0, 0, 3051, 3049, 1, 0, 0, 0, 3052, 3055, 3,
		472, 236, 0, 3053, 3055, 3, 474, 237, 0, 3054, 3052, 1, 0, 0, 0, 3054,
		3053, 1, 0, 0, 0, 3055, 471, 1, 0, 0, 0, 3056, 3058, 5, 45, 0, 0, 3057,
		3059, 5, 80, 0, 0, 3058, 3057, 1, 0, 0, 0, 3058, 3059, 1, 0, 0, 0, 3059,
		3060, 1, 0, 0, 0, 3060, 3061, 3, 506, 253, 0, 3061, 473, 1, 0, 0, 0, 3062,
		3064, 5, 115, 0, 0, 3063, 3065, 5, 80, 0, 0, 3064, 3063, 1, 0, 0, 0, 3064,
		3065, 1, 0, 0, 0, 3065, 3066, 1, 0, 0, 0, 3066, 3067, 3, 786, 393, 0, 3067,
		475, 1, 0, 0, 0, 3068, 3069, 5, 48, 0, 0, 3069, 3070, 5, 80, 0, 0, 3070,
		3071, 3, 786, 393, 0, 3071, 3072, 5, 270, 0, 0, 3072, 3073, 3, 508, 254,
		0, 3073, 477, 1, 0, 0, 0, 3074, 3075, 5, 48, 0, 0, 3075, 3076, 5, 80, 0,
		0, 3076, 3077, 3, 786, 393, 0, 3077, 3078, 5, 115, 0, 0, 3078, 3079, 5,
		200, 0, 0, 3079, 3080, 5, 202, 0, 0, 3080, 479, 1, 0, 0, 0, 3081, 3082,
		5, 45, 0, 0, 3082, 3083, 3, 546, 273, 0, 3083, 481, 1, 0, 0, 0, 3084, 3085,
		5, 48, 0, 0, 3085, 3086, 5, 137, 0, 0, 3086, 3087, 3, 786, 393, 0, 3087,
		3088, 5, 270, 0, 0, 3088, 3089, 3, 786, 393, 0, 3089, 3090, 3, 552, 276,
		0, 3090, 483, 1, 0, 0, 0, 3091, 3092, 5, 270, 0, 0, 3092, 3093, 3, 786,
		393, 0, 3093, 3094, 3, 544, 272, 0, 3094, 485, 1, 0, 0, 0, 3095, 3096,
		5, 270, 0, 0, 3096, 3097, 5, 26, 0, 0, 3097, 3102, 3, 542, 271, 0, 3098,
		3099, 5, 25, 0, 0, 3099, 3101, 3, 542, 271, 0, 3100, 3098, 1, 0, 0, 0,
		3101, 3104, 1, 0, 0, 0, 3102, 3100, 1, 0, 0, 0, 3102, 3103, 1, 0, 0, 0,
		3103, 3105, 1, 0, 0, 0, 3104, 3102, 1, 0, 0, 0, 3105, 3106, 5, 27, 0, 0,
		3106, 487, 1, 0, 0, 0, 3107, 3108, 5, 247, 0, 0, 3108, 3109, 5, 26, 0,
		0, 3109, 3114, 3, 786, 393, 0, 3110, 3111, 5, 25, 0, 0, 3111, 3113, 3,
		786, 393, 0, 3112, 3110, 1, 0, 0, 0, 3113, 3116, 1, 0, 0, 0, 3114, 3112,
		1, 0, 0, 0, 3114, 3115, 1, 0, 0, 0, 3115, 3117, 1, 0, 0, 0, 3116, 3114,
		1, 0, 0, 0, 3117, 3118, 5, 27, 0, 0, 3118, 489, 1, 0, 0, 0, 3119, 3120,
		5, 45, 0, 0, 3120, 3121, 3, 516, 258, 0, 3121, 491, 1, 0, 0, 0, 3122, 3123,
		5, 115, 0, 0, 3123, 3124, 5, 164, 0, 0, 3124, 3125, 3, 786, 393, 0, 3125,
		493, 1, 0, 0, 0, 3126, 3127, 5, 243, 0, 0, 3127, 3128, 5, 292, 0, 0, 3128,
		3129, 3, 798, 399, 0, 3129, 495, 1, 0, 0, 0, 3130, 3131, 5, 243, 0, 0,
		3131, 3132, 5, 164, 0, 0, 3132, 3133, 3, 786, 393, 0, 3133, 3134, 5, 292,
		0, 0, 3134, 3135, 3, 786, 393, 0, 3135, 497, 1, 0, 0, 0, 3136, 3137, 5,
		45, 0, 0, 3137, 3138, 3, 532, 266, 0, 3138, 499, 1, 0, 0, 0, 3139, 3140,
		5, 48, 0, 0, 3140, 3141, 5, 76, 0, 0, 3141, 3142, 3, 786, 393, 0, 3142,
		3143, 3, 540, 270, 0, 3143, 501, 1, 0, 0, 0, 3144, 3145, 5, 115, 0, 0,
		3145, 3146, 5, 76, 0, 0, 3146, 3147, 3, 786, 393, 0, 3147, 503, 1, 0, 0,
		0, 3148, 3149, 5, 48, 0, 0, 3149, 3150, 5, 164, 0, 0, 3150, 3151, 3, 786,
		393, 0, 3151, 3152, 3, 558, 279, 0, 3152, 505, 1, 0, 0, 0, 3153, 3154,
		3, 790, 395, 0, 3154, 3156, 3, 204, 102, 0, 3155, 3157, 3, 508, 254, 0,
		3156, 3155, 1, 0, 0, 0, 3156, 3157, 1, 0, 0, 0, 3157, 3158, 1, 0, 0, 0,
		3158, 3159, 3, 510, 255, 0, 3159, 507, 1, 0, 0, 0, 3160, 3161, 5, 137,
		0, 0, 3161, 3162, 3, 786, 393, 0, 3162, 509, 1, 0, 0, 0, 3163, 3165, 5,
		200, 0, 0, 3164, 3163, 1, 0, 0, 0, 3164, 3165, 1, 0, 0, 0, 3165, 3166,
		1, 0, 0, 0, 3166, 3168, 5, 202, 0, 0, 3167, 3164, 1, 0, 0, 0, 3167, 3168,
		1, 0, 0, 0, 3168, 3171, 1, 0, 0, 0, 3169, 3170, 5, 101, 0, 0, 3170, 3172,
		3, 14, 7, 0, 3171, 3169, 1, 0, 0, 0, 3171, 3172, 1, 0, 0, 0, 3172, 511,
		1, 0, 0, 0, 3173, 3175, 3, 786, 393, 0, 3174, 3176, 7, 9, 0, 0, 3175, 3174,
		1, 0, 0, 0, 3175, 3176, 1, 0, 0, 0, 3176, 513, 1, 0, 0, 0, 3177, 3178,
		5, 231, 0, 0, 3178, 3179, 5, 180, 0, 0, 3179, 3180, 5, 26, 0, 0, 3180,
		3185, 3, 786, 393, 0, 3181, 3182, 5, 25, 0, 0, 3182, 3184, 3, 786, 393,
		0, 3183, 3181, 1, 0, 0, 0, 3184, 3187, 1, 0, 0, 0, 3185, 3183, 1, 0, 0,
		0, 3185, 3186, 1, 0, 0, 0, 3186, 3188, 1, 0, 0, 0, 3187, 3185, 1, 0, 0,
		0, 3188, 3189, 5, 27, 0, 0, 3189, 3217, 1, 0, 0, 0, 3190, 3191, 5, 219,
		0, 0, 3191, 3192, 5, 71, 0, 0, 3192, 3193, 5, 26, 0, 0, 3193, 3198, 3,
		786, 393, 0, 3194, 3195, 5, 25, 0, 0, 3195, 3197, 3, 786, 393, 0, 3196,
		3194, 1, 0, 0, 0, 3197, 3200, 1, 0, 0, 0, 3198, 3196, 1, 0, 0, 0, 3198,
		3199, 1, 0, 0, 0, 3199, 3201, 1, 0, 0, 0, 3200, 3198, 1, 0, 0, 0, 3201,
		3202, 5, 27, 0, 0, 3202, 3217, 1, 0, 0, 0, 3203, 3204, 5, 214, 0, 0, 3204,
		3205, 5, 71, 0, 0, 3205, 3206, 5, 26, 0, 0, 3206, 3211, 3, 512, 256, 0,
		3207, 3208, 5, 25, 0, 0, 3208, 3210, 3, 512, 256, 0, 3209, 3207, 1, 0,
		0, 0, 3210, 3213, 1, 0, 0, 0, 3211, 3209, 1, 0, 0, 0, 3211, 3212, 1, 0,
		0, 0, 3212, 3214, 1, 0, 0, 0, 3213, 3211, 1, 0, 0, 0, 3214, 3215, 5, 27,
		0, 0, 3215, 3217, 1, 0, 0, 0, 3216, 3177, 1, 0, 0, 0, 3216, 3190, 1, 0,
		0, 0, 3216, 3203, 1, 0, 0, 0, 3217, 515, 1, 0, 0, 0, 3218, 3219, 5, 164,
		0, 0, 3219, 3220, 3, 786, 393, 0, 3220, 3221, 3, 518, 259, 0, 3221, 3222,
		5, 208, 0, 0, 3222, 3223, 5, 26, 0, 0, 3223, 3228, 3, 790, 395, 0, 3224,
		3225, 5, 25, 0, 0, 3225, 3227, 3, 790, 395, 0, 3226, 3224, 1, 0, 0, 0,
		3227, 3230, 1, 0, 0, 0, 3228, 3226, 1, 0, 0, 0, 3228, 3229, 1, 0, 0, 0,
		3229, 3231, 1, 0, 0, 0, 3230, 3228, 1, 0, 0, 0, 3231, 3244, 5, 27, 0, 0,
		3232, 3233, 5, 89, 0, 0, 3233, 3234, 5, 26, 0, 0, 3234, 3239, 3, 790, 395,
		0, 3235, 3236, 5, 25, 0, 0, 3236, 3238, 3, 790, 395, 0, 3237, 3235, 1,
		0, 0, 0, 3238, 3241, 1, 0, 0, 0, 3239, 3237, 1, 0, 0, 0, 3239, 3240, 1,
		0, 0, 0, 3240, 3242, 1, 0, 0, 0, 3241, 3239, 1, 0, 0, 0, 3242, 3243, 5,
		27, 0, 0, 3243, 3245, 1, 0, 0, 0, 3244, 3232, 1, 0, 0, 0, 3244, 3245, 1,
		0, 0, 0, 3245, 3247, 1, 0, 0, 0, 3246, 3248, 3, 526, 263, 0, 3247, 3246,
		1, 0, 0, 0, 3247, 3248, 1, 0, 0, 0, 3248, 517, 1, 0, 0, 0, 3249, 3252,
		3, 520, 260, 0, 3250, 3252, 3, 522, 261, 0, 3251, 3249, 1, 0, 0, 0, 3251,
		3250, 1, 0, 0, 0, 3252, 3255, 1, 0, 0, 0, 3253, 3254, 5, 309, 0, 0, 3254,
		3256, 3, 524, 262, 0, 3255, 3253, 1, 0, 0, 0, 3255, 3256, 1, 0, 0, 0, 3256,
		519, 1, 0, 0, 0, 3257, 3259, 5, 149, 0, 0, 3258, 3260, 5, 302, 0, 0, 3259,
		3258, 1, 0, 0, 0, 3259, 3260, 1, 0, 0, 0, 3260, 3262, 1, 0, 0, 0, 3261,
		3263, 7, 16, 0, 0, 3262, 3261, 1, 0, 0, 0, 3262, 3263, 1, 0, 0, 0, 3263,
		521, 1, 0, 0, 0, 3264, 3265, 5, 187, 0, 0, 3265, 523, 1, 0, 0, 0, 3266,
		3267, 3, 786, 393, 0, 3267, 525, 1, 0, 0, 0, 3268, 3269, 5, 318, 0, 0,
		3269, 3270, 5, 26, 0, 0, 3270, 3275, 3, 528, 264, 0, 3271, 3272, 5, 25,
		0, 0, 3272, 3274, 3, 528, 264, 0, 3273, 3271, 1, 0, 0, 0, 3274, 3277, 1,
		0, 0, 0, 3275, 3273, 1, 0, 0, 0, 3275, 3276, 1, 0, 0, 0, 3276, 3279, 1,
		0, 0, 0, 3277, 3275, 1, 0, 0, 0, 3278, 3280, 5, 25, 0, 0, 3279, 3278, 1,
		0, 0, 0, 3279, 3280, 1, 0, 0, 0, 3280, 3281, 1, 0, 0, 0, 3281, 3282, 5,
		27, 0, 0, 3282, 527, 1, 0, 0, 0, 3283, 3284, 3, 786, 393, 0, 3284, 3285,
		5, 1, 0, 0, 3285, 3286, 3, 530, 265, 0, 3286, 529, 1, 0, 0, 0, 3287, 3292,
		3, 814, 407, 0, 3288, 3292, 5, 322, 0, 0, 3289, 3292, 3, 850, 425, 0, 3290,
		3292, 3, 846, 423, 0, 3291, 3287, 1, 0, 0, 0, 3291, 3288, 1, 0, 0, 0, 3291,
		3289, 1, 0, 0, 0, 3291, 3290, 1, 0, 0, 0, 3292, 531, 1, 0, 0, 0, 3293,
		3294, 5, 76, 0, 0, 3294, 3295, 3, 786, 393, 0, 3295, 3296, 5, 318, 0, 0,
		3296, 3297, 5, 26, 0, 0, 3297, 3298, 3, 534, 267, 0, 3298, 3299, 5, 27,
		0, 0, 3299, 533, 1, 0, 0, 0, 3300, 3305, 3, 536, 268, 0, 3301, 3302, 5,
		25, 0, 0, 3302, 3304, 3, 536, 268, 0, 3303, 3301, 1, 0, 0, 0, 3304, 3307,
		1, 0, 0, 0, 3305, 3303, 1, 0, 0, 0, 3305, 3306, 1, 0, 0, 0, 3306, 535,
		1, 0, 0, 0, 3307, 3305, 1, 0, 0, 0, 3308, 3309, 3, 786, 393, 0, 3309, 3310,
		5, 1, 0, 0, 3310, 3311, 3, 538, 269, 0, 3311, 537, 1, 0, 0, 0, 3312, 3313,
		3, 14, 7, 0, 3313, 539, 1, 0, 0, 0, 3314, 3321, 5, 111, 0, 0, 3315, 3316,
		5, 270, 0, 0, 3316, 3317, 5, 26, 0, 0, 3317, 3318, 3, 534, 267, 0, 3318,
		3319, 5, 27, 0, 0, 3319, 3321, 1, 0, 0, 0, 3320, 3314, 1, 0, 0, 0, 3320,
		3315, 1, 0, 0, 0, 3321, 541, 1, 0, 0, 0, 3322, 3323, 3, 786, 393, 0, 3323,
		3324, 5, 1, 0, 0, 3324, 3325, 3, 544, 272, 0, 3325, 543, 1, 0, 0, 0, 3326,
		3339, 3, 768, 384, 0, 3327, 3339, 5, 322, 0, 0, 3328, 3339, 3, 850, 425,
		0, 3329, 3339, 3, 554, 277, 0, 3330, 3331, 3, 14, 7, 0, 3331, 3332, 5,
		208, 0, 0, 3332, 3335, 3, 786, 393, 0, 3333, 3334, 5, 54, 0, 0, 3334, 3336,
		7, 17, 0, 0, 3335, 3333, 1, 0, 0, 0, 3335, 3336, 1, 0, 0, 0, 3336, 3339,
		1, 0, 0, 0, 3337, 3339, 3, 846, 423, 0, 3338, 3326, 1, 0, 0, 0, 3338, 3327,
		1, 0, 0, 0, 3338, 3328, 1, 0, 0, 0, 3338, 3329, 1, 0, 0, 0, 3338, 3330,
		1, 0, 0, 0, 3338, 3337, 1, 0, 0, 0, 3339, 545, 1, 0, 0, 0, 3340, 3341,
		5, 137, 0, 0, 3341, 3342, 3, 786, 393, 0, 3342, 3343, 3, 548, 274, 0, 3343,
		547, 1, 0, 0, 0, 3344, 3353, 5, 26, 0, 0, 3345, 3350, 3, 550, 275, 0, 3346,
		3347, 5, 25, 0, 0, 3347, 3349, 3, 550, 275, 0, 3348, 3346, 1, 0, 0, 0,
		3349, 3352, 1, 0, 0, 0, 3350, 3348, 1, 0, 0, 0, 3350, 3351, 1, 0, 0, 0,
		3351, 3354, 1, 0, 0, 0, 3352, 3350, 1, 0, 0, 0, 3353, 3345, 1, 0, 0, 0,
		3353, 3354, 1, 0, 0, 0, 3354, 3355, 1, 0, 0, 0, 3355, 3356, 5, 27, 0, 0,
		3356, 549, 1, 0, 0, 0, 3357, 3358, 3, 786, 393, 0, 3358, 3359, 5, 1, 0,
		0, 3359, 3360, 3, 552, 276, 0, 3360, 551, 1, 0, 0, 0, 3361, 3362, 5, 322,
		0, 0, 3362, 553, 1, 0, 0, 0, 3363, 3364, 5, 26, 0, 0, 3364, 3369, 3, 556,
		278, 0, 3365, 3366, 5, 25, 0, 0, 3366, 3368, 3, 556, 278, 0, 3367, 3365,
		1, 0, 0, 0, 3368, 3371, 1, 0, 0, 0, 3369, 3367, 1, 0, 0, 0, 3369, 3370,
		1, 0, 0, 0, 3370, 3372, 1, 0, 0, 0, 3371, 3369, 1, 0, 0, 0, 3372, 3373,
		5, 27, 0, 0, 3373, 3376, 1, 0, 0, 0, 3374, 3376, 3, 556, 278, 0, 3375,
		3363, 1, 0, 0, 0, 3375, 3374, 1, 0, 0, 0, 3376, 555, 1, 0, 0, 0, 3377,
		3378, 5, 26, 0, 0, 3378, 3383, 3, 142, 71, 0, 3379, 3380, 5, 25, 0, 0,
		3380, 3382, 3, 142, 71, 0, 3381, 3379, 1, 0, 0, 0, 3382, 3385, 1, 0, 0,
		0, 3383, 3381, 1, 0, 0, 0, 3383, 3384, 1, 0, 0, 0, 3384, 3386, 1, 0, 0,
		0, 3385, 3383, 1, 0, 0, 0, 3386, 3387, 5, 27, 0, 0, 3387, 557, 1, 0, 0,
		0, 3388, 3392, 3, 484, 242, 0, 3389, 3392, 3, 486, 243, 0, 3390, 3392,
		3, 488, 244, 0, 3391, 3388, 1, 0, 0, 0, 3391, 3389, 1, 0, 0, 0, 3391, 3390,
		1, 0, 0, 0, 3392, 559, 1, 0, 0, 0, 3393, 3398, 5, 115, 0, 0, 3394, 3399,
		5, 283, 0, 0, 3395, 3399, 5, 286, 0, 0, 3396, 3397, 5, 134, 0, 0, 3397,
		3399, 5, 283, 0, 0, 3398, 3394, 1, 0, 0, 0, 3398, 3395, 1, 0, 0, 0, 3398,
		3396, 1, 0, 0, 0, 3399, 3402, 1, 0, 0, 0, 3400, 3401, 5, 157, 0, 0, 3401,
		3403, 5, 131, 0, 0, 3402, 3400, 1, 0, 0, 0, 3402, 3403, 1, 0, 0, 0, 3403,
		3404, 1, 0, 0, 0, 3404, 3405, 3, 642, 321, 0, 3405, 561, 1, 0, 0, 0, 3406,
		3407, 5, 90, 0, 0, 3407, 3408, 5, 308, 0, 0, 3408, 3410, 3, 572, 286, 0,
		3409, 3411, 3, 574, 287, 0, 3410, 3409, 1, 0, 0, 0, 3410, 3411, 1, 0, 0,
		0, 3411, 563, 1, 0, 0, 0, 3412, 3413, 5, 48, 0, 0, 3413, 3414, 5, 308,
		0, 0, 3414, 3422, 3, 572, 286, 0, 3415, 3417, 5, 318, 0, 0, 3416, 3415,
		1, 0, 0, 0, 3416, 3417, 1, 0, 0, 0, 3417, 3418, 1, 0, 0, 0, 3418, 3423,
		3, 574, 287, 0, 3419, 3420, 5, 243, 0, 0, 3420, 3421, 5, 292, 0, 0, 3421,
		3423, 3, 572, 286, 0, 3422, 3416, 1, 0, 0, 0, 3422, 3419, 1, 0, 0, 0, 3423,
		565, 1, 0, 0, 0, 3424, 3425, 5, 90, 0, 0, 3425, 3426, 5, 151, 0, 0, 3426,
		3440, 3, 572, 286, 0, 3427, 3428, 5, 318, 0, 0, 3428, 3429, 5, 308, 0,
		0, 3429, 3434, 3, 572, 286, 0, 3430, 3431, 5, 25, 0, 0, 3431, 3433, 3,
		572, 286, 0, 3432, 3430, 1, 0, 0, 0, 3433, 3436, 1, 0, 0, 0, 3434, 3432,
		1, 0, 0, 0, 3434, 3435, 1, 0, 0, 0, 3435, 3438, 1, 0, 0, 0, 3436, 3434,
		1, 0, 0, 0, 3437, 3439, 5, 25, 0, 0, 3438, 3437, 1, 0, 0, 0, 3438, 3439,
		1, 0, 0, 0, 3439, 3441, 1, 0, 0, 0, 3440, 3427, 1, 0, 0, 0, 3440, 3441,
		1, 0, 0, 0, 3441, 567, 1, 0, 0, 0, 3442, 3443, 5, 48, 0, 0, 3443, 3444,
		5, 151, 0, 0, 3444, 3461, 3, 572, 286, 0, 3445, 3446, 7, 18, 0, 0, 3446,
		3447, 5, 308, 0, 0, 3447, 3452, 3, 572, 286, 0, 3448, 3449, 5, 25, 0, 0,
		3449, 3451, 3, 572, 286, 0, 3450, 3448, 1, 0, 0, 0, 3451, 3454, 1, 0, 0,
		0, 3452, 3450, 1, 0, 0, 0, 3452, 3453, 1, 0, 0, 0, 3453, 3456, 1, 0, 0,
		0, 3454, 3452, 1, 0, 0, 0, 3455, 3457, 5, 25, 0, 0, 3456, 3455, 1, 0, 0,
		0, 3456, 3457, 1, 0, 0, 0, 3457, 3462, 1, 0, 0, 0, 3458, 3459, 5, 243,
		0, 0, 3459, 3460, 5, 292, 0, 0, 3460, 3462, 3, 572, 286, 0, 3461, 3445,
		1, 0, 0, 0, 3461, 3458, 1, 0, 0, 0, 3462, 569, 1, 0, 0, 0, 3463, 3464,
		5, 115, 0, 0, 3464, 3467, 7, 19, 0, 0, 3465, 3466, 5, 157, 0, 0, 3466,
		3468, 5, 131, 0, 0, 3467, 3465, 1, 0, 0, 0, 3467, 3468, 1, 0, 0, 0, 3468,
		3469, 1, 0, 0, 0, 3469, 3474, 3, 572, 286, 0, 3470, 3471, 5, 25, 0, 0,
		3471, 3473, 3, 572, 286, 0, 3472, 3470, 1, 0, 0, 0, 3473, 3476, 1, 0, 0,
		0, 3474, 3472, 1, 0, 0, 0, 3474, 3475, 1, 0, 0, 0, 3475, 3478, 1, 0, 0,
		0, 3476, 3474, 1, 0, 0, 0, 3477, 3479, 5, 25, 0, 0, 3478, 3477, 1, 0, 0,
		0, 3478, 3479, 1, 0, 0, 0, 3479, 571, 1, 0, 0, 0, 3480, 3483, 3, 788, 394,
		0, 3481, 3483, 3, 144, 72, 0, 3482, 3480, 1, 0, 0, 0, 3482, 3481, 1, 0,
		0, 0, 3483, 573, 1, 0, 0, 0, 3484, 3486, 5, 120, 0, 0, 3485, 3484, 1, 0,
		0, 0, 3485, 3486, 1, 0, 0, 0, 3486, 3487, 1, 0, 0, 0, 3487, 3488, 5, 221,
		0, 0, 3488, 3489, 3, 14, 7, 0, 3489, 575, 1, 0, 0, 0, 3490, 3491, 5, 150,
		0, 0, 3491, 3492, 3, 584, 292, 0, 3492, 3493, 5, 208, 0, 0, 3493, 3498,
		3, 790, 395, 0, 3494, 3495, 5, 25, 0, 0, 3495, 3497, 3, 790, 395, 0, 3496,
		3494, 1, 0, 0, 0, 3497, 3500, 1, 0, 0, 0, 3498, 3496, 1, 0, 0, 0, 3498,
		3499, 1, 0, 0, 0, 3499, 3501, 1, 0, 0, 0, 3500, 3498, 1, 0, 0, 0, 3501,
		3502, 5, 292, 0, 0, 3502, 3507, 3, 572, 286, 0, 3503, 3504, 5, 25, 0, 0,
		3504, 3506, 3, 572, 286, 0, 3505, 3503, 1, 0, 0, 0, 3506, 3509, 1, 0, 0,
		0, 3507, 3505, 1, 0, 0, 0, 3507, 3508, 1, 0, 0, 0, 3508, 3511, 1, 0, 0,
		0, 3509, 3507, 1, 0, 0, 0, 3510, 3512, 5, 25, 0, 0, 3511, 3510, 1, 0, 0,
		0, 3511, 3512, 1, 0, 0, 0, 3512, 3516, 1, 0, 0, 0, 3513, 3514, 5, 318,
		0, 0, 3514, 3515, 5, 150, 0, 0, 3515, 3517, 5, 211, 0, 0, 3516, 3513, 1,
		0, 0, 0, 3516, 3517, 1, 0, 0, 0, 3517, 577, 1, 0, 0, 0, 3518, 3522, 5,
		256, 0, 0, 3519, 3520, 5, 150, 0, 0, 3520, 3521, 5, 211, 0, 0, 3521, 3523,
		5, 143, 0, 0, 3522, 3519, 1, 0, 0, 0, 3522, 3523, 1, 0, 0, 0, 3523, 3524,
		1, 0, 0, 0, 3524, 3525, 3, 584, 292, 0, 3525, 3526, 5, 208, 0, 0, 3526,
		3531, 3, 790, 395, 0, 3527, 3528, 5, 25, 0, 0, 3528, 3530, 3, 790, 395,
		0, 3529, 3527, 1, 0, 0, 0, 3530, 3533, 1, 0, 0, 0, 3531, 3529, 1, 0, 0,
		0, 3531, 3532, 1, 0, 0, 0, 3532, 3534, 1, 0, 0, 0, 3533, 3531, 1, 0, 0,
		0, 3534, 3535, 5, 145, 0, 0, 3535, 3540, 3, 572, 286, 0, 3536, 3537, 5,
		25, 0, 0, 3537, 3539, 3, 572, 286, 0, 3538, 3536, 1, 0, 0, 0, 3539, 3542,
		1, 0, 0, 0, 3540, 3538, 1, 0, 0, 0, 3540, 3541, 1, 0, 0, 0, 3541, 579,
		1, 0, 0, 0, 3542, 3540, 1, 0, 0, 0, 3543, 3568, 5, 86, 0, 0, 3544, 3568,
		5, 186, 0, 0, 3545, 3568, 5, 170, 0, 0, 3546, 3568, 5, 188, 0, 0, 3547,
		3568, 5, 115, 0, 0, 3548, 3568, 5, 150, 0, 0, 3549, 3550, 5, 195, 0, 0,
		3550, 3568, 7, 20, 0, 0, 3551, 3552, 7, 21, 0, 0, 3552, 3568, 5, 261, 0,
		0, 3553, 3554, 7, 22, 0, 0, 3554, 3568, 5, 265, 0, 0, 3555, 3557, 5, 268,
		0, 0, 3556, 3558, 7, 23, 0, 0, 3557, 3556, 1, 0, 0, 0, 3557, 3558, 1, 0,
		0, 0, 3558, 3568, 1, 0, 0, 0, 3559, 3561, 7, 24, 0, 0, 3560, 3562, 5, 183,
		0, 0, 3561, 3560, 1, 0, 0, 0, 3561, 3562, 1, 0, 0, 0, 3562, 3568, 1, 0,
		0, 0, 3563, 3565, 5, 90, 0, 0, 3564, 3566, 7, 25, 0, 0, 3565, 3564, 1,
		0, 0, 0, 3565, 3566, 1, 0, 0, 0, 3566, 3568, 1, 0, 0, 0, 3567, 3543, 1,
		0, 0, 0, 3567, 3544, 1, 0, 0, 0, 3567, 3545, 1, 0, 0, 0, 3567, 3546, 1,
		0, 0, 0, 3567, 3547, 1, 0, 0, 0, 3567, 3548, 1, 0, 0, 0, 3567, 3549, 1,
		0, 0, 0, 3567, 3551, 1, 0, 0, 0, 3567, 3553, 1, 0, 0, 0, 3567, 3555, 1,
		0, 0, 0, 3567, 3559, 1, 0, 0, 0, 3567, 3563, 1, 0, 0, 0, 3568, 581, 1,
		0, 0, 0, 3569, 3572, 3, 580, 290, 0, 3570, 3572, 5, 322, 0, 0, 3571, 3569,
		1, 0, 0, 0, 3571, 3570, 1, 0, 0, 0, 3572, 583, 1, 0, 0, 0, 3573, 3578,
		3, 582, 291, 0, 3574, 3575, 5, 25, 0, 0, 3575, 3577, 3, 582, 291, 0, 3576,
		3574, 1, 0, 0, 0, 3577, 3580, 1, 0, 0, 0, 3578, 3576, 1, 0, 0, 0, 3578,
		3579, 1, 0, 0, 0, 3579, 3582, 1, 0, 0, 0, 3580, 3578, 1, 0, 0, 0, 3581,
		3583, 5, 25, 0, 0, 3582, 3581, 1, 0, 0, 0, 3582, 3583, 1, 0, 0, 0, 3583,
		3589, 1, 0, 0, 0, 3584, 3586, 5, 47, 0, 0, 3585, 3587, 5, 232, 0, 0, 3586,
		3585, 1, 0, 0, 0, 3586, 3587, 1, 0, 0, 0, 3587, 3589, 1, 0, 0, 0, 3588,
		3573, 1, 0, 0, 0, 3588, 3584, 1, 0, 0, 0, 3589, 585, 1, 0, 0, 0, 3590,
		3591, 5, 90, 0, 0, 3591, 3592, 5, 248, 0, 0, 3592, 3593, 5, 227, 0, 0,
		3593, 3594, 3, 638, 319, 0, 3594, 3595, 3, 452, 226, 0, 3595, 587, 1, 0,
		0, 0, 3596, 3597, 5, 48, 0, 0, 3597, 3598, 5, 248, 0, 0, 3598, 3599, 5,
		227, 0, 0, 3599, 3600, 3, 638, 319, 0, 3600, 3605, 3, 590, 295, 0, 3601,
		3602, 5, 25, 0, 0, 3602, 3604, 3, 590, 295, 0, 3603, 3601, 1, 0, 0, 0,
		3604, 3607, 1, 0, 0, 0, 3605, 3603, 1, 0, 0, 0, 3605, 3606, 1, 0, 0, 0,
		3606, 589, 1, 0, 0, 0, 3607, 3605, 1, 0, 0, 0, 3608, 3611, 3, 486, 243,
		0, 3609, 3611, 3, 488, 244, 0, 3610, 3608, 1, 0, 0, 0, 3610, 3609, 1, 0,
		0, 0, 3611, 591, 1, 0, 0, 0, 3612, 3613, 5, 115, 0, 0, 3613, 3614, 5, 248,
		0, 0, 3614, 3615, 5, 227, 0, 0, 3615, 3616, 3, 638, 319, 0, 3616, 593,
		1, 0, 0, 0, 3617, 3618, 5, 90, 0, 0, 3618, 3619, 5, 248, 0, 0, 3619, 3620,
		5, 227, 0, 0, 3620, 3621, 5, 78, 0, 0, 3621, 3622, 3, 638, 319, 0, 3622,
		3623, 3, 452, 226, 0, 3623, 595, 1, 0, 0, 0, 3624, 3625, 5, 48, 0, 0, 3625,
		3626, 5, 248, 0, 0, 3626, 3627, 5, 227, 0, 0, 3627, 3628, 5, 78, 0, 0,
		3628, 3629, 3, 638, 319, 0, 3629, 3634, 3, 598, 299, 0, 3630, 3631, 5,
		25, 0, 0, 3631, 3633, 3, 598, 299, 0, 3632, 3630, 1, 0, 0, 0, 3633, 3636,
		1, 0, 0, 0, 3634, 3632, 1, 0, 0, 0, 3634, 3635, 1, 0, 0, 0, 3635, 597,
		1, 0, 0, 0, 3636, 3634, 1, 0, 0, 0, 3637, 3640, 3, 486, 243, 0, 3638, 3640,
		3, 488, 244, 0, 3639, 3637, 1, 0, 0, 0, 3639, 3638, 1, 0, 0, 0, 3640, 599,
		1, 0, 0, 0, 3641, 3642, 5, 115, 0, 0, 3642, 3643, 5, 248, 0, 0, 3643, 3644,
		5, 227, 0, 0, 3644, 3645, 5, 78, 0, 0, 3645, 3646, 3, 638, 319, 0, 3646,
		601, 1, 0, 0, 0, 3647, 3648, 5, 90, 0, 0, 3648, 3649, 5, 58, 0, 0, 3649,
		3650, 5, 246, 0, 0, 3650, 3651, 3, 638, 319, 0, 3651, 3652, 5, 143, 0,
		0, 3652, 3657, 3, 604, 302, 0, 3653, 3654, 5, 25, 0, 0, 3654, 3656, 3,
		604, 302, 0, 3655, 3653, 1, 0, 0, 0, 3656, 3659, 1, 0, 0, 0, 3657, 3655,
		1, 0, 0, 0, 3657, 3658, 1, 0, 0, 0, 3658, 3660, 1, 0, 0, 0, 3659, 3657,
		1, 0, 0, 0, 3660, 3661, 5, 318, 0, 0, 3661, 3662, 5, 26, 0, 0, 3662, 3663,
		3, 606, 303, 0, 3663, 3664, 5, 27, 0, 0, 3664, 603, 1, 0, 0, 0, 3665, 3666,
		3, 638, 319, 0, 3666, 3667, 5, 54, 0, 0, 3667, 3668, 3, 638, 319, 0, 3668,
		605, 1, 0, 0, 0, 3669, 3674, 3, 608, 304, 0, 3670, 3671, 5, 25, 0, 0, 3671,
		3673, 3, 608, 304, 0, 3672, 3670, 1, 0, 0, 0, 3673, 3676, 1, 0, 0, 0, 3674,
		3672, 1, 0, 0, 0, 3674, 3675, 1, 0, 0, 0, 3675, 607, 1, 0, 0, 0, 3676,
		3674, 1, 0, 0, 0, 3677, 3678, 3, 786, 393, 0, 3678, 3679, 5, 1, 0, 0, 3679,
		3680, 5, 322, 0, 0, 3680, 609, 1, 0, 0, 0, 3681, 3682, 5, 48, 0, 0, 3682,
		3683, 5, 58, 0, 0, 3683, 3684, 5, 246, 0, 0, 3684, 3685, 3, 638, 319, 0,
		3685, 3690, 3, 612, 306, 0, 3686, 3687, 5, 25, 0, 0, 3687, 3689, 3, 612,
		306, 0, 3688, 3686, 1, 0, 0, 0, 3689, 3692, 1, 0, 0, 0, 3690, 3688, 1,
		0, 0, 0, 3690, 3691, 1, 0, 0, 0, 3691, 611, 1, 0, 0, 0, 3692, 3690, 1,
		0, 0, 0, 3693, 3694, 3, 614, 307, 0, 3694, 613, 1, 0, 0, 0, 3695, 3696,
		5, 270, 0, 0, 3696, 3697, 5, 26, 0, 0, 3697, 3698, 3, 606, 303, 0, 3698,
		3699, 5, 27, 0, 0, 3699, 615, 1, 0, 0, 0, 3700, 3701, 5, 115, 0, 0, 3701,
		3702, 5, 58, 0, 0, 3702, 3703, 5, 246, 0, 0, 3703, 3705, 3, 638, 319, 0,
		3704, 3706, 5, 73, 0, 0, 3705, 3704, 1, 0, 0, 0, 3705, 3706, 1, 0, 0, 0,
		3706, 617, 1, 0, 0, 0, 3707, 3712, 3, 146, 73, 0, 3708, 3709, 5, 25, 0,
		0, 3709, 3711, 3, 146, 73, 0, 3710, 3708, 1, 0, 0, 0, 3711, 3714, 1, 0,
		0, 0, 3712, 3710, 1, 0, 0, 0, 3712, 3713, 1, 0, 0, 0, 3713, 619, 1, 0,
		0, 0, 3714, 3712, 1, 0, 0, 0, 3715, 3716, 5, 104, 0, 0, 3716, 3717, 7,
		26, 0, 0, 3717, 3718, 3, 144, 72, 0, 3718, 3720, 5, 26, 0, 0, 3719, 3721,
		3, 618, 309, 0, 3720, 3719, 1, 0, 0, 0, 3720, 3721, 1, 0, 0, 0, 3721, 3722,
		1, 0, 0, 0, 3722, 3723, 5, 27, 0, 0, 3723, 3724, 5, 54, 0, 0, 3724, 3725,
		3, 622, 311, 0, 3725, 3726, 5, 121, 0, 0, 3726, 3727, 5, 104, 0, 0, 3727,
		621, 1, 0, 0, 0, 3728, 3730, 5, 23, 0, 0, 3729, 3728, 1, 0, 0, 0, 3730,
		3733, 1, 0, 0, 0, 3731, 3729, 1, 0, 0, 0, 3731, 3732, 1, 0, 0, 0, 3732,
		3752, 1, 0, 0, 0, 3733, 3731, 1, 0, 0, 0, 3734, 3743, 3, 12, 6, 0, 3735,
		3737, 5, 23, 0, 0, 3736, 3735, 1, 0, 0, 0, 3737, 3738, 1, 0, 0, 0, 3738,
		3736, 1, 0, 0, 0, 3738, 3739, 1, 0, 0, 0, 3739, 3740, 1, 0, 0, 0, 3740,
		3742, 3, 12, 6, 0, 3741, 3736, 1, 0, 0, 0, 3742, 3745, 1, 0, 0, 0, 3743,
		3741, 1, 0, 0, 0, 3743, 3744, 1, 0, 0, 0, 3744, 3749, 1, 0, 0, 0, 3745,
		3743, 1, 0, 0, 0, 3746, 3748, 5, 23, 0, 0, 3747, 3746, 1, 0, 0, 0, 3748,
		3751, 1, 0, 0, 0, 3749, 3747, 1, 0, 0, 0, 3749, 3750, 1, 0, 0, 0, 3750,
		3753, 1, 0, 0, 0, 3751, 3749, 1, 0, 0, 0, 3752, 3734, 1, 0, 0, 0, 3752,
		3753, 1, 0, 0, 0, 3753, 623, 1, 0, 0, 0, 3754, 3756, 5, 126, 0, 0, 3755,
		3754, 1, 0, 0, 0, 3755, 3756, 1, 0, 0, 0, 3756, 3757, 1, 0, 0, 0, 3757,
		3758, 5, 157, 0, 0, 3758, 3759, 3, 14, 7, 0, 3759, 3762, 3, 222, 111, 0,
		3760, 3761, 5, 117, 0, 0, 3761, 3763, 3, 222, 111, 0, 3762, 3760, 1, 0,
		0, 0, 3762, 3763, 1, 0, 0, 0, 3763, 625, 1, 0, 0, 0, 3764, 3766, 5, 126,
		0, 0, 3765, 3764, 1, 0, 0, 0, 3765, 3766, 1, 0, 0, 0, 3766, 3768, 1, 0,
		0, 0, 3767, 3769, 5, 218, 0, 0, 3768, 3767, 1, 0, 0, 0, 3768, 3769, 1,
		0, 0, 0, 3769, 3770, 1, 0, 0, 0, 3770, 3771, 5, 143, 0, 0, 3771, 3772,
		3, 144, 72, 0, 3772, 3773, 5, 162, 0, 0, 3773, 3774, 3, 14, 7, 0, 3774,
		3777, 3, 222, 111, 0, 3775, 3776, 5, 117, 0, 0, 3776, 3778, 3, 222, 111,
		0, 3777, 3775, 1, 0, 0, 0, 3777, 3778, 1, 0, 0, 0, 3778, 627, 1, 0, 0,
		0, 3779, 3780, 3, 812, 406, 0, 3780, 3781, 5, 24, 0, 0, 3781, 3783, 1,
		0, 0, 0, 3782, 3779, 1, 0, 0, 0, 3782, 3783, 1, 0, 0, 0, 3783, 3785, 1,
		0, 0, 0, 3784, 3786, 5, 30, 0, 0, 3785, 3784, 1, 0, 0, 0, 3785, 3786, 1,
		0, 0, 0, 3786, 3817, 1, 0, 0, 0, 3787, 3818, 3, 630, 315, 0, 3788, 3789,
		3, 792, 396, 0, 3789, 3801, 5, 26, 0, 0, 3790, 3795, 3, 632, 316, 0, 3791,
		3792, 5, 25, 0, 0, 3792, 3794, 3, 632, 316, 0, 3793, 3791, 1, 0, 0, 0,
		3794, 3797, 1, 0, 0, 0, 3795, 3793, 1, 0, 0, 0, 3795, 3796, 1, 0, 0, 0,
		3796, 3799, 1, 0, 0, 0, 3797, 3795, 1, 0, 0, 0, 3798, 3800, 5, 25, 0, 0,
		3799, 3798, 1, 0, 0, 0, 3799, 3800, 1, 0, 0, 0, 3800, 3802, 1, 0, 0, 0,
		3801, 3790, 1, 0, 0, 0, 3801, 3802, 1, 0, 0, 0, 3802, 3803, 1, 0, 0, 0,
		3803, 3804, 5, 27, 0, 0, 3804, 3818, 1, 0, 0, 0, 3805, 3811, 3, 144, 72,
		0, 3806, 3808, 5, 26, 0, 0, 3807, 3809, 3, 112, 56, 0, 3808, 3807, 1, 0,
		0, 0, 3808, 3809, 1, 0, 0, 0, 3809, 3810, 1, 0, 0, 0, 3810, 3812, 5, 27,
		0, 0, 3811, 3806, 1, 0, 0, 0, 3811, 3812, 1, 0, 0, 0, 3812, 3815, 1, 0,
		0, 0, 3813, 3814, 5, 313, 0, 0, 3814, 3816, 3, 808, 404, 0, 3815, 3813,
		1, 0, 0, 0, 3815, 3816, 1, 0, 0, 0, 3816, 3818, 1, 0, 0, 0, 3817, 3787,
		1, 0, 0, 0, 3817, 3788, 1, 0, 0, 0, 3817, 3805, 1, 0, 0, 0, 3818, 3820,
		1, 0, 0, 0, 3819, 3821, 3, 634, 317, 0, 3820, 3819, 1, 0, 0, 0, 3820, 3821,
		1, 0, 0, 0, 3821, 629, 1, 0, 0, 0, 3822, 3825, 3, 820, 410, 0, 3823, 3824,
		5, 313, 0, 0, 3824, 3826, 3, 808, 404, 0, 3825, 3823, 1, 0, 0, 0, 3825,
		3826, 1, 0, 0, 0, 3826, 631, 1, 0, 0, 0, 3827, 3829, 5, 30, 0, 0, 3828,
		3827, 1, 0, 0, 0, 3828, 3829, 1, 0, 0, 0, 3829, 3830, 1, 0, 0, 0, 3830,
		3833, 3, 128, 64, 0, 3831, 3832, 5, 313, 0, 0, 3832, 3834, 3, 808, 404,
		0, 3833, 3831, 1, 0, 0, 0, 3833, 3834, 1, 0, 0, 0, 3834, 633, 1, 0, 0,
		0, 3835, 3848, 5, 318, 0, 0, 3836, 3849, 3, 636, 318, 0, 3837, 3838, 5,
		26, 0, 0, 3838, 3843, 3, 636, 318, 0, 3839, 3840, 5, 25, 0, 0, 3840, 3842,
		3, 636, 318, 0, 3841, 3839, 1, 0, 0, 0, 3842, 3845, 1, 0, 0, 0, 3843, 3841,
		1, 0, 0, 0, 3843, 3844, 1, 0, 0, 0, 3844, 3846, 1, 0, 0, 0, 3845, 3843,
		1, 0, 0, 0, 3846, 3847, 5, 27, 0, 0, 3847, 3849, 1, 0, 0, 0, 3848, 3836,
		1, 0, 0, 0, 3848, 3837, 1, 0, 0, 0, 3849, 635, 1, 0, 0, 0, 3850, 3869,
		3, 802, 401, 0, 3851, 3867, 5, 1, 0, 0, 3852, 3868, 3, 160, 80, 0, 3853,
		3854, 5, 26, 0, 0, 3854, 3859, 3, 160, 80, 0, 3855, 3856, 5, 25, 0, 0,
		3856, 3858, 3, 160, 80, 0, 3857, 3855, 1, 0, 0, 0, 3858, 3861, 1, 0, 0,
		0, 3859, 3857, 1, 0, 0, 0, 3859, 3860, 1, 0, 0, 0, 3860, 3863, 1, 0, 0,
		0, 3861, 3859, 1, 0, 0, 0, 3862, 3864, 5, 25, 0, 0, 3863, 3862, 1, 0, 0,
		0, 3863, 3864, 1, 0, 0, 0, 3864, 3865, 1, 0, 0, 0, 3865, 3866, 5, 27, 0,
		0, 3866, 3868, 1, 0, 0, 0, 3867, 3852, 1, 0, 0, 0, 3867, 3853, 1, 0, 0,
		0, 3868, 3870, 1, 0, 0, 0, 3869, 3851, 1, 0, 0, 0, 3869, 3870, 1, 0, 0,
		0, 3870, 3896, 1, 0, 0, 0, 3871, 3873, 7, 27, 0, 0, 3872, 3874, 5, 1, 0,
		0, 3873, 3872, 1, 0, 0, 0, 3873, 3874, 1, 0, 0, 0, 3874, 3875, 1, 0, 0,
		0, 3875, 3896, 3, 204, 102, 0, 3876, 3878, 5, 265, 0, 0, 3877, 3879, 5,
		1, 0, 0, 3878, 3877, 1, 0, 0, 0, 3878, 3879, 1, 0, 0, 0, 3879, 3880, 1,
		0, 0, 0, 3880, 3889, 5, 26, 0, 0, 3881, 3886, 3, 164, 82, 0, 3882, 3883,
		5, 25, 0, 0, 3883, 3885, 3, 164, 82, 0, 3884, 3882, 1, 0, 0, 0, 3885, 3888,
		1, 0, 0, 0, 3886, 3884, 1, 0, 0, 0, 3886, 3887, 1, 0, 0, 0, 3887, 3890,
		1, 0, 0, 0, 3888, 3886, 1, 0, 0, 0, 3889, 3881, 1, 0, 0, 0, 3889, 3890,
		1, 0, 0, 0, 3890, 3892, 1, 0, 0, 0, 3891, 3893, 5, 25, 0, 0, 3892, 3891,
		1, 0, 0, 0, 3892, 3893, 1, 0, 0, 0, 3893, 3894, 1, 0, 0, 0, 3894, 3896,
		5, 27, 0, 0, 3895, 3850, 1, 0, 0, 0, 3895, 3871, 1, 0, 0, 0, 3895, 3876,
		1, 0, 0, 0, 3896, 637, 1, 0, 0, 0, 3897, 3898, 3, 812, 406, 0, 3898, 3899,
		5, 24, 0, 0, 3899, 3901, 1, 0, 0, 0, 3900, 3897, 1, 0, 0, 0, 3900, 3901,
		1, 0, 0, 0, 3901, 3902, 1, 0, 0, 0, 3902, 3903, 3, 818, 409, 0, 3903, 639,
		1, 0, 0, 0, 3904, 3910, 3, 638, 319, 0, 3905, 3907, 5, 30, 0, 0, 3906,
		3905, 1, 0, 0, 0, 3906, 3907, 1, 0, 0, 0, 3907, 3908, 1, 0, 0, 0, 3908,
		3910, 3, 144, 72, 0, 3909, 3904, 1, 0, 0, 0, 3909, 3906, 1, 0, 0, 0, 3910,
		641, 1, 0, 0, 0, 3911, 3913, 3, 640, 320, 0, 3912, 3914, 3, 634, 317, 0,
		3913, 3912, 1, 0, 0, 0, 3913, 3914, 1, 0, 0, 0, 3914, 643, 1, 0, 0, 0,
		3915, 3919, 3, 642, 321, 0, 3916, 3917, 5, 123, 0, 0, 3917, 3918, 5, 71,
		0, 0, 3918, 3920, 3, 114, 57, 0, 3919, 3916, 1, 0, 0, 0, 3919, 3920, 1,
		0, 0, 0, 3920, 645, 1, 0, 0, 0, 3921, 3922, 5, 105, 0, 0, 3922, 3923, 5,
		145, 0, 0, 3923, 3928, 3, 642, 321, 0, 3924, 3925, 5, 316, 0, 0, 3925,
		3929, 3, 14, 7, 0, 3926, 3927, 5, 208, 0, 0, 3927, 3929, 3, 366, 183, 0,
		3928, 3924, 1, 0, 0, 0, 3928, 3926, 1, 0, 0, 0, 3928, 3929, 1, 0, 0, 0,
		3929, 3931, 1, 0, 0, 0, 3930, 3932, 3, 362, 181, 0, 3931, 3930, 1, 0, 0,
		0, 3931, 3932, 1, 0, 0, 0, 3932, 647, 1, 0, 0, 0, 3933, 3934, 5, 305, 0,
		0, 3934, 3943, 3, 642, 321, 0, 3935, 3936, 5, 270, 0, 0, 3936, 3939, 3,
		650, 325, 0, 3937, 3938, 5, 316, 0, 0, 3938, 3940, 3, 14, 7, 0, 3939, 3937,
		1, 0, 0, 0, 3939, 3940, 1, 0, 0, 0, 3940, 3944, 1, 0, 0, 0, 3941, 3942,
		5, 208, 0, 0, 3942, 3944, 3, 366, 183, 0, 3943, 3935, 1, 0, 0, 0, 3943,
		3941, 1, 0, 0, 0, 3944, 3946, 1, 0, 0, 0, 3945, 3947, 3, 362, 181, 0, 3946,
		3945, 1, 0, 0, 0, 3946, 3947, 1, 0, 0, 0, 3947, 649, 1, 0, 0, 0, 3948,
		3951, 3, 652, 326, 0, 3949, 3951, 3, 658, 329, 0, 3950, 3948, 1, 0, 0,
		0, 3950, 3949, 1, 0, 0, 0, 3951, 651, 1, 0, 0, 0, 3952, 3957, 3, 654, 327,
		0, 3953, 3954, 5, 25, 0, 0, 3954, 3956, 3, 654, 327, 0, 3955, 3953, 1,
		0, 0, 0, 3956, 3959, 1, 0, 0, 0, 3957, 3955, 1, 0, 0, 0, 3957, 3958, 1,
		0, 0, 0, 3958, 653, 1, 0, 0, 0, 3959, 3957, 1, 0, 0, 0, 3960, 3961, 3,
		656, 328, 0, 3961, 3962, 5, 1, 0, 0, 3962, 3963, 3, 14, 7, 0, 3963, 655,
		1, 0, 0, 0, 3964, 3965, 3, 120, 60, 0, 3965, 657, 1, 0, 0, 0, 3966, 3967,
		3, 660, 330, 0, 3967, 3968, 5, 1, 0, 0, 3968, 3969, 5, 26, 0, 0, 3969,
		3970, 3, 376, 188, 0, 3970, 3971, 5, 27, 0, 0, 3971, 659, 1, 0, 0, 0, 3972,
		3973, 5, 26, 0, 0, 3973, 3978, 3, 656, 328, 0, 3974, 3975, 5, 25, 0, 0,
		3975, 3977, 3, 656, 328, 0, 3976, 3974, 1, 0, 0, 0, 3977, 3980, 1, 0, 0,
		0, 3978, 3976, 1, 0, 0, 0, 3978, 3979, 1, 0, 0, 0, 3979, 3981, 1, 0, 0,
		0, 3980, 3978, 1, 0, 0, 0, 3981, 3982, 5, 27, 0, 0, 3982, 661, 1, 0, 0,
		0, 3983, 3984, 5, 90, 0, 0, 3984, 3988, 5, 293, 0, 0, 3985, 3986, 5, 157,
		0, 0, 3986, 3987, 5, 200, 0, 0, 3987, 3989, 5, 131, 0, 0, 3988, 3985, 1,
		0, 0, 0, 3988, 3989, 1, 0, 0, 0, 3989, 3990, 1, 0, 0, 0, 3990, 3992, 3,
		708, 354, 0, 3991, 3993, 3, 664, 332, 0, 3992, 3991, 1, 0, 0, 0, 3992,
		3993, 1, 0, 0, 0, 3993, 3995, 1, 0, 0, 0, 3994, 3996, 3, 668, 334, 0, 3995,
		3994, 1, 0, 0, 0, 3995, 3996, 1, 0, 0, 0, 3996, 663, 1, 0, 0, 0, 3997,
		3998, 5, 26, 0, 0, 3998, 4003, 3, 666, 333, 0, 3999, 4000, 5, 25, 0, 0,
		4000, 4002, 3, 666, 333, 0, 4001, 3999, 1, 0, 0, 0, 4002, 4005, 1, 0, 0,
		0, 4003, 4001, 1, 0, 0, 0, 4003, 4004, 1, 0, 0, 0, 4004, 4006, 1, 0, 0,
		0, 4005, 4003, 1, 0, 0, 0, 4006, 4007, 5, 27, 0, 0, 4007, 665, 1, 0, 0,
		0, 4008, 4009, 3, 676, 338, 0, 4009, 667, 1, 0, 0, 0, 4010, 4011, 5, 318,
		0, 0, 4011, 4012, 5, 26, 0, 0, 4012, 4013, 3, 694, 347, 0, 4013, 4014,
		5, 27, 0, 0, 4014, 669, 1, 0, 0, 0, 4015, 4016, 5, 48, 0, 0, 4016, 4019,
		5, 293, 0, 0, 4017, 4018, 5, 157, 0, 0, 4018, 4020, 5, 131, 0, 0, 4019,
		4017, 1, 0, 0, 0, 4019, 4020, 1, 0, 0, 0, 4020, 4021, 1, 0, 0, 0, 4021,
		4022, 3, 708, 354, 0, 4022, 4027, 3, 672, 336, 0, 4023, 4024, 5, 25, 0,
		0, 4024, 4026, 3, 672, 336, 0, 4025, 4023, 1, 0, 0, 0, 4026, 4029, 1, 0,
		0, 0, 4027, 4025, 1, 0, 0, 0, 4027, 4028, 1, 0, 0, 0, 4028, 671, 1, 0,
		0, 0, 4029, 4027, 1, 0, 0, 0, 4030, 4036, 3, 674, 337, 0, 4031, 4036, 3,
		678, 339, 0, 4032, 4036, 3, 682, 341, 0, 4033, 4036, 3, 688, 344, 0, 4034,
		4036, 3, 690, 345, 0, 4035, 4030, 1, 0, 0, 0, 4035, 4031, 1, 0, 0, 0, 4035,
		4032, 1, 0, 0, 0, 4035, 4033, 1, 0, 0, 0, 4035, 4034, 1, 0, 0, 0, 4036,
		673, 1, 0, 0, 0, 4037, 4038, 5, 45, 0, 0, 4038, 4039, 3, 676, 338, 0, 4039,
		675, 1, 0, 0, 0, 4040, 4041, 5, 88, 0, 0, 4041, 4043, 3, 786, 393, 0, 4042,
		4044, 3, 700, 350, 0, 4043, 4042, 1, 0, 0, 0, 4043, 4044, 1, 0, 0, 0, 4044,
		677, 1, 0, 0, 0, 4045, 4046, 5, 48, 0, 0, 4046, 4047, 5, 88, 0, 0, 4047,
		4048, 3, 710, 355, 0, 4048, 4049, 3, 680, 340, 0, 4049, 679, 1, 0, 0, 0,
		4050, 4053, 3, 684, 342, 0, 4051, 4053, 3, 686, 343, 0, 4052, 4050, 1,
		0, 0, 0, 4052, 4051, 1, 0, 0, 0, 4053, 681, 1, 0, 0, 0, 4054, 4055, 5,
		115, 0, 0, 4055, 4056, 5, 88, 0, 0, 4056, 4057, 3, 710, 355, 0, 4057, 683,
		1, 0, 0, 0, 4058, 4059, 5, 270, 0, 0, 4059, 4060, 5, 26, 0, 0, 4060, 4061,
		3, 702, 351, 0, 4061, 4062, 5, 27, 0, 0, 4062, 685, 1, 0, 0, 0, 4063, 4064,
		5, 247, 0, 0, 4064, 4065, 5, 26, 0, 0, 4065, 4070, 3, 786, 393, 0, 4066,
		4067, 5, 25, 0, 0, 4067, 4069, 3, 786, 393, 0, 4068, 4066, 1, 0, 0, 0,
		4069, 4072, 1, 0, 0, 0, 4070, 4068, 1, 0, 0, 0, 4070, 4071, 1, 0, 0, 0,
		4071, 4073, 1, 0, 0, 0, 4072, 4070, 1, 0, 0, 0, 4073, 4074, 5, 27, 0, 0,
		4074, 687, 1, 0, 0, 0, 4075, 4076, 5, 270, 0, 0, 4076, 4077, 5, 26, 0,
		0, 4077, 4078, 3, 694, 347, 0, 4078, 4079, 5, 27, 0, 0, 4079, 689, 1, 0,
		0, 0, 4080, 4081, 5, 247, 0, 0, 4081, 4082, 5, 26, 0, 0, 4082, 4087, 3,
		786, 393, 0, 4083, 4084, 5, 25, 0, 0, 4084, 4086, 3, 804, 402, 0, 4085,
		4083, 1, 0, 0, 0, 4086, 4089, 1, 0, 0, 0, 4087, 4085, 1, 0, 0, 0, 4087,
		4088, 1, 0, 0, 0, 4088, 4090, 1, 0, 0, 0, 4089, 4087, 1, 0, 0, 0, 4090,
		4091, 5, 27, 0, 0, 4091, 691, 1, 0, 0, 0, 4092, 4093, 5, 115, 0, 0, 4093,
		4096, 5, 293, 0, 0, 4094, 4095, 5, 157, 0, 0, 4095, 4097, 5, 131, 0, 0,
		4096, 4094, 1, 0, 0, 0, 4096, 4097, 1, 0, 0, 0, 4097, 4098, 1, 0, 0, 0,
		4098, 4099, 3, 708, 354, 0, 4099, 693, 1, 0, 0, 0, 4100, 4105, 3, 696,
		348, 0, 4101, 4102, 5, 25, 0, 0, 4102, 4104, 3, 696, 348, 0, 4103, 4101,
		1, 0, 0, 0, 4104, 4107, 1, 0, 0, 0, 4105, 4103, 1, 0, 0, 0, 4105, 4106,
		1, 0, 0, 0, 4106, 695, 1, 0, 0, 0, 4107, 4105, 1, 0, 0, 0, 4108, 4109,
		3, 786, 393, 0, 4109, 4110, 5, 1, 0, 0, 4110, 4111, 3, 698, 349, 0, 4111,
		697, 1, 0, 0, 0, 4112, 4113, 3, 14, 7, 0, 4113, 699, 1, 0, 0, 0, 4114,
		4115, 5, 318, 0, 0, 4115, 4116, 5, 26, 0, 0, 4116, 4117, 3, 702, 351, 0,
		4117, 4118, 5, 27, 0, 0, 4118, 701, 1, 0, 0, 0, 4119, 4124, 3, 704, 352,
		0, 4120, 4121, 5, 25, 0, 0, 4121, 4123, 3, 704, 352, 0, 4122, 4120, 1,
		0, 0, 0, 4123, 4126, 1, 0, 0, 0, 4124, 4122, 1, 0, 0, 0, 4124, 4125, 1,
		0, 0, 0, 4125, 703, 1, 0, 0, 0, 4126, 4124, 1, 0, 0, 0, 4127, 4128, 3,
		786, 393, 0, 4128, 4129, 5, 1, 0, 0, 4129, 4130, 3, 706, 353, 0, 4130,
		705, 1, 0, 0, 0, 4131, 4132, 3, 14, 7, 0, 4132, 707, 1, 0, 0, 0, 4133,
		4134, 3, 812, 406, 0, 4134, 4135, 5, 24, 0, 0, 4135, 4137, 1, 0, 0, 0,
		4136, 4133, 1, 0, 0, 0, 4136, 4137, 1, 0, 0, 0, 4137, 4138, 1, 0, 0, 0,
		4138, 4139, 3, 786, 393, 0, 4139, 709, 1, 0, 0, 0, 4140, 4141, 3, 804,
		402, 0, 4141, 711, 1, 0, 0, 0, 4142, 4143, 5, 249, 0, 0, 4143, 4147, 5,
		203, 0, 0, 4144, 4145, 5, 158, 0, 0, 4145, 4147, 5, 203, 0, 0, 4146, 4142,
		1, 0, 0, 0, 4146, 4144, 1, 0, 0, 0, 4147, 713, 1, 0, 0, 0, 4148, 4149,
		5, 138, 0, 0, 4149, 4150, 5, 26, 0, 0, 4150, 4151, 5, 316, 0, 0, 4151,
		4152, 3, 14, 7, 0, 4152, 4153, 5, 27, 0, 0, 4153, 715, 1, 0, 0, 0, 4154,
		4157, 3, 718, 359, 0, 4155, 4157, 3, 728, 364, 0, 4156, 4154, 1, 0, 0,
		0, 4156, 4155, 1, 0, 0, 0, 4157, 717, 1, 0, 0, 0, 4158, 4159, 3, 796, 398,
		0, 4159, 719, 1, 0, 0, 0, 4160, 4161, 5, 317, 0, 0, 4161, 4162, 3, 722,
		361, 0, 4162, 721, 1, 0, 0, 0, 4163, 4168, 3, 724, 362, 0, 4164, 4165,
		5, 25, 0, 0, 4165, 4167, 3, 724, 362, 0, 4166, 4164, 1, 0, 0, 0, 4167,
		4170, 1, 0, 0, 0, 4168, 4166, 1, 0, 0, 0, 4168, 4169, 1, 0, 0, 0, 4169,
		723, 1, 0, 0, 0, 4170, 4168, 1, 0, 0, 0, 4171, 4172, 3, 726, 363, 0, 4172,
		4173, 5, 54, 0, 0, 4173, 4174, 3, 728, 364, 0, 4174, 725, 1, 0, 0, 0, 4175,
		4176, 3, 718, 359, 0, 4176, 727, 1, 0, 0, 0, 4177, 4178, 5, 26, 0, 0, 4178,
		4179, 3, 730, 365, 0, 4179, 4180, 5, 27, 0, 0, 4180, 729, 1, 0, 0, 0, 4181,
		4183, 3, 732, 366, 0, 4182, 4181, 1, 0, 0, 0, 4182, 4183, 1, 0, 0, 0, 4183,
		4185, 1, 0, 0, 0, 4184, 4186, 3, 734, 367, 0, 4185, 4184, 1, 0, 0, 0, 4185,
		4186, 1, 0, 0, 0, 4186, 4188, 1, 0, 0, 0, 4187, 4189, 3, 736, 368, 0, 4188,
		4187, 1, 0, 0, 0, 4188, 4189, 1, 0, 0, 0, 4189, 4191, 1, 0, 0, 0, 4190,
		4192, 3, 738, 369, 0, 4191, 4190, 1, 0, 0, 0, 4191, 4192, 1, 0, 0, 0, 4192,
		731, 1, 0, 0, 0, 4193, 4194, 3, 718, 359, 0, 4194, 733, 1, 0, 0, 0, 4195,
		4197, 5, 219, 0, 0, 4196, 4198, 5, 83, 0, 0, 4197, 4196, 1, 0, 0, 0, 4197,
		4198, 1, 0, 0, 0, 4198, 4199, 1, 0, 0, 0, 4199, 4200, 5, 71, 0, 0, 4200,
		4201, 3, 130, 65, 0, 4201, 735, 1, 0, 0, 0, 4202, 4203, 3, 314, 157, 0,
		4203, 737, 1, 0, 0, 0, 4204, 4205, 3, 740, 370, 0, 4205, 4207, 3, 742,
		371, 0, 4206, 4208, 3, 748, 374, 0, 4207, 4206, 1, 0, 0, 0, 4207, 4208,
		1, 0, 0, 0, 4208, 739, 1, 0, 0, 0, 4209, 4210, 7, 28, 0, 0, 4210, 741,
		1, 0, 0, 0, 4211, 4214, 3, 746, 373, 0, 4212, 4214, 3, 744, 372, 0, 4213,
		4211, 1, 0, 0, 0, 4213, 4212, 1, 0, 0, 0, 4214, 743, 1, 0, 0, 0, 4215,
		4216, 5, 69, 0, 0, 4216, 4217, 3, 746, 373, 0, 4217, 4218, 5, 50, 0, 0,
		4218, 4219, 3, 746, 373, 0, 4219, 745, 1, 0, 0, 0, 4220, 4221, 5, 93, 0,
		0, 4221, 4228, 5, 261, 0, 0, 4222, 4225, 3, 14, 7, 0, 4223, 4225, 5, 299,
		0, 0, 4224, 4222, 1, 0, 0, 0, 4224, 4223, 1, 0, 0, 0, 4225, 4226, 1, 0,
		0, 0, 4226, 4228, 7, 29, 0, 0, 4227, 4220, 1, 0, 0, 0, 4227, 4224, 1, 0,
		0, 0, 4228, 747, 1, 0, 0, 0, 4229, 4230, 5, 128, 0, 0, 4230, 4231, 5, 93,
		0, 0, 4231, 4240, 5, 261, 0, 0, 4232, 4233, 5, 128, 0, 0, 4233, 4240, 5,
		151, 0, 0, 4234, 4235, 5, 128, 0, 0, 4235, 4240, 5, 291, 0, 0, 4236, 4237,
		5, 128, 0, 0, 4237, 4238, 5, 199, 0, 0, 4238, 4240, 5, 215, 0, 0, 4239,
		4229, 1, 0, 0, 0, 4239, 4232, 1, 0, 0, 0, 4239, 4234, 1, 0, 0, 0, 4239,
		4236, 1, 0, 0, 0, 4240, 749, 1, 0, 0, 0, 4241, 4242, 5, 307, 0, 0, 4242,
		4243, 3, 812, 406, 0, 4243, 751, 1, 0, 0, 0, 4244, 4245, 5, 26, 0, 0, 4245,
		4246, 3, 232, 116, 0, 4246, 4247, 5, 27, 0, 0, 4247, 4250, 1, 0, 0, 0,
		4248, 4250, 3, 234, 117, 0, 4249, 4244, 1, 0, 0, 0, 4249, 4248, 1, 0, 0,
		0, 4250, 753, 1, 0, 0, 0, 4251, 4252, 3, 148, 74, 0, 4252, 4255, 5, 1,
		0, 0, 4253, 4256, 3, 14, 7, 0, 4254, 4256, 3, 752, 376, 0, 4255, 4253,
		1, 0, 0, 0, 4255, 4254, 1, 0, 0, 0, 4256, 755, 1, 0, 0, 0, 4257, 4258,
		5, 82, 0, 0, 4258, 757, 1, 0, 0, 0, 4259, 4260, 5, 259, 0, 0, 4260, 759,
		1, 0, 0, 0, 4261, 4266, 3, 642, 321, 0, 4262, 4263, 5, 26, 0, 0, 4263,
		4264, 3, 124, 62, 0, 4264, 4265, 5, 27, 0, 0, 4265, 4267, 1, 0, 0, 0, 4266,
		4262, 1, 0, 0, 0, 4266, 4267, 1, 0, 0, 0, 4267, 761, 1, 0, 0, 0, 4268,
		4273, 3, 760, 380, 0, 4269, 4270, 5, 25, 0, 0, 4270, 4272, 3, 760, 380,
		0, 4271, 4269, 1, 0, 0, 0, 4272, 4275, 1, 0, 0, 0, 4273, 4271, 1, 0, 0,
		0, 4273, 4274, 1, 0, 0, 0, 4274, 4277, 1, 0, 0, 0, 4275, 4273, 1, 0, 0,
		0, 4276, 4278, 5, 25, 0, 0, 4277, 4276, 1, 0, 0, 0, 4277, 4278, 1, 0, 0,
		0, 4278, 763, 1, 0, 0, 0, 4279, 4280, 5, 49, 0, 0, 4280, 4281, 3, 762,
		381, 0, 4281, 765, 1, 0, 0, 0, 4282, 4283, 7, 30, 0, 0, 4283, 767, 1, 0,
		0, 0, 4284, 4287, 3, 766, 383, 0, 4285, 4287, 3, 824, 412, 0, 4286, 4284,
		1, 0, 0, 0, 4286, 4285, 1, 0, 0, 0, 4287, 769, 1, 0, 0, 0, 4288, 4296,
		3, 766, 383, 0, 4289, 4296, 3, 842, 421, 0, 4290, 4296, 3, 826, 413, 0,
		4291, 4296, 3, 830, 415, 0, 4292, 4296, 3, 834, 417, 0, 4293, 4296, 3,
		836, 418, 0, 4294, 4296, 3, 838, 419, 0, 4295, 4288, 1, 0, 0, 0, 4295,
		4289, 1, 0, 0, 0, 4295, 4290, 1, 0, 0, 0, 4295, 4291, 1, 0, 0, 0, 4295,
		4292, 1, 0, 0, 0, 4295, 4293, 1, 0, 0, 0, 4295, 4294, 1, 0, 0, 0, 4296,
		771, 1, 0, 0, 0, 4297, 4304, 3, 766, 383, 0, 4298, 4304, 3, 842, 421, 0,
		4299, 4304, 3, 832, 416, 0, 4300, 4304, 3, 834, 417, 0, 4301, 4304, 3,
		836, 418, 0, 4302, 4304, 3, 838, 419, 0, 4303, 4297, 1, 0, 0, 0, 4303,
		4298, 1, 0, 0, 0, 4303, 4299, 1, 0, 0, 0, 4303, 4300, 1, 0, 0, 0, 4303,
		4301, 1, 0, 0, 0, 4303, 4302, 1, 0, 0, 0, 4304, 773, 1, 0, 0, 0, 4305,
		4311, 3, 766, 383, 0, 4306, 4311, 3, 842, 421, 0, 4307, 4311, 3, 832, 416,
		0, 4308, 4311, 3, 836, 418, 0, 4309, 4311, 3, 838, 419, 0, 4310, 4305,
		1, 0, 0, 0, 4310, 4306, 1, 0, 0, 0, 4310, 4307, 1, 0, 0, 0, 4310, 4308,
		1, 0, 0, 0, 4310, 4309, 1, 0, 0, 0, 4311, 775, 1, 0, 0, 0, 4312, 4321,
		3, 766, 383, 0, 4313, 4321, 3, 842, 421, 0, 4314, 4321, 3, 826, 413, 0,
		4315, 4321, 3, 828, 414, 0, 4316, 4321, 3, 830, 415, 0, 4317, 4321, 3,
		832, 416, 0, 4318, 4321, 3, 834, 417, 0, 4319, 4321, 3, 838, 419, 0, 4320,
		4312, 1, 0, 0, 0, 4320, 4313, 1, 0, 0, 0, 4320, 4314, 1, 0, 0, 0, 4320,
		4315, 1, 0, 0, 0, 4320, 4316, 1, 0, 0, 0, 4320, 4317, 1, 0, 0, 0, 4320,
		4318, 1, 0, 0, 0, 4320, 4319, 1, 0, 0, 0, 4321, 777, 1, 0, 0, 0, 4322,
		4330, 3, 766, 383, 0, 4323, 4330, 3, 842, 421, 0, 4324, 4330, 3, 826, 413,
		0, 4325, 4330, 3, 830, 415, 0, 4326, 4330, 3, 834, 417, 0, 4327, 4330,
		3, 836, 418, 0, 4328, 4330, 3, 838, 419, 0, 4329, 4322, 1, 0, 0, 0, 4329,
		4323, 1, 0, 0, 0, 4329, 4324, 1, 0, 0, 0, 4329, 4325, 1, 0, 0, 0, 4329,
		4326, 1, 0, 0, 0, 4329, 4327, 1, 0, 0, 0, 4329, 4328, 1, 0, 0, 0, 4330,
		779, 1, 0, 0, 0, 4331, 4339, 3, 766, 383, 0, 4332, 4339, 3, 842, 421, 0,
		4333, 4339, 3, 828, 414, 0, 4334, 4339, 3, 832, 416, 0, 4335, 4339, 3,
		834, 417, 0, 4336, 4339, 3, 836, 418, 0, 4337, 4339, 3, 838, 419, 0, 4338,
		4331, 1, 0, 0, 0, 4338, 4332, 1, 0, 0, 0, 4338, 4333, 1, 0, 0, 0, 4338,
		4334, 1, 0, 0, 0, 4338, 4335, 1, 0, 0, 0, 4338, 4336, 1, 0, 0, 0, 4338,
		4337, 1, 0, 0, 0, 4339, 781, 1, 0, 0, 0, 4340, 4349, 3, 766, 383, 0, 4341,
		4349, 3, 842, 421, 0, 4342, 4349, 3, 826, 413, 0, 4343, 4349, 3, 828, 414,
		0, 4344, 4349, 3, 830, 415, 0, 4345, 4349, 3, 832, 416, 0, 4346, 4349,
		3, 834, 417, 0, 4347, 4349, 3, 836, 418, 0, 4348, 4340, 1, 0, 0, 0, 4348,
		4341, 1, 0, 0, 0, 4348, 4342, 1, 0, 0, 0, 4348, 4343, 1, 0, 0, 0, 4348,
		4344, 1, 0, 0, 0, 4348, 4345, 1, 0, 0, 0, 4348, 4346, 1, 0, 0, 0, 4348,
		4347, 1, 0, 0, 0, 4349, 783, 1, 0, 0, 0, 4350, 4353, 3, 766, 383, 0, 4351,
		4353, 3, 840, 420, 0, 4352, 4350, 1, 0, 0, 0, 4352, 4351, 1, 0, 0, 0, 4353,
		785, 1, 0, 0, 0, 4354, 4357, 3, 768, 384, 0, 4355, 4357, 5, 322, 0, 0,
		4356, 4354, 1, 0, 0, 0, 4356, 4355, 1, 0, 0, 0, 4357, 787, 1, 0, 0, 0,
		4358, 4361, 3, 814, 407, 0, 4359, 4361, 5, 322, 0, 0, 4360, 4358, 1, 0,
		0, 0, 4360, 4359, 1, 0, 0, 0, 4361, 789, 1, 0, 0, 0, 4362, 4365, 3, 770,
		385, 0, 4363, 4365, 5, 322, 0, 0, 4364, 4362, 1, 0, 0, 0, 4364, 4363, 1,
		0, 0, 0, 4365, 791, 1, 0, 0, 0, 4366, 4369, 3, 772, 386, 0, 4367, 4369,
		5, 322, 0, 0, 4368, 4366, 1, 0, 0, 0, 4368, 4367, 1, 0, 0, 0, 4369, 793,
		1, 0, 0, 0, 4370, 4373, 3, 774, 387, 0, 4371, 4373, 5, 322, 0, 0, 4372,
		4370, 1, 0, 0, 0, 4372, 4371, 1, 0, 0, 0, 4373, 795, 1, 0, 0, 0, 4374,
		4377, 3, 776, 388, 0, 4375, 4377, 5, 322, 0, 0, 4376, 4374, 1, 0, 0, 0,
		4376, 4375, 1, 0, 0, 0, 4377, 797, 1, 0, 0, 0, 4378, 4381, 3, 778, 389,
		0, 4379, 4381, 5, 322, 0, 0, 4380, 4378, 1, 0, 0, 0, 4380, 4379, 1, 0,
		0, 0, 4381, 799, 1, 0, 0, 0, 4382, 4385, 3, 780, 390, 0, 4383, 4385, 5,
		322, 0, 0, 4384, 4382, 1, 0, 0, 0, 4384, 4383, 1, 0, 0, 0, 4385, 801, 1,
		0, 0, 0, 4386, 4389, 3, 782, 391, 0, 4387, 4389, 5, 322, 0, 0, 4388, 4386,
		1, 0, 0, 0, 4388, 4387, 1, 0, 0, 0, 4389, 803, 1, 0, 0, 0, 4390, 4393,
		3, 766, 383, 0, 4391, 4393, 5, 322, 0, 0, 4392, 4390, 1, 0, 0, 0, 4392,
		4391, 1, 0, 0, 0, 4393, 805, 1, 0, 0, 0, 4394, 4397, 3, 784, 392, 0, 4395,
		4397, 5, 322, 0, 0, 4396, 4394, 1, 0, 0, 0, 4396, 4395, 1, 0, 0, 0, 4397,
		807, 1, 0, 0, 0, 4398, 4402, 3, 786, 393, 0, 4399, 4400, 5, 231, 0, 0,
		4400, 4402, 5, 180, 0, 0, 4401, 4398, 1, 0, 0, 0, 4401, 4399, 1, 0, 0,
		0, 4402, 809, 1, 0, 0, 0, 4403, 4404, 3, 786, 393, 0, 4404, 4405, 5, 24,
		0, 0, 4405, 4407, 1, 0, 0, 0, 4406, 4403, 1, 0, 0, 0, 4406, 4407, 1, 0,
		0, 0, 4407, 811, 1, 0, 0, 0, 4408, 4409, 3, 786, 393, 0, 4409, 4410, 5,
		29, 0, 0, 4410, 4412, 1, 0, 0, 0, 4411, 4408, 1, 0, 0, 0, 4411, 4412, 1,
		0, 0, 0, 4412, 4415, 1, 0, 0, 0, 4413, 4416, 3, 116, 58, 0, 4414, 4416,
		5, 19, 0, 0, 4415, 4413, 1, 0, 0, 0, 4415, 4414, 1, 0, 0, 0, 4416, 813,
		1, 0, 0, 0, 4417, 4420, 3, 768, 384, 0, 4418, 4420, 3, 844, 422, 0, 4419,
		4417, 1, 0, 0, 0, 4419, 4418, 1, 0, 0, 0, 4420, 815, 1, 0, 0, 0, 4421,
		4422, 3, 788, 394, 0, 4422, 4423, 5, 24, 0, 0, 4423, 4425, 1, 0, 0, 0,
		4424, 4421, 1, 0, 0, 0, 4424, 4425, 1, 0, 0, 0, 4425, 817, 1, 0, 0, 0,
		4426, 4428, 5, 30, 0, 0, 4427, 4426, 1, 0, 0, 0, 4427, 4428, 1, 0, 0, 0,
		4428, 4429, 1, 0, 0, 0, 4429, 4430, 3, 788, 394, 0, 4430, 819, 1, 0, 0,
		0, 4431, 4434, 3, 798, 399, 0, 4432, 4434, 3, 844, 422, 0, 4433, 4431,
		1, 0, 0, 0, 4433, 4432, 1, 0, 0, 0, 4434, 821, 1, 0, 0, 0, 4435, 4437,
		5, 30, 0, 0, 4436, 4435, 1, 0, 0, 0, 4436, 4437, 1, 0, 0, 0, 4437, 4438,
		1, 0, 0, 0, 4438, 4439, 3, 820, 410, 0, 4439, 823, 1, 0, 0, 0, 4440, 4449,
		3, 842, 421, 0, 4441, 4449, 3, 826, 413, 0, 4442, 4449, 3, 828, 414, 0,
		4443, 4449, 3, 830, 415, 0, 4444, 4449, 3, 832, 416, 0, 4445, 4449, 3,
		834, 417, 0, 4446, 4449, 3, 836, 418, 0, 4447, 4449, 3, 838, 419, 0, 4448,
		4440, 1, 0, 0, 0, 4448, 4441, 1, 0, 0, 0, 4448, 4442, 1, 0, 0, 0, 4448,
		4443, 1, 0, 0, 0, 4448, 4444, 1, 0, 0, 0, 4448, 4445, 1, 0, 0, 0, 4448,
		4446, 1, 0, 0, 0, 4448, 4447, 1, 0, 0, 0, 4449, 825, 1, 0, 0, 0, 4450,
		4451, 7, 31, 0, 0, 4451, 827, 1, 0, 0, 0, 4452, 4453, 7, 32, 0, 0, 4453,
		829, 1, 0, 0, 0, 4454, 4455, 7, 33, 0, 0, 4455, 831, 1, 0, 0, 0, 4456,
		4457, 5, 80, 0, 0, 4457, 833, 1, 0, 0, 0, 4458, 4459, 5, 83, 0, 0, 4459,
		835, 1, 0, 0, 0, 4460, 4461, 7, 28, 0, 0, 4461, 837, 1, 0, 0, 0, 4462,
		4463, 7, 27, 0, 0, 4463, 839, 1, 0, 0, 0, 4464, 4465, 7, 34, 0, 0, 4465,
		841, 1, 0, 0, 0, 4466, 4467, 7, 35, 0, 0, 4467, 843, 1, 0, 0, 0, 4468,
		4469, 7, 36, 0, 0, 4469, 845, 1, 0, 0, 0, 4470, 4471, 7, 37, 0, 0, 4471,
		847, 1, 0, 0, 0, 4472, 4473, 5, 327, 0, 0, 4473, 849, 1, 0, 0, 0, 4474,
		4475, 7, 38, 0, 0, 4475, 851, 1, 0, 0, 0, 491, 857, 862, 869, 874, 880,
		888, 896, 903, 907, 915, 920, 929, 931, 991, 998, 1002, 1009, 1017, 1022,
		1026, 1032, 1038, 1041, 1045, 1053, 1057, 1060, 1064, 1075, 1080, 1082,
		1091, 1112, 1117, 1126, 1128, 1135, 1143, 1151, 1158, 1168, 1170, 1174,
		1179, 1183, 1189, 1195, 1199, 1203, 1206, 1213, 1219, 1223, 1228, 1231,
		1245, 1250, 1253, 1267, 1274, 1285, 1296, 1316, 1322, 1327, 1331, 1345,
		1347, 1354, 1360, 1371, 1379, 1385, 1392, 1400, 1413, 1419, 1423, 1426,
		1428, 1436, 1444, 1450, 1456, 1462, 1465, 1474, 1483, 1490, 1498, 1511,
		1518, 1522, 1529, 1533, 1538, 1545, 1552, 1555, 1562, 1566, 1576, 1599,
		1605, 1609, 1616, 1622, 1629, 1633, 1637, 1643, 1648, 1657, 1660, 1666,
		1671, 1679, 1686, 1708, 1712, 1714, 1718, 1727, 1731, 1733, 1737, 1746,
		1750, 1788, 1792, 1812, 1815, 1821, 1841, 1846, 1852, 1857, 1860, 1864,
		1891, 1899, 1902, 1909, 1922, 1926, 1938, 1951, 1956, 1963, 1967, 1974,
		1983, 1992, 2000, 2004, 2008, 2015, 2017, 2020, 2025, 2030, 2034, 2041,
		2048, 2052, 2056, 2060, 2064, 2066, 2077, 2086, 2091, 2097, 2102, 2106,
		2110, 2114, 2117, 2121, 2125, 2133, 2137, 2141, 2145, 2149, 2152, 2156,
		2159, 2162, 2167, 2170, 2173, 2176, 2190, 2192, 2203, 2213, 2223, 2226,
		2233, 2257, 2268, 2274, 2278, 2282, 2286, 2290, 2294, 2298, 2302, 2308,
		2315, 2325, 2336, 2349, 2365, 2375, 2395, 2401, 2408, 2415, 2423, 2432,
		2469, 2471, 2474, 2479, 2483, 2487, 2493, 2499, 2503, 2508, 2513, 2515,
		2519, 2524, 2527, 2529, 2533, 2544, 2555, 2566, 2570, 2574, 2578, 2581,
		2585, 2588, 2594, 2603, 2606, 2620, 2626, 2629, 2634, 2641, 2648, 2657,
		2662, 2670, 2685, 2691, 2699, 2707, 2724, 2731, 2739, 2760, 2768, 2777,
		2787, 2796, 2801, 2808, 2818, 2823, 2832, 2836, 2840, 2843, 2846, 2849,
		2852, 2860, 2869, 2875, 2882, 2891, 2899, 2904, 2911, 2924, 2935, 2945,
		2951, 2960, 2977, 3000, 3020, 3031, 3039, 3049, 3054, 3058, 3064, 3102,
		3114, 3156, 3164, 3167, 3171, 3175, 3185, 3198, 3211, 3216, 3228, 3239,
		3244, 3247, 3251, 3255, 3259, 3262, 3275, 3279, 3291, 3305, 3320, 3335,
		3338, 3350, 3353, 3369, 3375, 3383, 3391, 3398, 3402, 3410, 3416, 3422,
		3434, 3438, 3440, 3452, 3456, 3461, 3467, 3474, 3478, 3482, 3485, 3498,
		3507, 3511, 3516, 3522, 3531, 3540, 3557, 3561, 3565, 3567, 3571, 3578,
		3582, 3586, 3588, 3605, 3610, 3634, 3639, 3657, 3674, 3690, 3705, 3712,
		3720, 3731, 3738, 3743, 3749, 3752, 3755, 3762, 3765, 3768, 3777, 3782,
		3785, 3795, 3799, 3801, 3808, 3811, 3815, 3817, 3820, 3825, 3828, 3833,
		3843, 3848, 3859, 3863, 3867, 3869, 3873, 3878, 3886, 3889, 3892, 3895,
		3900, 3906, 3909, 3913, 3919, 3928, 3931, 3939, 3943, 3946, 3950, 3957,
		3978, 3988, 3992, 3995, 4003, 4019, 4027, 4035, 4043, 4052, 4070, 4087,
		4096, 4105, 4124, 4136, 4146, 4156, 4168, 4182, 4185, 4188, 4191, 4197,
		4207, 4213, 4224, 4227, 4239, 4249, 4255, 4266, 4273, 4277, 4286, 4295,
		4303, 4310, 4320, 4329, 4338, 4348, 4352, 4356, 4360, 4364, 4368, 4372,
		4376, 4380, 4384, 4388, 4392, 4396, 4401, 4406, 4411, 4415, 4419, 4424,
		4427, 4433, 4436, 4448,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// SQLv1Antlr4ParserInit initializes any static state used to implement SQLv1Antlr4Parser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewSQLv1Antlr4Parser(). You can call this function if you wish to initialize the static state ahead
// of time.
func SQLv1Antlr4ParserInit() {
	staticData := &SQLv1Antlr4ParserStaticData
	staticData.once.Do(sqlv1antlr4ParserInit)
}

// NewSQLv1Antlr4Parser produces a new parser instance for the optional input antlr.TokenStream.
func NewSQLv1Antlr4Parser(input antlr.TokenStream) *SQLv1Antlr4Parser {
	SQLv1Antlr4ParserInit()
	this := new(SQLv1Antlr4Parser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &SQLv1Antlr4ParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "SQLv1Antlr4.g4"

	return this
}

// SQLv1Antlr4Parser tokens.
const (
	SQLv1Antlr4ParserEOF               = antlr.TokenEOF
	SQLv1Antlr4ParserEQUALS            = 1
	SQLv1Antlr4ParserEQUALS2           = 2
	SQLv1Antlr4ParserNOT_EQUALS        = 3
	SQLv1Antlr4ParserNOT_EQUALS2       = 4
	SQLv1Antlr4ParserLESS              = 5
	SQLv1Antlr4ParserLESS_OR_EQ        = 6
	SQLv1Antlr4ParserGREATER           = 7
	SQLv1Antlr4ParserGREATER_OR_EQ     = 8
	SQLv1Antlr4ParserSHIFT_LEFT        = 9
	SQLv1Antlr4ParserROT_LEFT          = 10
	SQLv1Antlr4ParserAMPERSAND         = 11
	SQLv1Antlr4ParserPIPE              = 12
	SQLv1Antlr4ParserDOUBLE_PIPE       = 13
	SQLv1Antlr4ParserSTRUCT_OPEN       = 14
	SQLv1Antlr4ParserSTRUCT_CLOSE      = 15
	SQLv1Antlr4ParserPLUS              = 16
	SQLv1Antlr4ParserMINUS             = 17
	SQLv1Antlr4ParserTILDA             = 18
	SQLv1Antlr4ParserASTERISK          = 19
	SQLv1Antlr4ParserSLASH             = 20
	SQLv1Antlr4ParserBACKSLASH         = 21
	SQLv1Antlr4ParserPERCENT           = 22
	SQLv1Antlr4ParserSEMICOLON         = 23
	SQLv1Antlr4ParserDOT               = 24
	SQLv1Antlr4ParserCOMMA             = 25
	SQLv1Antlr4ParserLPAREN            = 26
	SQLv1Antlr4ParserRPAREN            = 27
	SQLv1Antlr4ParserQUESTION          = 28
	SQLv1Antlr4ParserCOLON             = 29
	SQLv1Antlr4ParserCOMMAT            = 30
	SQLv1Antlr4ParserDOUBLE_COMMAT     = 31
	SQLv1Antlr4ParserDOLLAR            = 32
	SQLv1Antlr4ParserQUOTE_DOUBLE      = 33
	SQLv1Antlr4ParserQUOTE_SINGLE      = 34
	SQLv1Antlr4ParserBACKTICK          = 35
	SQLv1Antlr4ParserLBRACE_CURLY      = 36
	SQLv1Antlr4ParserRBRACE_CURLY      = 37
	SQLv1Antlr4ParserCARET             = 38
	SQLv1Antlr4ParserNAMESPACE         = 39
	SQLv1Antlr4ParserARROW             = 40
	SQLv1Antlr4ParserRBRACE_SQUARE     = 41
	SQLv1Antlr4ParserLBRACE_SQUARE     = 42
	SQLv1Antlr4ParserABORT             = 43
	SQLv1Antlr4ParserACTION            = 44
	SQLv1Antlr4ParserADD               = 45
	SQLv1Antlr4ParserAFTER             = 46
	SQLv1Antlr4ParserALL               = 47
	SQLv1Antlr4ParserALTER             = 48
	SQLv1Antlr4ParserANALYZE           = 49
	SQLv1Antlr4ParserAND               = 50
	SQLv1Antlr4ParserANSI              = 51
	SQLv1Antlr4ParserANY               = 52
	SQLv1Antlr4ParserARRAY             = 53
	SQLv1Antlr4ParserAS                = 54
	SQLv1Antlr4ParserASC               = 55
	SQLv1Antlr4ParserASSUME            = 56
	SQLv1Antlr4ParserASYMMETRIC        = 57
	SQLv1Antlr4ParserASYNC             = 58
	SQLv1Antlr4ParserAT                = 59
	SQLv1Antlr4ParserATTACH            = 60
	SQLv1Antlr4ParserATTRIBUTES        = 61
	SQLv1Antlr4ParserAUTOINCREMENT     = 62
	SQLv1Antlr4ParserAUTOMAP           = 63
	SQLv1Antlr4ParserBACKUP            = 64
	SQLv1Antlr4ParserCOLLECTION        = 65
	SQLv1Antlr4ParserBEFORE            = 66
	SQLv1Antlr4ParserBEGIN             = 67
	SQLv1Antlr4ParserBERNOULLI         = 68
	SQLv1Antlr4ParserBETWEEN           = 69
	SQLv1Antlr4ParserBITCAST           = 70
	SQLv1Antlr4ParserBY                = 71
	SQLv1Antlr4ParserCALLABLE          = 72
	SQLv1Antlr4ParserCASCADE           = 73
	SQLv1Antlr4ParserCASE              = 74
	SQLv1Antlr4ParserCAST              = 75
	SQLv1Antlr4ParserCHANGEFEED        = 76
	SQLv1Antlr4ParserCHECK             = 77
	SQLv1Antlr4ParserCLASSIFIER        = 78
	SQLv1Antlr4ParserCOLLATE           = 79
	SQLv1Antlr4ParserCOLUMN            = 80
	SQLv1Antlr4ParserCOLUMNS           = 81
	SQLv1Antlr4ParserCOMMIT            = 82
	SQLv1Antlr4ParserCOMPACT           = 83
	SQLv1Antlr4ParserCONDITIONAL       = 84
	SQLv1Antlr4ParserCONFLICT          = 85
	SQLv1Antlr4ParserCONNECT           = 86
	SQLv1Antlr4ParserCONSTRAINT        = 87
	SQLv1Antlr4ParserCONSUMER          = 88
	SQLv1Antlr4ParserCOVER             = 89
	SQLv1Antlr4ParserCREATE            = 90
	SQLv1Antlr4ParserCROSS             = 91
	SQLv1Antlr4ParserCUBE              = 92
	SQLv1Antlr4ParserCURRENT           = 93
	SQLv1Antlr4ParserCURRENT_DATE      = 94
	SQLv1Antlr4ParserCURRENT_TIME      = 95
	SQLv1Antlr4ParserCURRENT_TIMESTAMP = 96
	SQLv1Antlr4ParserDATA              = 97
	SQLv1Antlr4ParserDATABASE          = 98
	SQLv1Antlr4ParserDECIMAL           = 99
	SQLv1Antlr4ParserDECLARE           = 100
	SQLv1Antlr4ParserDEFAULT           = 101
	SQLv1Antlr4ParserDEFERRABLE        = 102
	SQLv1Antlr4ParserDEFERRED          = 103
	SQLv1Antlr4ParserDEFINE            = 104
	SQLv1Antlr4ParserDELETE            = 105
	SQLv1Antlr4ParserDESC              = 106
	SQLv1Antlr4ParserDESCRIBE          = 107
	SQLv1Antlr4ParserDETACH            = 108
	SQLv1Antlr4ParserDICT              = 109
	SQLv1Antlr4ParserDIRECTORY         = 110
	SQLv1Antlr4ParserDISABLE           = 111
	SQLv1Antlr4ParserDISCARD           = 112
	SQLv1Antlr4ParserDISTINCT          = 113
	SQLv1Antlr4ParserDO                = 114
	SQLv1Antlr4ParserDROP              = 115
	SQLv1Antlr4ParserEACH              = 116
	SQLv1Antlr4ParserELSE              = 117
	SQLv1Antlr4ParserEMPTY             = 118
	SQLv1Antlr4ParserEMPTY_ACTION      = 119
	SQLv1Antlr4ParserENCRYPTED         = 120
	SQLv1Antlr4ParserEND               = 121
	SQLv1Antlr4ParserENUM              = 122
	SQLv1Antlr4ParserERASE             = 123
	SQLv1Antlr4ParserERROR             = 124
	SQLv1Antlr4ParserESCAPE            = 125
	SQLv1Antlr4ParserEVALUATE          = 126
	SQLv1Antlr4ParserEXCEPT            = 127
	SQLv1Antlr4ParserEXCLUDE           = 128
	SQLv1Antlr4ParserEXCLUSION         = 129
	SQLv1Antlr4ParserEXCLUSIVE         = 130
	SQLv1Antlr4ParserEXISTS            = 131
	SQLv1Antlr4ParserEXPLAIN           = 132
	SQLv1Antlr4ParserEXPORT            = 133
	SQLv1Antlr4ParserEXTERNAL          = 134
	SQLv1Antlr4ParserFAIL              = 135
	SQLv1Antlr4ParserFALSE             = 136
	SQLv1Antlr4ParserFAMILY            = 137
	SQLv1Antlr4ParserFILTER            = 138
	SQLv1Antlr4ParserFIRST             = 139
	SQLv1Antlr4ParserFLATTEN           = 140
	SQLv1Antlr4ParserFLOW              = 141
	SQLv1Antlr4ParserFOLLOWING         = 142
	SQLv1Antlr4ParserFOR               = 143
	SQLv1Antlr4ParserFOREIGN           = 144
	SQLv1Antlr4ParserFROM              = 145
	SQLv1Antlr4ParserFULL              = 146
	SQLv1Antlr4ParserFUNCTION          = 147
	SQLv1Antlr4ParserGLOB              = 148
	SQLv1Antlr4ParserGLOBAL            = 149
	SQLv1Antlr4ParserGRANT             = 150
	SQLv1Antlr4ParserGROUP             = 151
	SQLv1Antlr4ParserGROUPING          = 152
	SQLv1Antlr4ParserGROUPS            = 153
	SQLv1Antlr4ParserHASH              = 154
	SQLv1Antlr4ParserHAVING            = 155
	SQLv1Antlr4ParserHOP               = 156
	SQLv1Antlr4ParserIF                = 157
	SQLv1Antlr4ParserIGNORE            = 158
	SQLv1Antlr4ParserILIKE             = 159
	SQLv1Antlr4ParserIMMEDIATE         = 160
	SQLv1Antlr4ParserIMPORT            = 161
	SQLv1Antlr4ParserIN                = 162
	SQLv1Antlr4ParserINCREMENTAL       = 163
	SQLv1Antlr4ParserINDEX             = 164
	SQLv1Antlr4ParserINDEXED           = 165
	SQLv1Antlr4ParserINHERITS          = 166
	SQLv1Antlr4ParserINITIAL           = 167
	SQLv1Antlr4ParserINITIALLY         = 168
	SQLv1Antlr4ParserINNER             = 169
	SQLv1Antlr4ParserINSERT            = 170
	SQLv1Antlr4ParserINSTEAD           = 171
	SQLv1Antlr4ParserINTERSECT         = 172
	SQLv1Antlr4ParserINTO              = 173
	SQLv1Antlr4ParserIS                = 174
	SQLv1Antlr4ParserISNULL            = 175
	SQLv1Antlr4ParserJOIN              = 176
	SQLv1Antlr4ParserJSON_EXISTS       = 177
	SQLv1Antlr4ParserJSON_QUERY        = 178
	SQLv1Antlr4ParserJSON_VALUE        = 179
	SQLv1Antlr4ParserKEY               = 180
	SQLv1Antlr4ParserLAST              = 181
	SQLv1Antlr4ParserLEFT              = 182
	SQLv1Antlr4ParserLEGACY            = 183
	SQLv1Antlr4ParserLIKE              = 184
	SQLv1Antlr4ParserLIMIT             = 185
	SQLv1Antlr4ParserLIST              = 186
	SQLv1Antlr4ParserLOCAL             = 187
	SQLv1Antlr4ParserMANAGE            = 188
	SQLv1Antlr4ParserMATCH             = 189
	SQLv1Antlr4ParserMATCHES           = 190
	SQLv1Antlr4ParserMATCH_RECOGNIZE   = 191
	SQLv1Antlr4ParserMEASURES          = 192
	SQLv1Antlr4ParserMICROSECONDS      = 193
	SQLv1Antlr4ParserMILLISECONDS      = 194
	SQLv1Antlr4ParserMODIFY            = 195
	SQLv1Antlr4ParserNANOSECONDS       = 196
	SQLv1Antlr4ParserNATURAL           = 197
	SQLv1Antlr4ParserNEXT              = 198
	SQLv1Antlr4ParserNO                = 199
	SQLv1Antlr4ParserNOT               = 200
	SQLv1Antlr4ParserNOTNULL           = 201
	SQLv1Antlr4ParserNULL              = 202
	SQLv1Antlr4ParserNULLS             = 203
	SQLv1Antlr4ParserOBJECT            = 204
	SQLv1Antlr4ParserOF                = 205
	SQLv1Antlr4ParserOFFSET            = 206
	SQLv1Antlr4ParserOMIT              = 207
	SQLv1Antlr4ParserON                = 208
	SQLv1Antlr4ParserONE               = 209
	SQLv1Antlr4ParserONLY              = 210
	SQLv1Antlr4ParserOPTION            = 211
	SQLv1Antlr4ParserOPTIONAL          = 212
	SQLv1Antlr4ParserOR                = 213
	SQLv1Antlr4ParserORDER             = 214
	SQLv1Antlr4ParserOTHERS            = 215
	SQLv1Antlr4ParserOUTER             = 216
	SQLv1Antlr4ParserOVER              = 217
	SQLv1Antlr4ParserPARALLEL          = 218
	SQLv1Antlr4ParserPARTITION         = 219
	SQLv1Antlr4ParserPASSING           = 220
	SQLv1Antlr4ParserPASSWORD          = 221
	SQLv1Antlr4ParserPAST              = 222
	SQLv1Antlr4ParserPATTERN           = 223
	SQLv1Antlr4ParserPER               = 224
	SQLv1Antlr4ParserPERMUTE           = 225
	SQLv1Antlr4ParserPLAN              = 226
	SQLv1Antlr4ParserPOOL              = 227
	SQLv1Antlr4ParserPRAGMA            = 228
	SQLv1Antlr4ParserPRECEDING         = 229
	SQLv1Antlr4ParserPRESORT           = 230
	SQLv1Antlr4ParserPRIMARY           = 231
	SQLv1Antlr4ParserPRIVILEGES        = 232
	SQLv1Antlr4ParserPROCESS           = 233
	SQLv1Antlr4ParserQUEUE             = 234
	SQLv1Antlr4ParserRAISE             = 235
	SQLv1Antlr4ParserRANGE             = 236
	SQLv1Antlr4ParserREDUCE            = 237
	SQLv1Antlr4ParserREFERENCES        = 238
	SQLv1Antlr4ParserREGEXP            = 239
	SQLv1Antlr4ParserREINDEX           = 240
	SQLv1Antlr4ParserRELEASE           = 241
	SQLv1Antlr4ParserREMOVE            = 242
	SQLv1Antlr4ParserRENAME            = 243
	SQLv1Antlr4ParserREPEATABLE        = 244
	SQLv1Antlr4ParserREPLACE           = 245
	SQLv1Antlr4ParserREPLICATION       = 246
	SQLv1Antlr4ParserRESET             = 247
	SQLv1Antlr4ParserRESOURCE          = 248
	SQLv1Antlr4ParserRESPECT           = 249
	SQLv1Antlr4ParserRESTORE           = 250
	SQLv1Antlr4ParserRESTRICT          = 251
	SQLv1Antlr4ParserRESULT            = 252
	SQLv1Antlr4ParserRETURN            = 253
	SQLv1Antlr4ParserRETURNING         = 254
	SQLv1Antlr4ParserREVERT            = 255
	SQLv1Antlr4ParserREVOKE            = 256
	SQLv1Antlr4ParserRIGHT             = 257
	SQLv1Antlr4ParserRLIKE             = 258
	SQLv1Antlr4ParserROLLBACK          = 259
	SQLv1Antlr4ParserROLLUP            = 260
	SQLv1Antlr4ParserROW               = 261
	SQLv1Antlr4ParserROWS              = 262
	SQLv1Antlr4ParserSAMPLE            = 263
	SQLv1Antlr4ParserSAVEPOINT         = 264
	SQLv1Antlr4ParserSCHEMA            = 265
	SQLv1Antlr4ParserSECONDS           = 266
	SQLv1Antlr4ParserSEEK              = 267
	SQLv1Antlr4ParserSELECT            = 268
	SQLv1Antlr4ParserSEMI              = 269
	SQLv1Antlr4ParserSET               = 270
	SQLv1Antlr4ParserSETS              = 271
	SQLv1Antlr4ParserSHOW              = 272
	SQLv1Antlr4ParserTSKIP             = 273
	SQLv1Antlr4ParserSOURCE            = 274
	SQLv1Antlr4ParserSTREAM            = 275
	SQLv1Antlr4ParserSTRUCT            = 276
	SQLv1Antlr4ParserSUBQUERY          = 277
	SQLv1Antlr4ParserSUBSET            = 278
	SQLv1Antlr4ParserSYMBOLS           = 279
	SQLv1Antlr4ParserSYMMETRIC         = 280
	SQLv1Antlr4ParserSYNC              = 281
	SQLv1Antlr4ParserSYSTEM            = 282
	SQLv1Antlr4ParserTABLE             = 283
	SQLv1Antlr4ParserTABLES            = 284
	SQLv1Antlr4ParserTABLESAMPLE       = 285
	SQLv1Antlr4ParserTABLESTORE        = 286
	SQLv1Antlr4ParserTAGGED            = 287
	SQLv1Antlr4ParserTEMP              = 288
	SQLv1Antlr4ParserTEMPORARY         = 289
	SQLv1Antlr4ParserTHEN              = 290
	SQLv1Antlr4ParserTIES              = 291
	SQLv1Antlr4ParserTO                = 292
	SQLv1Antlr4ParserTOPIC             = 293
	SQLv1Antlr4ParserTRANSACTION       = 294
	SQLv1Antlr4ParserTRIGGER           = 295
	SQLv1Antlr4ParserTRUE              = 296
	SQLv1Antlr4ParserTUPLE             = 297
	SQLv1Antlr4ParserTYPE              = 298
	SQLv1Antlr4ParserUNBOUNDED         = 299
	SQLv1Antlr4ParserUNCONDITIONAL     = 300
	SQLv1Antlr4ParserUNION             = 301
	SQLv1Antlr4ParserUNIQUE            = 302
	SQLv1Antlr4ParserUNKNOWN           = 303
	SQLv1Antlr4ParserUNMATCHED         = 304
	SQLv1Antlr4ParserUPDATE            = 305
	SQLv1Antlr4ParserUPSERT            = 306
	SQLv1Antlr4ParserUSE               = 307
	SQLv1Antlr4ParserUSER              = 308
	SQLv1Antlr4ParserUSING             = 309
	SQLv1Antlr4ParserVACUUM            = 310
	SQLv1Antlr4ParserVALUES            = 311
	SQLv1Antlr4ParserVARIANT           = 312
	SQLv1Antlr4ParserVIEW              = 313
	SQLv1Antlr4ParserVIRTUAL           = 314
	SQLv1Antlr4ParserWHEN              = 315
	SQLv1Antlr4ParserWHERE             = 316
	SQLv1Antlr4ParserWINDOW            = 317
	SQLv1Antlr4ParserWITH              = 318
	SQLv1Antlr4ParserWITHOUT           = 319
	SQLv1Antlr4ParserWRAPPER           = 320
	SQLv1Antlr4ParserXOR               = 321
	SQLv1Antlr4ParserSTRING_VALUE      = 322
	SQLv1Antlr4ParserID_PLAIN          = 323
	SQLv1Antlr4ParserID_QUOTED         = 324
	SQLv1Antlr4ParserDIGITS            = 325
	SQLv1Antlr4ParserINTEGER_VALUE     = 326
	SQLv1Antlr4ParserREAL              = 327
	SQLv1Antlr4ParserBLOB              = 328
	SQLv1Antlr4ParserTQ                = 329
	SQLv1Antlr4ParserTU                = 330
	SQLv1Antlr4ParserTE                = 331
	SQLv1Antlr4ParserTR                = 332
	SQLv1Antlr4ParserTY                = 333
	SQLv1Antlr4ParserWS                = 334
	SQLv1Antlr4ParserCOMMENT           = 335
)

// SQLv1Antlr4Parser rules.
const (
	SQLv1Antlr4ParserRULE_sql_query                               = 0
	SQLv1Antlr4ParserRULE_sql_stmt_list                           = 1
	SQLv1Antlr4ParserRULE_ansi_sql_stmt_list                      = 2
	SQLv1Antlr4ParserRULE_lambda_body                             = 3
	SQLv1Antlr4ParserRULE_lambda_stmt                             = 4
	SQLv1Antlr4ParserRULE_sql_stmt                                = 5
	SQLv1Antlr4ParserRULE_sql_stmt_core                           = 6
	SQLv1Antlr4ParserRULE_expr                                    = 7
	SQLv1Antlr4ParserRULE_or_subexpr                              = 8
	SQLv1Antlr4ParserRULE_and_subexpr                             = 9
	SQLv1Antlr4ParserRULE_xor_subexpr                             = 10
	SQLv1Antlr4ParserRULE_distinct_from_op                        = 11
	SQLv1Antlr4ParserRULE_cond_expr                               = 12
	SQLv1Antlr4ParserRULE_match_op                                = 13
	SQLv1Antlr4ParserRULE_eq_subexpr                              = 14
	SQLv1Antlr4ParserRULE_shift_right                             = 15
	SQLv1Antlr4ParserRULE_rot_right                               = 16
	SQLv1Antlr4ParserRULE_double_question                         = 17
	SQLv1Antlr4ParserRULE_neq_subexpr                             = 18
	SQLv1Antlr4ParserRULE_bit_subexpr                             = 19
	SQLv1Antlr4ParserRULE_add_subexpr                             = 20
	SQLv1Antlr4ParserRULE_mul_subexpr                             = 21
	SQLv1Antlr4ParserRULE_con_subexpr                             = 22
	SQLv1Antlr4ParserRULE_unary_op                                = 23
	SQLv1Antlr4ParserRULE_unary_subexpr_suffix                    = 24
	SQLv1Antlr4ParserRULE_unary_casual_subexpr                    = 25
	SQLv1Antlr4ParserRULE_in_unary_casual_subexpr                 = 26
	SQLv1Antlr4ParserRULE_unary_subexpr                           = 27
	SQLv1Antlr4ParserRULE_in_unary_subexpr                        = 28
	SQLv1Antlr4ParserRULE_list_literal                            = 29
	SQLv1Antlr4ParserRULE_expr_dict_list                          = 30
	SQLv1Antlr4ParserRULE_dict_literal                            = 31
	SQLv1Antlr4ParserRULE_expr_struct_list                        = 32
	SQLv1Antlr4ParserRULE_struct_literal                          = 33
	SQLv1Antlr4ParserRULE_atom_expr                               = 34
	SQLv1Antlr4ParserRULE_in_atom_expr                            = 35
	SQLv1Antlr4ParserRULE_cast_expr                               = 36
	SQLv1Antlr4ParserRULE_bitcast_expr                            = 37
	SQLv1Antlr4ParserRULE_exists_expr                             = 38
	SQLv1Antlr4ParserRULE_case_expr                               = 39
	SQLv1Antlr4ParserRULE_lambda                                  = 40
	SQLv1Antlr4ParserRULE_in_expr                                 = 41
	SQLv1Antlr4ParserRULE_json_api_expr                           = 42
	SQLv1Antlr4ParserRULE_jsonpath_spec                           = 43
	SQLv1Antlr4ParserRULE_json_variable_name                      = 44
	SQLv1Antlr4ParserRULE_json_variable                           = 45
	SQLv1Antlr4ParserRULE_json_variables                          = 46
	SQLv1Antlr4ParserRULE_json_common_args                        = 47
	SQLv1Antlr4ParserRULE_json_case_handler                       = 48
	SQLv1Antlr4ParserRULE_json_value                              = 49
	SQLv1Antlr4ParserRULE_json_exists_handler                     = 50
	SQLv1Antlr4ParserRULE_json_exists                             = 51
	SQLv1Antlr4ParserRULE_json_query_wrapper                      = 52
	SQLv1Antlr4ParserRULE_json_query_handler                      = 53
	SQLv1Antlr4ParserRULE_json_query                              = 54
	SQLv1Antlr4ParserRULE_smart_parenthesis                       = 55
	SQLv1Antlr4ParserRULE_expr_list                               = 56
	SQLv1Antlr4ParserRULE_pure_column_list                        = 57
	SQLv1Antlr4ParserRULE_pure_column_or_named                    = 58
	SQLv1Antlr4ParserRULE_pure_column_or_named_list               = 59
	SQLv1Antlr4ParserRULE_column_name                             = 60
	SQLv1Antlr4ParserRULE_without_column_name                     = 61
	SQLv1Antlr4ParserRULE_column_list                             = 62
	SQLv1Antlr4ParserRULE_without_column_list                     = 63
	SQLv1Antlr4ParserRULE_named_expr                              = 64
	SQLv1Antlr4ParserRULE_named_expr_list                         = 65
	SQLv1Antlr4ParserRULE_invoke_expr                             = 66
	SQLv1Antlr4ParserRULE_invoke_expr_tail                        = 67
	SQLv1Antlr4ParserRULE_using_call_expr                         = 68
	SQLv1Antlr4ParserRULE_key_expr                                = 69
	SQLv1Antlr4ParserRULE_when_expr                               = 70
	SQLv1Antlr4ParserRULE_literal_value                           = 71
	SQLv1Antlr4ParserRULE_bind_parameter                          = 72
	SQLv1Antlr4ParserRULE_opt_bind_parameter                      = 73
	SQLv1Antlr4ParserRULE_bind_parameter_list                     = 74
	SQLv1Antlr4ParserRULE_named_bind_parameter                    = 75
	SQLv1Antlr4ParserRULE_named_bind_parameter_list               = 76
	SQLv1Antlr4ParserRULE_signed_number                           = 77
	SQLv1Antlr4ParserRULE_type_name_simple                        = 78
	SQLv1Antlr4ParserRULE_integer_or_bind                         = 79
	SQLv1Antlr4ParserRULE_type_name_tag                           = 80
	SQLv1Antlr4ParserRULE_struct_arg                              = 81
	SQLv1Antlr4ParserRULE_struct_arg_positional                   = 82
	SQLv1Antlr4ParserRULE_variant_arg                             = 83
	SQLv1Antlr4ParserRULE_callable_arg                            = 84
	SQLv1Antlr4ParserRULE_callable_arg_list                       = 85
	SQLv1Antlr4ParserRULE_type_name_decimal                       = 86
	SQLv1Antlr4ParserRULE_type_name_optional                      = 87
	SQLv1Antlr4ParserRULE_type_name_tuple                         = 88
	SQLv1Antlr4ParserRULE_type_name_struct                        = 89
	SQLv1Antlr4ParserRULE_type_name_variant                       = 90
	SQLv1Antlr4ParserRULE_type_name_list                          = 91
	SQLv1Antlr4ParserRULE_type_name_stream                        = 92
	SQLv1Antlr4ParserRULE_type_name_flow                          = 93
	SQLv1Antlr4ParserRULE_type_name_dict                          = 94
	SQLv1Antlr4ParserRULE_type_name_set                           = 95
	SQLv1Antlr4ParserRULE_type_name_enum                          = 96
	SQLv1Antlr4ParserRULE_type_name_resource                      = 97
	SQLv1Antlr4ParserRULE_type_name_tagged                        = 98
	SQLv1Antlr4ParserRULE_type_name_callable                      = 99
	SQLv1Antlr4ParserRULE_type_name_composite                     = 100
	SQLv1Antlr4ParserRULE_type_name                               = 101
	SQLv1Antlr4ParserRULE_type_name_or_bind                       = 102
	SQLv1Antlr4ParserRULE_value_constructor_literal               = 103
	SQLv1Antlr4ParserRULE_value_constructor                       = 104
	SQLv1Antlr4ParserRULE_declare_stmt                            = 105
	SQLv1Antlr4ParserRULE_module_path                             = 106
	SQLv1Antlr4ParserRULE_import_stmt                             = 107
	SQLv1Antlr4ParserRULE_export_stmt                             = 108
	SQLv1Antlr4ParserRULE_call_action                             = 109
	SQLv1Antlr4ParserRULE_inline_action                           = 110
	SQLv1Antlr4ParserRULE_do_stmt                                 = 111
	SQLv1Antlr4ParserRULE_pragma_stmt                             = 112
	SQLv1Antlr4ParserRULE_pragma_value                            = 113
	SQLv1Antlr4ParserRULE_sort_specification                      = 114
	SQLv1Antlr4ParserRULE_sort_specification_list                 = 115
	SQLv1Antlr4ParserRULE_select_stmt                             = 116
	SQLv1Antlr4ParserRULE_select_unparenthesized_stmt             = 117
	SQLv1Antlr4ParserRULE_select_kind_parenthesis                 = 118
	SQLv1Antlr4ParserRULE_select_op                               = 119
	SQLv1Antlr4ParserRULE_select_kind_partial                     = 120
	SQLv1Antlr4ParserRULE_select_kind                             = 121
	SQLv1Antlr4ParserRULE_process_core                            = 122
	SQLv1Antlr4ParserRULE_external_call_param                     = 123
	SQLv1Antlr4ParserRULE_external_call_settings                  = 124
	SQLv1Antlr4ParserRULE_reduce_core                             = 125
	SQLv1Antlr4ParserRULE_opt_set_quantifier                      = 126
	SQLv1Antlr4ParserRULE_select_core                             = 127
	SQLv1Antlr4ParserRULE_row_pattern_recognition_clause          = 128
	SQLv1Antlr4ParserRULE_row_pattern_rows_per_match              = 129
	SQLv1Antlr4ParserRULE_row_pattern_empty_match_handling        = 130
	SQLv1Antlr4ParserRULE_row_pattern_measures                    = 131
	SQLv1Antlr4ParserRULE_row_pattern_measure_list                = 132
	SQLv1Antlr4ParserRULE_row_pattern_measure_definition          = 133
	SQLv1Antlr4ParserRULE_row_pattern_common_syntax               = 134
	SQLv1Antlr4ParserRULE_row_pattern_skip_to                     = 135
	SQLv1Antlr4ParserRULE_row_pattern_skip_to_variable_name       = 136
	SQLv1Antlr4ParserRULE_row_pattern_initial_or_seek             = 137
	SQLv1Antlr4ParserRULE_row_pattern                             = 138
	SQLv1Antlr4ParserRULE_row_pattern_term                        = 139
	SQLv1Antlr4ParserRULE_row_pattern_factor                      = 140
	SQLv1Antlr4ParserRULE_row_pattern_quantifier                  = 141
	SQLv1Antlr4ParserRULE_row_pattern_primary                     = 142
	SQLv1Antlr4ParserRULE_row_pattern_primary_variable_name       = 143
	SQLv1Antlr4ParserRULE_row_pattern_permute                     = 144
	SQLv1Antlr4ParserRULE_row_pattern_subset_clause               = 145
	SQLv1Antlr4ParserRULE_row_pattern_subset_list                 = 146
	SQLv1Antlr4ParserRULE_row_pattern_subset_item                 = 147
	SQLv1Antlr4ParserRULE_row_pattern_subset_item_variable_name   = 148
	SQLv1Antlr4ParserRULE_row_pattern_subset_rhs                  = 149
	SQLv1Antlr4ParserRULE_row_pattern_subset_rhs_variable_name    = 150
	SQLv1Antlr4ParserRULE_row_pattern_definition_list             = 151
	SQLv1Antlr4ParserRULE_row_pattern_definition                  = 152
	SQLv1Antlr4ParserRULE_row_pattern_definition_variable_name    = 153
	SQLv1Antlr4ParserRULE_row_pattern_definition_search_condition = 154
	SQLv1Antlr4ParserRULE_search_condition                        = 155
	SQLv1Antlr4ParserRULE_row_pattern_variable_name               = 156
	SQLv1Antlr4ParserRULE_order_by_clause                         = 157
	SQLv1Antlr4ParserRULE_ext_order_by_clause                     = 158
	SQLv1Antlr4ParserRULE_group_by_clause                         = 159
	SQLv1Antlr4ParserRULE_grouping_element_list                   = 160
	SQLv1Antlr4ParserRULE_grouping_element                        = 161
	SQLv1Antlr4ParserRULE_ordinary_grouping_set                   = 162
	SQLv1Antlr4ParserRULE_ordinary_grouping_set_list              = 163
	SQLv1Antlr4ParserRULE_rollup_list                             = 164
	SQLv1Antlr4ParserRULE_cube_list                               = 165
	SQLv1Antlr4ParserRULE_grouping_sets_specification             = 166
	SQLv1Antlr4ParserRULE_hopping_window_specification            = 167
	SQLv1Antlr4ParserRULE_result_column                           = 168
	SQLv1Antlr4ParserRULE_join_source                             = 169
	SQLv1Antlr4ParserRULE_named_column                            = 170
	SQLv1Antlr4ParserRULE_flatten_by_arg                          = 171
	SQLv1Antlr4ParserRULE_flatten_source                          = 172
	SQLv1Antlr4ParserRULE_named_single_source                     = 173
	SQLv1Antlr4ParserRULE_single_source                           = 174
	SQLv1Antlr4ParserRULE_sample_clause                           = 175
	SQLv1Antlr4ParserRULE_tablesample_clause                      = 176
	SQLv1Antlr4ParserRULE_sampling_mode                           = 177
	SQLv1Antlr4ParserRULE_repeatable_clause                       = 178
	SQLv1Antlr4ParserRULE_join_op                                 = 179
	SQLv1Antlr4ParserRULE_join_constraint                         = 180
	SQLv1Antlr4ParserRULE_returning_columns_list                  = 181
	SQLv1Antlr4ParserRULE_into_table_stmt                         = 182
	SQLv1Antlr4ParserRULE_into_values_source                      = 183
	SQLv1Antlr4ParserRULE_values_stmt                             = 184
	SQLv1Antlr4ParserRULE_values_source                           = 185
	SQLv1Antlr4ParserRULE_values_source_row_list                  = 186
	SQLv1Antlr4ParserRULE_values_source_row                       = 187
	SQLv1Antlr4ParserRULE_simple_values_source                    = 188
	SQLv1Antlr4ParserRULE_create_external_data_source_stmt        = 189
	SQLv1Antlr4ParserRULE_alter_external_data_source_stmt         = 190
	SQLv1Antlr4ParserRULE_alter_external_data_source_action       = 191
	SQLv1Antlr4ParserRULE_drop_external_data_source_stmt          = 192
	SQLv1Antlr4ParserRULE_create_view_stmt                        = 193
	SQLv1Antlr4ParserRULE_drop_view_stmt                          = 194
	SQLv1Antlr4ParserRULE_upsert_object_stmt                      = 195
	SQLv1Antlr4ParserRULE_create_object_stmt                      = 196
	SQLv1Antlr4ParserRULE_create_object_features                  = 197
	SQLv1Antlr4ParserRULE_alter_object_stmt                       = 198
	SQLv1Antlr4ParserRULE_alter_object_features                   = 199
	SQLv1Antlr4ParserRULE_drop_object_stmt                        = 200
	SQLv1Antlr4ParserRULE_drop_object_features                    = 201
	SQLv1Antlr4ParserRULE_object_feature_value                    = 202
	SQLv1Antlr4ParserRULE_object_feature_kv                       = 203
	SQLv1Antlr4ParserRULE_object_feature_flag                     = 204
	SQLv1Antlr4ParserRULE_object_feature                          = 205
	SQLv1Antlr4ParserRULE_object_features                         = 206
	SQLv1Antlr4ParserRULE_object_type_ref                         = 207
	SQLv1Antlr4ParserRULE_create_table_stmt                       = 208
	SQLv1Antlr4ParserRULE_create_table_entry                      = 209
	SQLv1Antlr4ParserRULE_create_backup_collection_stmt           = 210
	SQLv1Antlr4ParserRULE_alter_backup_collection_stmt            = 211
	SQLv1Antlr4ParserRULE_drop_backup_collection_stmt             = 212
	SQLv1Antlr4ParserRULE_database_or_table_list                  = 213
	SQLv1Antlr4ParserRULE_table_list                              = 214
	SQLv1Antlr4ParserRULE_alter_backup_collection_actions         = 215
	SQLv1Antlr4ParserRULE_alter_backup_collection_action          = 216
	SQLv1Antlr4ParserRULE_alter_backup_collection_entries         = 217
	SQLv1Antlr4ParserRULE_alter_backup_collection_entry           = 218
	SQLv1Antlr4ParserRULE_backup_collection                       = 219
	SQLv1Antlr4ParserRULE_backup_collection_settings              = 220
	SQLv1Antlr4ParserRULE_backup_collection_settings_entry        = 221
	SQLv1Antlr4ParserRULE_backup_stmt                             = 222
	SQLv1Antlr4ParserRULE_restore_stmt                            = 223
	SQLv1Antlr4ParserRULE_table_inherits                          = 224
	SQLv1Antlr4ParserRULE_table_partition_by                      = 225
	SQLv1Antlr4ParserRULE_with_table_settings                     = 226
	SQLv1Antlr4ParserRULE_table_tablestore                        = 227
	SQLv1Antlr4ParserRULE_table_settings_entry                    = 228
	SQLv1Antlr4ParserRULE_table_as_source                         = 229
	SQLv1Antlr4ParserRULE_alter_table_stmt                        = 230
	SQLv1Antlr4ParserRULE_alter_table_action                      = 231
	SQLv1Antlr4ParserRULE_alter_external_table_stmt               = 232
	SQLv1Antlr4ParserRULE_alter_external_table_action             = 233
	SQLv1Antlr4ParserRULE_alter_table_store_stmt                  = 234
	SQLv1Antlr4ParserRULE_alter_table_store_action                = 235
	SQLv1Antlr4ParserRULE_alter_table_add_column                  = 236
	SQLv1Antlr4ParserRULE_alter_table_drop_column                 = 237
	SQLv1Antlr4ParserRULE_alter_table_alter_column                = 238
	SQLv1Antlr4ParserRULE_alter_table_alter_column_drop_not_null  = 239
	SQLv1Antlr4ParserRULE_alter_table_add_column_family           = 240
	SQLv1Antlr4ParserRULE_alter_table_alter_column_family         = 241
	SQLv1Antlr4ParserRULE_alter_table_set_table_setting_uncompat  = 242
	SQLv1Antlr4ParserRULE_alter_table_set_table_setting_compat    = 243
	SQLv1Antlr4ParserRULE_alter_table_reset_table_setting         = 244
	SQLv1Antlr4ParserRULE_alter_table_add_index                   = 245
	SQLv1Antlr4ParserRULE_alter_table_drop_index                  = 246
	SQLv1Antlr4ParserRULE_alter_table_rename_to                   = 247
	SQLv1Antlr4ParserRULE_alter_table_rename_index_to             = 248
	SQLv1Antlr4ParserRULE_alter_table_add_changefeed              = 249
	SQLv1Antlr4ParserRULE_alter_table_alter_changefeed            = 250
	SQLv1Antlr4ParserRULE_alter_table_drop_changefeed             = 251
	SQLv1Antlr4ParserRULE_alter_table_alter_index                 = 252
	SQLv1Antlr4ParserRULE_column_schema                           = 253
	SQLv1Antlr4ParserRULE_family_relation                         = 254
	SQLv1Antlr4ParserRULE_opt_column_constraints                  = 255
	SQLv1Antlr4ParserRULE_column_order_by_specification           = 256
	SQLv1Antlr4ParserRULE_table_constraint                        = 257
	SQLv1Antlr4ParserRULE_table_index                             = 258
	SQLv1Antlr4ParserRULE_table_index_type                        = 259
	SQLv1Antlr4ParserRULE_global_index                            = 260
	SQLv1Antlr4ParserRULE_local_index                             = 261
	SQLv1Antlr4ParserRULE_index_subtype                           = 262
	SQLv1Antlr4ParserRULE_with_index_settings                     = 263
	SQLv1Antlr4ParserRULE_index_setting_entry                     = 264
	SQLv1Antlr4ParserRULE_index_setting_value                     = 265
	SQLv1Antlr4ParserRULE_changefeed                              = 266
	SQLv1Antlr4ParserRULE_changefeed_settings                     = 267
	SQLv1Antlr4ParserRULE_changefeed_settings_entry               = 268
	SQLv1Antlr4ParserRULE_changefeed_setting_value                = 269
	SQLv1Antlr4ParserRULE_changefeed_alter_settings               = 270
	SQLv1Antlr4ParserRULE_alter_table_setting_entry               = 271
	SQLv1Antlr4ParserRULE_table_setting_value                     = 272
	SQLv1Antlr4ParserRULE_family_entry                            = 273
	SQLv1Antlr4ParserRULE_family_settings                         = 274
	SQLv1Antlr4ParserRULE_family_settings_entry                   = 275
	SQLv1Antlr4ParserRULE_family_setting_value                    = 276
	SQLv1Antlr4ParserRULE_split_boundaries                        = 277
	SQLv1Antlr4ParserRULE_literal_value_list                      = 278
	SQLv1Antlr4ParserRULE_alter_table_alter_index_action          = 279
	SQLv1Antlr4ParserRULE_drop_table_stmt                         = 280
	SQLv1Antlr4ParserRULE_create_user_stmt                        = 281
	SQLv1Antlr4ParserRULE_alter_user_stmt                         = 282
	SQLv1Antlr4ParserRULE_create_group_stmt                       = 283
	SQLv1Antlr4ParserRULE_alter_group_stmt                        = 284
	SQLv1Antlr4ParserRULE_drop_role_stmt                          = 285
	SQLv1Antlr4ParserRULE_role_name                               = 286
	SQLv1Antlr4ParserRULE_create_user_option                      = 287
	SQLv1Antlr4ParserRULE_grant_permissions_stmt                  = 288
	SQLv1Antlr4ParserRULE_revoke_permissions_stmt                 = 289
	SQLv1Antlr4ParserRULE_permission_id                           = 290
	SQLv1Antlr4ParserRULE_permission_name                         = 291
	SQLv1Antlr4ParserRULE_permission_name_target                  = 292
	SQLv1Antlr4ParserRULE_create_resource_pool_stmt               = 293
	SQLv1Antlr4ParserRULE_alter_resource_pool_stmt                = 294
	SQLv1Antlr4ParserRULE_alter_resource_pool_action              = 295
	SQLv1Antlr4ParserRULE_drop_resource_pool_stmt                 = 296
	SQLv1Antlr4ParserRULE_create_resource_pool_classifier_stmt    = 297
	SQLv1Antlr4ParserRULE_alter_resource_pool_classifier_stmt     = 298
	SQLv1Antlr4ParserRULE_alter_resource_pool_classifier_action   = 299
	SQLv1Antlr4ParserRULE_drop_resource_pool_classifier_stmt      = 300
	SQLv1Antlr4ParserRULE_create_replication_stmt                 = 301
	SQLv1Antlr4ParserRULE_replication_target                      = 302
	SQLv1Antlr4ParserRULE_replication_settings                    = 303
	SQLv1Antlr4ParserRULE_replication_settings_entry              = 304
	SQLv1Antlr4ParserRULE_alter_replication_stmt                  = 305
	SQLv1Antlr4ParserRULE_alter_replication_action                = 306
	SQLv1Antlr4ParserRULE_alter_replication_set_setting           = 307
	SQLv1Antlr4ParserRULE_drop_replication_stmt                   = 308
	SQLv1Antlr4ParserRULE_action_or_subquery_args                 = 309
	SQLv1Antlr4ParserRULE_define_action_or_subquery_stmt          = 310
	SQLv1Antlr4ParserRULE_define_action_or_subquery_body          = 311
	SQLv1Antlr4ParserRULE_if_stmt                                 = 312
	SQLv1Antlr4ParserRULE_for_stmt                                = 313
	SQLv1Antlr4ParserRULE_table_ref                               = 314
	SQLv1Antlr4ParserRULE_table_key                               = 315
	SQLv1Antlr4ParserRULE_table_arg                               = 316
	SQLv1Antlr4ParserRULE_table_hints                             = 317
	SQLv1Antlr4ParserRULE_table_hint                              = 318
	SQLv1Antlr4ParserRULE_object_ref                              = 319
	SQLv1Antlr4ParserRULE_simple_table_ref_core                   = 320
	SQLv1Antlr4ParserRULE_simple_table_ref                        = 321
	SQLv1Antlr4ParserRULE_into_simple_table_ref                   = 322
	SQLv1Antlr4ParserRULE_delete_stmt                             = 323
	SQLv1Antlr4ParserRULE_update_stmt                             = 324
	SQLv1Antlr4ParserRULE_set_clause_choice                       = 325
	SQLv1Antlr4ParserRULE_set_clause_list                         = 326
	SQLv1Antlr4ParserRULE_set_clause                              = 327
	SQLv1Antlr4ParserRULE_set_target                              = 328
	SQLv1Antlr4ParserRULE_multiple_column_assignment              = 329
	SQLv1Antlr4ParserRULE_set_target_list                         = 330
	SQLv1Antlr4ParserRULE_create_topic_stmt                       = 331
	SQLv1Antlr4ParserRULE_create_topic_entries                    = 332
	SQLv1Antlr4ParserRULE_create_topic_entry                      = 333
	SQLv1Antlr4ParserRULE_with_topic_settings                     = 334
	SQLv1Antlr4ParserRULE_alter_topic_stmt                        = 335
	SQLv1Antlr4ParserRULE_alter_topic_action                      = 336
	SQLv1Antlr4ParserRULE_alter_topic_add_consumer                = 337
	SQLv1Antlr4ParserRULE_topic_create_consumer_entry             = 338
	SQLv1Antlr4ParserRULE_alter_topic_alter_consumer              = 339
	SQLv1Antlr4ParserRULE_alter_topic_alter_consumer_entry        = 340
	SQLv1Antlr4ParserRULE_alter_topic_drop_consumer               = 341
	SQLv1Antlr4ParserRULE_topic_alter_consumer_set                = 342
	SQLv1Antlr4ParserRULE_topic_alter_consumer_reset              = 343
	SQLv1Antlr4ParserRULE_alter_topic_set_settings                = 344
	SQLv1Antlr4ParserRULE_alter_topic_reset_settings              = 345
	SQLv1Antlr4ParserRULE_drop_topic_stmt                         = 346
	SQLv1Antlr4ParserRULE_topic_settings                          = 347
	SQLv1Antlr4ParserRULE_topic_settings_entry                    = 348
	SQLv1Antlr4ParserRULE_topic_setting_value                     = 349
	SQLv1Antlr4ParserRULE_topic_consumer_with_settings            = 350
	SQLv1Antlr4ParserRULE_topic_consumer_settings                 = 351
	SQLv1Antlr4ParserRULE_topic_consumer_settings_entry           = 352
	SQLv1Antlr4ParserRULE_topic_consumer_setting_value            = 353
	SQLv1Antlr4ParserRULE_topic_ref                               = 354
	SQLv1Antlr4ParserRULE_topic_consumer_ref                      = 355
	SQLv1Antlr4ParserRULE_null_treatment                          = 356
	SQLv1Antlr4ParserRULE_filter_clause                           = 357
	SQLv1Antlr4ParserRULE_window_name_or_specification            = 358
	SQLv1Antlr4ParserRULE_window_name                             = 359
	SQLv1Antlr4ParserRULE_window_clause                           = 360
	SQLv1Antlr4ParserRULE_window_definition_list                  = 361
	SQLv1Antlr4ParserRULE_window_definition                       = 362
	SQLv1Antlr4ParserRULE_new_window_name                         = 363
	SQLv1Antlr4ParserRULE_window_specification                    = 364
	SQLv1Antlr4ParserRULE_window_specification_details            = 365
	SQLv1Antlr4ParserRULE_existing_window_name                    = 366
	SQLv1Antlr4ParserRULE_window_partition_clause                 = 367
	SQLv1Antlr4ParserRULE_window_order_clause                     = 368
	SQLv1Antlr4ParserRULE_window_frame_clause                     = 369
	SQLv1Antlr4ParserRULE_window_frame_units                      = 370
	SQLv1Antlr4ParserRULE_window_frame_extent                     = 371
	SQLv1Antlr4ParserRULE_window_frame_between                    = 372
	SQLv1Antlr4ParserRULE_window_frame_bound                      = 373
	SQLv1Antlr4ParserRULE_window_frame_exclusion                  = 374
	SQLv1Antlr4ParserRULE_use_stmt                                = 375
	SQLv1Antlr4ParserRULE_subselect_stmt                          = 376
	SQLv1Antlr4ParserRULE_named_nodes_stmt                        = 377
	SQLv1Antlr4ParserRULE_commit_stmt                             = 378
	SQLv1Antlr4ParserRULE_rollback_stmt                           = 379
	SQLv1Antlr4ParserRULE_analyze_table                           = 380
	SQLv1Antlr4ParserRULE_analyze_table_list                      = 381
	SQLv1Antlr4ParserRULE_analyze_stmt                            = 382
	SQLv1Antlr4ParserRULE_identifier                              = 383
	SQLv1Antlr4ParserRULE_id                                      = 384
	SQLv1Antlr4ParserRULE_id_schema                               = 385
	SQLv1Antlr4ParserRULE_id_expr                                 = 386
	SQLv1Antlr4ParserRULE_id_expr_in                              = 387
	SQLv1Antlr4ParserRULE_id_window                               = 388
	SQLv1Antlr4ParserRULE_id_table                                = 389
	SQLv1Antlr4ParserRULE_id_without                              = 390
	SQLv1Antlr4ParserRULE_id_hint                                 = 391
	SQLv1Antlr4ParserRULE_id_as_compat                            = 392
	SQLv1Antlr4ParserRULE_an_id                                   = 393
	SQLv1Antlr4ParserRULE_an_id_or_type                           = 394
	SQLv1Antlr4ParserRULE_an_id_schema                            = 395
	SQLv1Antlr4ParserRULE_an_id_expr                              = 396
	SQLv1Antlr4ParserRULE_an_id_expr_in                           = 397
	SQLv1Antlr4ParserRULE_an_id_window                            = 398
	SQLv1Antlr4ParserRULE_an_id_table                             = 399
	SQLv1Antlr4ParserRULE_an_id_without                           = 400
	SQLv1Antlr4ParserRULE_an_id_hint                              = 401
	SQLv1Antlr4ParserRULE_an_id_pure                              = 402
	SQLv1Antlr4ParserRULE_an_id_as_compat                         = 403
	SQLv1Antlr4ParserRULE_view_name                               = 404
	SQLv1Antlr4ParserRULE_opt_id_prefix                           = 405
	SQLv1Antlr4ParserRULE_cluster_expr                            = 406
	SQLv1Antlr4ParserRULE_id_or_type                              = 407
	SQLv1Antlr4ParserRULE_opt_id_prefix_or_type                   = 408
	SQLv1Antlr4ParserRULE_id_or_at                                = 409
	SQLv1Antlr4ParserRULE_id_table_or_type                        = 410
	SQLv1Antlr4ParserRULE_id_table_or_at                          = 411
	SQLv1Antlr4ParserRULE_keyword                                 = 412
	SQLv1Antlr4ParserRULE_keyword_expr_uncompat                   = 413
	SQLv1Antlr4ParserRULE_keyword_table_uncompat                  = 414
	SQLv1Antlr4ParserRULE_keyword_select_uncompat                 = 415
	SQLv1Antlr4ParserRULE_keyword_alter_uncompat                  = 416
	SQLv1Antlr4ParserRULE_keyword_in_uncompat                     = 417
	SQLv1Antlr4ParserRULE_keyword_window_uncompat                 = 418
	SQLv1Antlr4ParserRULE_keyword_hint_uncompat                   = 419
	SQLv1Antlr4ParserRULE_keyword_as_compat                       = 420
	SQLv1Antlr4ParserRULE_keyword_compat                          = 421
	SQLv1Antlr4ParserRULE_type_id                                 = 422
	SQLv1Antlr4ParserRULE_bool_value                              = 423
	SQLv1Antlr4ParserRULE_real                                    = 424
	SQLv1Antlr4ParserRULE_integer                                 = 425
)

// ISql_queryContext is an interface to support dynamic dispatch.
type ISql_queryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Sql_stmt_list() ISql_stmt_listContext
	PRAGMA() antlr.TerminalNode
	ANSI() antlr.TerminalNode
	DIGITS() antlr.TerminalNode
	Ansi_sql_stmt_list() IAnsi_sql_stmt_listContext

	// IsSql_queryContext differentiates from other interfaces.
	IsSql_queryContext()
}

type Sql_queryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySql_queryContext() *Sql_queryContext {
	var p = new(Sql_queryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_sql_query
	return p
}

func InitEmptySql_queryContext(p *Sql_queryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_sql_query
}

func (*Sql_queryContext) IsSql_queryContext() {}

func NewSql_queryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sql_queryContext {
	var p = new(Sql_queryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_sql_query

	return p
}

func (s *Sql_queryContext) GetParser() antlr.Parser { return s.parser }

func (s *Sql_queryContext) Sql_stmt_list() ISql_stmt_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_stmt_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_stmt_listContext)
}

func (s *Sql_queryContext) PRAGMA() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPRAGMA, 0)
}

func (s *Sql_queryContext) ANSI() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserANSI, 0)
}

func (s *Sql_queryContext) DIGITS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDIGITS, 0)
}

func (s *Sql_queryContext) Ansi_sql_stmt_list() IAnsi_sql_stmt_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnsi_sql_stmt_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnsi_sql_stmt_listContext)
}

func (s *Sql_queryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sql_queryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sql_queryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSql_query(s)
	}
}

func (s *Sql_queryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSql_query(s)
	}
}

func (p *SQLv1Antlr4Parser) Sql_query() (localctx ISql_queryContext) {
	localctx = NewSql_queryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SQLv1Antlr4ParserRULE_sql_query)
	p.SetState(857)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(852)
			p.Sql_stmt_list()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(853)
			p.Match(SQLv1Antlr4ParserPRAGMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(854)
			p.Match(SQLv1Antlr4ParserANSI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(855)
			p.Match(SQLv1Antlr4ParserDIGITS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(856)
			p.Ansi_sql_stmt_list()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISql_stmt_listContext is an interface to support dynamic dispatch.
type ISql_stmt_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSql_stmt() []ISql_stmtContext
	Sql_stmt(i int) ISql_stmtContext
	EOF() antlr.TerminalNode
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode

	// IsSql_stmt_listContext differentiates from other interfaces.
	IsSql_stmt_listContext()
}

type Sql_stmt_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySql_stmt_listContext() *Sql_stmt_listContext {
	var p = new(Sql_stmt_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_sql_stmt_list
	return p
}

func InitEmptySql_stmt_listContext(p *Sql_stmt_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_sql_stmt_list
}

func (*Sql_stmt_listContext) IsSql_stmt_listContext() {}

func NewSql_stmt_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sql_stmt_listContext {
	var p = new(Sql_stmt_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_sql_stmt_list

	return p
}

func (s *Sql_stmt_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Sql_stmt_listContext) AllSql_stmt() []ISql_stmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_stmtContext); ok {
			len++
		}
	}

	tst := make([]ISql_stmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_stmtContext); ok {
			tst[i] = t.(ISql_stmtContext)
			i++
		}
	}

	return tst
}

func (s *Sql_stmt_listContext) Sql_stmt(i int) ISql_stmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_stmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_stmtContext)
}

func (s *Sql_stmt_listContext) EOF() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEOF, 0)
}

func (s *Sql_stmt_listContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserSEMICOLON)
}

func (s *Sql_stmt_listContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSEMICOLON, i)
}

func (s *Sql_stmt_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sql_stmt_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sql_stmt_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSql_stmt_list(s)
	}
}

func (s *Sql_stmt_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSql_stmt_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Sql_stmt_list() (localctx ISql_stmt_listContext) {
	localctx = NewSql_stmt_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SQLv1Antlr4ParserRULE_sql_stmt_list)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(862)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserSEMICOLON {
		{
			p.SetState(859)
			p.Match(SQLv1Antlr4ParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(864)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(865)
		p.Sql_stmt()
	}
	p.SetState(874)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(867)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == SQLv1Antlr4ParserSEMICOLON {
				{
					p.SetState(866)
					p.Match(SQLv1Antlr4ParserSEMICOLON)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(869)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(871)
				p.Sql_stmt()
			}

		}
		p.SetState(876)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(880)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserSEMICOLON {
		{
			p.SetState(877)
			p.Match(SQLv1Antlr4ParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(882)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(883)
		p.Match(SQLv1Antlr4ParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnsi_sql_stmt_listContext is an interface to support dynamic dispatch.
type IAnsi_sql_stmt_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode

	// IsAnsi_sql_stmt_listContext differentiates from other interfaces.
	IsAnsi_sql_stmt_listContext()
}

type Ansi_sql_stmt_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnsi_sql_stmt_listContext() *Ansi_sql_stmt_listContext {
	var p = new(Ansi_sql_stmt_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_ansi_sql_stmt_list
	return p
}

func InitEmptyAnsi_sql_stmt_listContext(p *Ansi_sql_stmt_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_ansi_sql_stmt_list
}

func (*Ansi_sql_stmt_listContext) IsAnsi_sql_stmt_listContext() {}

func NewAnsi_sql_stmt_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ansi_sql_stmt_listContext {
	var p = new(Ansi_sql_stmt_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_ansi_sql_stmt_list

	return p
}

func (s *Ansi_sql_stmt_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Ansi_sql_stmt_listContext) EOF() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEOF, 0)
}

func (s *Ansi_sql_stmt_listContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserSEMICOLON)
}

func (s *Ansi_sql_stmt_listContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSEMICOLON, i)
}

func (s *Ansi_sql_stmt_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ansi_sql_stmt_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ansi_sql_stmt_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAnsi_sql_stmt_list(s)
	}
}

func (s *Ansi_sql_stmt_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAnsi_sql_stmt_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Ansi_sql_stmt_list() (localctx IAnsi_sql_stmt_listContext) {
	localctx = NewAnsi_sql_stmt_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SQLv1Antlr4ParserRULE_ansi_sql_stmt_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(888)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserSEMICOLON {
		{
			p.SetState(885)
			p.Match(SQLv1Antlr4ParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(890)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(891)
		p.Match(SQLv1Antlr4ParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambda_bodyContext is an interface to support dynamic dispatch.
type ILambda_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURN() antlr.TerminalNode
	Expr() IExprContext
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode
	AllLambda_stmt() []ILambda_stmtContext
	Lambda_stmt(i int) ILambda_stmtContext

	// IsLambda_bodyContext differentiates from other interfaces.
	IsLambda_bodyContext()
}

type Lambda_bodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambda_bodyContext() *Lambda_bodyContext {
	var p = new(Lambda_bodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_lambda_body
	return p
}

func InitEmptyLambda_bodyContext(p *Lambda_bodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_lambda_body
}

func (*Lambda_bodyContext) IsLambda_bodyContext() {}

func NewLambda_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lambda_bodyContext {
	var p = new(Lambda_bodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_lambda_body

	return p
}

func (s *Lambda_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Lambda_bodyContext) RETURN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRETURN, 0)
}

func (s *Lambda_bodyContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Lambda_bodyContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserSEMICOLON)
}

func (s *Lambda_bodyContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSEMICOLON, i)
}

func (s *Lambda_bodyContext) AllLambda_stmt() []ILambda_stmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILambda_stmtContext); ok {
			len++
		}
	}

	tst := make([]ILambda_stmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILambda_stmtContext); ok {
			tst[i] = t.(ILambda_stmtContext)
			i++
		}
	}

	return tst
}

func (s *Lambda_bodyContext) Lambda_stmt(i int) ILambda_stmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambda_stmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambda_stmtContext)
}

func (s *Lambda_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lambda_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lambda_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterLambda_body(s)
	}
}

func (s *Lambda_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitLambda_body(s)
	}
}

func (p *SQLv1Antlr4Parser) Lambda_body() (localctx ILambda_bodyContext) {
	localctx = NewLambda_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SQLv1Antlr4ParserRULE_lambda_body)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(896)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserSEMICOLON {
		{
			p.SetState(893)
			p.Match(SQLv1Antlr4ParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(898)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(907)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserDOLLAR || _la == SQLv1Antlr4ParserIMPORT {
		{
			p.SetState(899)
			p.Lambda_stmt()
		}
		p.SetState(901)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SQLv1Antlr4ParserSEMICOLON {
			{
				p.SetState(900)
				p.Match(SQLv1Antlr4ParserSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(903)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

		p.SetState(909)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(910)
		p.Match(SQLv1Antlr4ParserRETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(911)
		p.Expr()
	}
	p.SetState(915)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserSEMICOLON {
		{
			p.SetState(912)
			p.Match(SQLv1Antlr4ParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(917)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambda_stmtContext is an interface to support dynamic dispatch.
type ILambda_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Named_nodes_stmt() INamed_nodes_stmtContext
	Import_stmt() IImport_stmtContext

	// IsLambda_stmtContext differentiates from other interfaces.
	IsLambda_stmtContext()
}

type Lambda_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambda_stmtContext() *Lambda_stmtContext {
	var p = new(Lambda_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_lambda_stmt
	return p
}

func InitEmptyLambda_stmtContext(p *Lambda_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_lambda_stmt
}

func (*Lambda_stmtContext) IsLambda_stmtContext() {}

func NewLambda_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lambda_stmtContext {
	var p = new(Lambda_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_lambda_stmt

	return p
}

func (s *Lambda_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Lambda_stmtContext) Named_nodes_stmt() INamed_nodes_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_nodes_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_nodes_stmtContext)
}

func (s *Lambda_stmtContext) Import_stmt() IImport_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImport_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImport_stmtContext)
}

func (s *Lambda_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lambda_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lambda_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterLambda_stmt(s)
	}
}

func (s *Lambda_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitLambda_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Lambda_stmt() (localctx ILambda_stmtContext) {
	localctx = NewLambda_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SQLv1Antlr4ParserRULE_lambda_stmt)
	p.SetState(920)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserDOLLAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(918)
			p.Named_nodes_stmt()
		}

	case SQLv1Antlr4ParserIMPORT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(919)
			p.Import_stmt()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISql_stmtContext is an interface to support dynamic dispatch.
type ISql_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Sql_stmt_core() ISql_stmt_coreContext
	EXPLAIN() antlr.TerminalNode
	TQ() antlr.TerminalNode
	TU() antlr.TerminalNode
	TE() antlr.TerminalNode
	TR() antlr.TerminalNode
	TY() antlr.TerminalNode
	PLAN() antlr.TerminalNode

	// IsSql_stmtContext differentiates from other interfaces.
	IsSql_stmtContext()
}

type Sql_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySql_stmtContext() *Sql_stmtContext {
	var p = new(Sql_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_sql_stmt
	return p
}

func InitEmptySql_stmtContext(p *Sql_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_sql_stmt
}

func (*Sql_stmtContext) IsSql_stmtContext() {}

func NewSql_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sql_stmtContext {
	var p = new(Sql_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_sql_stmt

	return p
}

func (s *Sql_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Sql_stmtContext) Sql_stmt_core() ISql_stmt_coreContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_stmt_coreContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_stmt_coreContext)
}

func (s *Sql_stmtContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXPLAIN, 0)
}

func (s *Sql_stmtContext) TQ() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTQ, 0)
}

func (s *Sql_stmtContext) TU() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTU, 0)
}

func (s *Sql_stmtContext) TE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTE, 0)
}

func (s *Sql_stmtContext) TR() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTR, 0)
}

func (s *Sql_stmtContext) TY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTY, 0)
}

func (s *Sql_stmtContext) PLAN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPLAN, 0)
}

func (s *Sql_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sql_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sql_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSql_stmt(s)
	}
}

func (s *Sql_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSql_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Sql_stmt() (localctx ISql_stmtContext) {
	localctx = NewSql_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SQLv1Antlr4ParserRULE_sql_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(931)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserEXPLAIN {
		{
			p.SetState(922)
			p.Match(SQLv1Antlr4ParserEXPLAIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(929)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserTQ {
			{
				p.SetState(923)
				p.Match(SQLv1Antlr4ParserTQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(924)
				p.Match(SQLv1Antlr4ParserTU)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(925)
				p.Match(SQLv1Antlr4ParserTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(926)
				p.Match(SQLv1Antlr4ParserTR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(927)
				p.Match(SQLv1Antlr4ParserTY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(928)
				p.Match(SQLv1Antlr4ParserPLAN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(933)
		p.Sql_stmt_core()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISql_stmt_coreContext is an interface to support dynamic dispatch.
type ISql_stmt_coreContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Pragma_stmt() IPragma_stmtContext
	Select_stmt() ISelect_stmtContext
	Named_nodes_stmt() INamed_nodes_stmtContext
	Create_table_stmt() ICreate_table_stmtContext
	Drop_table_stmt() IDrop_table_stmtContext
	Use_stmt() IUse_stmtContext
	Into_table_stmt() IInto_table_stmtContext
	Commit_stmt() ICommit_stmtContext
	Update_stmt() IUpdate_stmtContext
	Delete_stmt() IDelete_stmtContext
	Rollback_stmt() IRollback_stmtContext
	Declare_stmt() IDeclare_stmtContext
	Import_stmt() IImport_stmtContext
	Export_stmt() IExport_stmtContext
	Alter_table_stmt() IAlter_table_stmtContext
	Alter_external_table_stmt() IAlter_external_table_stmtContext
	Do_stmt() IDo_stmtContext
	Define_action_or_subquery_stmt() IDefine_action_or_subquery_stmtContext
	If_stmt() IIf_stmtContext
	For_stmt() IFor_stmtContext
	Values_stmt() IValues_stmtContext
	Create_user_stmt() ICreate_user_stmtContext
	Alter_user_stmt() IAlter_user_stmtContext
	Create_group_stmt() ICreate_group_stmtContext
	Alter_group_stmt() IAlter_group_stmtContext
	Drop_role_stmt() IDrop_role_stmtContext
	Create_object_stmt() ICreate_object_stmtContext
	Alter_object_stmt() IAlter_object_stmtContext
	Drop_object_stmt() IDrop_object_stmtContext
	Create_external_data_source_stmt() ICreate_external_data_source_stmtContext
	Alter_external_data_source_stmt() IAlter_external_data_source_stmtContext
	Drop_external_data_source_stmt() IDrop_external_data_source_stmtContext
	Create_replication_stmt() ICreate_replication_stmtContext
	Drop_replication_stmt() IDrop_replication_stmtContext
	Create_topic_stmt() ICreate_topic_stmtContext
	Alter_topic_stmt() IAlter_topic_stmtContext
	Drop_topic_stmt() IDrop_topic_stmtContext
	Grant_permissions_stmt() IGrant_permissions_stmtContext
	Revoke_permissions_stmt() IRevoke_permissions_stmtContext
	Alter_table_store_stmt() IAlter_table_store_stmtContext
	Upsert_object_stmt() IUpsert_object_stmtContext
	Create_view_stmt() ICreate_view_stmtContext
	Drop_view_stmt() IDrop_view_stmtContext
	Alter_replication_stmt() IAlter_replication_stmtContext
	Create_resource_pool_stmt() ICreate_resource_pool_stmtContext
	Alter_resource_pool_stmt() IAlter_resource_pool_stmtContext
	Drop_resource_pool_stmt() IDrop_resource_pool_stmtContext
	Create_backup_collection_stmt() ICreate_backup_collection_stmtContext
	Alter_backup_collection_stmt() IAlter_backup_collection_stmtContext
	Drop_backup_collection_stmt() IDrop_backup_collection_stmtContext
	Analyze_stmt() IAnalyze_stmtContext
	Create_resource_pool_classifier_stmt() ICreate_resource_pool_classifier_stmtContext
	Alter_resource_pool_classifier_stmt() IAlter_resource_pool_classifier_stmtContext
	Drop_resource_pool_classifier_stmt() IDrop_resource_pool_classifier_stmtContext
	Backup_stmt() IBackup_stmtContext
	Restore_stmt() IRestore_stmtContext

	// IsSql_stmt_coreContext differentiates from other interfaces.
	IsSql_stmt_coreContext()
}

type Sql_stmt_coreContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySql_stmt_coreContext() *Sql_stmt_coreContext {
	var p = new(Sql_stmt_coreContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_sql_stmt_core
	return p
}

func InitEmptySql_stmt_coreContext(p *Sql_stmt_coreContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_sql_stmt_core
}

func (*Sql_stmt_coreContext) IsSql_stmt_coreContext() {}

func NewSql_stmt_coreContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sql_stmt_coreContext {
	var p = new(Sql_stmt_coreContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_sql_stmt_core

	return p
}

func (s *Sql_stmt_coreContext) GetParser() antlr.Parser { return s.parser }

func (s *Sql_stmt_coreContext) Pragma_stmt() IPragma_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPragma_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPragma_stmtContext)
}

func (s *Sql_stmt_coreContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Sql_stmt_coreContext) Named_nodes_stmt() INamed_nodes_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_nodes_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_nodes_stmtContext)
}

func (s *Sql_stmt_coreContext) Create_table_stmt() ICreate_table_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_stmtContext)
}

func (s *Sql_stmt_coreContext) Drop_table_stmt() IDrop_table_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_table_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_table_stmtContext)
}

func (s *Sql_stmt_coreContext) Use_stmt() IUse_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUse_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUse_stmtContext)
}

func (s *Sql_stmt_coreContext) Into_table_stmt() IInto_table_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInto_table_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInto_table_stmtContext)
}

func (s *Sql_stmt_coreContext) Commit_stmt() ICommit_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommit_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommit_stmtContext)
}

func (s *Sql_stmt_coreContext) Update_stmt() IUpdate_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdate_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdate_stmtContext)
}

func (s *Sql_stmt_coreContext) Delete_stmt() IDelete_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelete_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelete_stmtContext)
}

func (s *Sql_stmt_coreContext) Rollback_stmt() IRollback_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollback_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollback_stmtContext)
}

func (s *Sql_stmt_coreContext) Declare_stmt() IDeclare_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_stmtContext)
}

func (s *Sql_stmt_coreContext) Import_stmt() IImport_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImport_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImport_stmtContext)
}

func (s *Sql_stmt_coreContext) Export_stmt() IExport_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExport_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExport_stmtContext)
}

func (s *Sql_stmt_coreContext) Alter_table_stmt() IAlter_table_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_stmtContext)
}

func (s *Sql_stmt_coreContext) Alter_external_table_stmt() IAlter_external_table_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_external_table_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_external_table_stmtContext)
}

func (s *Sql_stmt_coreContext) Do_stmt() IDo_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDo_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDo_stmtContext)
}

func (s *Sql_stmt_coreContext) Define_action_or_subquery_stmt() IDefine_action_or_subquery_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefine_action_or_subquery_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefine_action_or_subquery_stmtContext)
}

func (s *Sql_stmt_coreContext) If_stmt() IIf_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIf_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIf_stmtContext)
}

func (s *Sql_stmt_coreContext) For_stmt() IFor_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFor_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFor_stmtContext)
}

func (s *Sql_stmt_coreContext) Values_stmt() IValues_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValues_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValues_stmtContext)
}

func (s *Sql_stmt_coreContext) Create_user_stmt() ICreate_user_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_user_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_user_stmtContext)
}

func (s *Sql_stmt_coreContext) Alter_user_stmt() IAlter_user_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_user_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_user_stmtContext)
}

func (s *Sql_stmt_coreContext) Create_group_stmt() ICreate_group_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_group_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_group_stmtContext)
}

func (s *Sql_stmt_coreContext) Alter_group_stmt() IAlter_group_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_group_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_group_stmtContext)
}

func (s *Sql_stmt_coreContext) Drop_role_stmt() IDrop_role_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_role_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_role_stmtContext)
}

func (s *Sql_stmt_coreContext) Create_object_stmt() ICreate_object_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_object_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_object_stmtContext)
}

func (s *Sql_stmt_coreContext) Alter_object_stmt() IAlter_object_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_object_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_object_stmtContext)
}

func (s *Sql_stmt_coreContext) Drop_object_stmt() IDrop_object_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_object_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_object_stmtContext)
}

func (s *Sql_stmt_coreContext) Create_external_data_source_stmt() ICreate_external_data_source_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_external_data_source_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_external_data_source_stmtContext)
}

func (s *Sql_stmt_coreContext) Alter_external_data_source_stmt() IAlter_external_data_source_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_external_data_source_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_external_data_source_stmtContext)
}

func (s *Sql_stmt_coreContext) Drop_external_data_source_stmt() IDrop_external_data_source_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_external_data_source_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_external_data_source_stmtContext)
}

func (s *Sql_stmt_coreContext) Create_replication_stmt() ICreate_replication_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_replication_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_replication_stmtContext)
}

func (s *Sql_stmt_coreContext) Drop_replication_stmt() IDrop_replication_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_replication_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_replication_stmtContext)
}

func (s *Sql_stmt_coreContext) Create_topic_stmt() ICreate_topic_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_topic_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_topic_stmtContext)
}

func (s *Sql_stmt_coreContext) Alter_topic_stmt() IAlter_topic_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_topic_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_topic_stmtContext)
}

func (s *Sql_stmt_coreContext) Drop_topic_stmt() IDrop_topic_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_topic_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_topic_stmtContext)
}

func (s *Sql_stmt_coreContext) Grant_permissions_stmt() IGrant_permissions_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrant_permissions_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrant_permissions_stmtContext)
}

func (s *Sql_stmt_coreContext) Revoke_permissions_stmt() IRevoke_permissions_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevoke_permissions_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevoke_permissions_stmtContext)
}

func (s *Sql_stmt_coreContext) Alter_table_store_stmt() IAlter_table_store_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_store_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_store_stmtContext)
}

func (s *Sql_stmt_coreContext) Upsert_object_stmt() IUpsert_object_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpsert_object_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpsert_object_stmtContext)
}

func (s *Sql_stmt_coreContext) Create_view_stmt() ICreate_view_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_view_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_view_stmtContext)
}

func (s *Sql_stmt_coreContext) Drop_view_stmt() IDrop_view_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_view_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_view_stmtContext)
}

func (s *Sql_stmt_coreContext) Alter_replication_stmt() IAlter_replication_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_replication_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_replication_stmtContext)
}

func (s *Sql_stmt_coreContext) Create_resource_pool_stmt() ICreate_resource_pool_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_resource_pool_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_resource_pool_stmtContext)
}

func (s *Sql_stmt_coreContext) Alter_resource_pool_stmt() IAlter_resource_pool_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_resource_pool_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_resource_pool_stmtContext)
}

func (s *Sql_stmt_coreContext) Drop_resource_pool_stmt() IDrop_resource_pool_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_resource_pool_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_resource_pool_stmtContext)
}

func (s *Sql_stmt_coreContext) Create_backup_collection_stmt() ICreate_backup_collection_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_backup_collection_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_backup_collection_stmtContext)
}

func (s *Sql_stmt_coreContext) Alter_backup_collection_stmt() IAlter_backup_collection_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_backup_collection_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_backup_collection_stmtContext)
}

func (s *Sql_stmt_coreContext) Drop_backup_collection_stmt() IDrop_backup_collection_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_backup_collection_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_backup_collection_stmtContext)
}

func (s *Sql_stmt_coreContext) Analyze_stmt() IAnalyze_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyze_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyze_stmtContext)
}

func (s *Sql_stmt_coreContext) Create_resource_pool_classifier_stmt() ICreate_resource_pool_classifier_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_resource_pool_classifier_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_resource_pool_classifier_stmtContext)
}

func (s *Sql_stmt_coreContext) Alter_resource_pool_classifier_stmt() IAlter_resource_pool_classifier_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_resource_pool_classifier_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_resource_pool_classifier_stmtContext)
}

func (s *Sql_stmt_coreContext) Drop_resource_pool_classifier_stmt() IDrop_resource_pool_classifier_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_resource_pool_classifier_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_resource_pool_classifier_stmtContext)
}

func (s *Sql_stmt_coreContext) Backup_stmt() IBackup_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackup_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackup_stmtContext)
}

func (s *Sql_stmt_coreContext) Restore_stmt() IRestore_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRestore_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRestore_stmtContext)
}

func (s *Sql_stmt_coreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sql_stmt_coreContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sql_stmt_coreContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSql_stmt_core(s)
	}
}

func (s *Sql_stmt_coreContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSql_stmt_core(s)
	}
}

func (p *SQLv1Antlr4Parser) Sql_stmt_core() (localctx ISql_stmt_coreContext) {
	localctx = NewSql_stmt_coreContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, SQLv1Antlr4ParserRULE_sql_stmt_core)
	p.SetState(991)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(935)
			p.Pragma_stmt()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(936)
			p.Select_stmt()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(937)
			p.Named_nodes_stmt()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(938)
			p.Create_table_stmt()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(939)
			p.Drop_table_stmt()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(940)
			p.Use_stmt()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(941)
			p.Into_table_stmt()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(942)
			p.Commit_stmt()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(943)
			p.Update_stmt()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(944)
			p.Delete_stmt()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(945)
			p.Rollback_stmt()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(946)
			p.Declare_stmt()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(947)
			p.Import_stmt()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(948)
			p.Export_stmt()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(949)
			p.Alter_table_stmt()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(950)
			p.Alter_external_table_stmt()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(951)
			p.Do_stmt()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(952)
			p.Define_action_or_subquery_stmt()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(953)
			p.If_stmt()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(954)
			p.For_stmt()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(955)
			p.Values_stmt()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(956)
			p.Create_user_stmt()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(957)
			p.Alter_user_stmt()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(958)
			p.Create_group_stmt()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(959)
			p.Alter_group_stmt()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(960)
			p.Drop_role_stmt()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(961)
			p.Create_object_stmt()
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(962)
			p.Alter_object_stmt()
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(963)
			p.Drop_object_stmt()
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(964)
			p.Create_external_data_source_stmt()
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(965)
			p.Alter_external_data_source_stmt()
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(966)
			p.Drop_external_data_source_stmt()
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(967)
			p.Create_replication_stmt()
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(968)
			p.Drop_replication_stmt()
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(969)
			p.Create_topic_stmt()
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(970)
			p.Alter_topic_stmt()
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(971)
			p.Drop_topic_stmt()
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(972)
			p.Grant_permissions_stmt()
		}

	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(973)
			p.Revoke_permissions_stmt()
		}

	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(974)
			p.Alter_table_store_stmt()
		}

	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(975)
			p.Upsert_object_stmt()
		}

	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(976)
			p.Create_view_stmt()
		}

	case 43:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(977)
			p.Drop_view_stmt()
		}

	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(978)
			p.Alter_replication_stmt()
		}

	case 45:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(979)
			p.Create_resource_pool_stmt()
		}

	case 46:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(980)
			p.Alter_resource_pool_stmt()
		}

	case 47:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(981)
			p.Drop_resource_pool_stmt()
		}

	case 48:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(982)
			p.Create_backup_collection_stmt()
		}

	case 49:
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(983)
			p.Alter_backup_collection_stmt()
		}

	case 50:
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(984)
			p.Drop_backup_collection_stmt()
		}

	case 51:
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(985)
			p.Analyze_stmt()
		}

	case 52:
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(986)
			p.Create_resource_pool_classifier_stmt()
		}

	case 53:
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(987)
			p.Alter_resource_pool_classifier_stmt()
		}

	case 54:
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(988)
			p.Drop_resource_pool_classifier_stmt()
		}

	case 55:
		p.EnterOuterAlt(localctx, 55)
		{
			p.SetState(989)
			p.Backup_stmt()
		}

	case 56:
		p.EnterOuterAlt(localctx, 56)
		{
			p.SetState(990)
			p.Restore_stmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllOr_subexpr() []IOr_subexprContext
	Or_subexpr(i int) IOr_subexprContext
	AllOR() []antlr.TerminalNode
	OR(i int) antlr.TerminalNode
	Type_name_composite() IType_name_compositeContext

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_expr
	return p
}

func InitEmptyExprContext(p *ExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_expr
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) AllOr_subexpr() []IOr_subexprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOr_subexprContext); ok {
			len++
		}
	}

	tst := make([]IOr_subexprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOr_subexprContext); ok {
			tst[i] = t.(IOr_subexprContext)
			i++
		}
	}

	return tst
}

func (s *ExprContext) Or_subexpr(i int) IOr_subexprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOr_subexprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOr_subexprContext)
}

func (s *ExprContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserOR)
}

func (s *ExprContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOR, i)
}

func (s *ExprContext) Type_name_composite() IType_name_compositeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_compositeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_compositeContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitExpr(s)
	}
}

func (p *SQLv1Antlr4Parser) Expr() (localctx IExprContext) {
	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SQLv1Antlr4ParserRULE_expr)
	var _alt int

	p.SetState(1002)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(993)
			p.Or_subexpr()
		}
		p.SetState(998)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(994)
					p.Match(SQLv1Antlr4ParserOR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(995)
					p.Or_subexpr()
				}

			}
			p.SetState(1000)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1001)
			p.Type_name_composite()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOr_subexprContext is an interface to support dynamic dispatch.
type IOr_subexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAnd_subexpr() []IAnd_subexprContext
	And_subexpr(i int) IAnd_subexprContext
	AllAND() []antlr.TerminalNode
	AND(i int) antlr.TerminalNode

	// IsOr_subexprContext differentiates from other interfaces.
	IsOr_subexprContext()
}

type Or_subexprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOr_subexprContext() *Or_subexprContext {
	var p = new(Or_subexprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_or_subexpr
	return p
}

func InitEmptyOr_subexprContext(p *Or_subexprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_or_subexpr
}

func (*Or_subexprContext) IsOr_subexprContext() {}

func NewOr_subexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Or_subexprContext {
	var p = new(Or_subexprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_or_subexpr

	return p
}

func (s *Or_subexprContext) GetParser() antlr.Parser { return s.parser }

func (s *Or_subexprContext) AllAnd_subexpr() []IAnd_subexprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnd_subexprContext); ok {
			len++
		}
	}

	tst := make([]IAnd_subexprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnd_subexprContext); ok {
			tst[i] = t.(IAnd_subexprContext)
			i++
		}
	}

	return tst
}

func (s *Or_subexprContext) And_subexpr(i int) IAnd_subexprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnd_subexprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnd_subexprContext)
}

func (s *Or_subexprContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserAND)
}

func (s *Or_subexprContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAND, i)
}

func (s *Or_subexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Or_subexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Or_subexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterOr_subexpr(s)
	}
}

func (s *Or_subexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitOr_subexpr(s)
	}
}

func (p *SQLv1Antlr4Parser) Or_subexpr() (localctx IOr_subexprContext) {
	localctx = NewOr_subexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SQLv1Antlr4ParserRULE_or_subexpr)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1004)
		p.And_subexpr()
	}
	p.SetState(1009)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1005)
				p.Match(SQLv1Antlr4ParserAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1006)
				p.And_subexpr()
			}

		}
		p.SetState(1011)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnd_subexprContext is an interface to support dynamic dispatch.
type IAnd_subexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllXor_subexpr() []IXor_subexprContext
	Xor_subexpr(i int) IXor_subexprContext
	AllXOR() []antlr.TerminalNode
	XOR(i int) antlr.TerminalNode

	// IsAnd_subexprContext differentiates from other interfaces.
	IsAnd_subexprContext()
}

type And_subexprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnd_subexprContext() *And_subexprContext {
	var p = new(And_subexprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_and_subexpr
	return p
}

func InitEmptyAnd_subexprContext(p *And_subexprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_and_subexpr
}

func (*And_subexprContext) IsAnd_subexprContext() {}

func NewAnd_subexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *And_subexprContext {
	var p = new(And_subexprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_and_subexpr

	return p
}

func (s *And_subexprContext) GetParser() antlr.Parser { return s.parser }

func (s *And_subexprContext) AllXor_subexpr() []IXor_subexprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IXor_subexprContext); ok {
			len++
		}
	}

	tst := make([]IXor_subexprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IXor_subexprContext); ok {
			tst[i] = t.(IXor_subexprContext)
			i++
		}
	}

	return tst
}

func (s *And_subexprContext) Xor_subexpr(i int) IXor_subexprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXor_subexprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXor_subexprContext)
}

func (s *And_subexprContext) AllXOR() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserXOR)
}

func (s *And_subexprContext) XOR(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserXOR, i)
}

func (s *And_subexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *And_subexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *And_subexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAnd_subexpr(s)
	}
}

func (s *And_subexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAnd_subexpr(s)
	}
}

func (p *SQLv1Antlr4Parser) And_subexpr() (localctx IAnd_subexprContext) {
	localctx = NewAnd_subexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, SQLv1Antlr4ParserRULE_and_subexpr)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1012)
		p.Xor_subexpr()
	}
	p.SetState(1017)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1013)
				p.Match(SQLv1Antlr4ParserXOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1014)
				p.Xor_subexpr()
			}

		}
		p.SetState(1019)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXor_subexprContext is an interface to support dynamic dispatch.
type IXor_subexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Eq_subexpr() IEq_subexprContext
	Cond_expr() ICond_exprContext

	// IsXor_subexprContext differentiates from other interfaces.
	IsXor_subexprContext()
}

type Xor_subexprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXor_subexprContext() *Xor_subexprContext {
	var p = new(Xor_subexprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_xor_subexpr
	return p
}

func InitEmptyXor_subexprContext(p *Xor_subexprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_xor_subexpr
}

func (*Xor_subexprContext) IsXor_subexprContext() {}

func NewXor_subexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Xor_subexprContext {
	var p = new(Xor_subexprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_xor_subexpr

	return p
}

func (s *Xor_subexprContext) GetParser() antlr.Parser { return s.parser }

func (s *Xor_subexprContext) Eq_subexpr() IEq_subexprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEq_subexprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEq_subexprContext)
}

func (s *Xor_subexprContext) Cond_expr() ICond_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICond_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICond_exprContext)
}

func (s *Xor_subexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Xor_subexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Xor_subexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterXor_subexpr(s)
	}
}

func (s *Xor_subexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitXor_subexpr(s)
	}
}

func (p *SQLv1Antlr4Parser) Xor_subexpr() (localctx IXor_subexprContext) {
	localctx = NewXor_subexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, SQLv1Antlr4ParserRULE_xor_subexpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1020)
		p.Eq_subexpr()
	}
	p.SetState(1022)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1021)
			p.Cond_expr()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDistinct_from_opContext is an interface to support dynamic dispatch.
type IDistinct_from_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IS() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	FROM() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsDistinct_from_opContext differentiates from other interfaces.
	IsDistinct_from_opContext()
}

type Distinct_from_opContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistinct_from_opContext() *Distinct_from_opContext {
	var p = new(Distinct_from_opContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_distinct_from_op
	return p
}

func InitEmptyDistinct_from_opContext(p *Distinct_from_opContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_distinct_from_op
}

func (*Distinct_from_opContext) IsDistinct_from_opContext() {}

func NewDistinct_from_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Distinct_from_opContext {
	var p = new(Distinct_from_opContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_distinct_from_op

	return p
}

func (s *Distinct_from_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Distinct_from_opContext) IS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIS, 0)
}

func (s *Distinct_from_opContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDISTINCT, 0)
}

func (s *Distinct_from_opContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFROM, 0)
}

func (s *Distinct_from_opContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNOT, 0)
}

func (s *Distinct_from_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Distinct_from_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Distinct_from_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterDistinct_from_op(s)
	}
}

func (s *Distinct_from_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitDistinct_from_op(s)
	}
}

func (p *SQLv1Antlr4Parser) Distinct_from_op() (localctx IDistinct_from_opContext) {
	localctx = NewDistinct_from_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SQLv1Antlr4ParserRULE_distinct_from_op)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1024)
		p.Match(SQLv1Antlr4ParserIS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1026)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserNOT {
		{
			p.SetState(1025)
			p.Match(SQLv1Antlr4ParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1028)
		p.Match(SQLv1Antlr4ParserDISTINCT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1029)
		p.Match(SQLv1Antlr4ParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICond_exprContext is an interface to support dynamic dispatch.
type ICond_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Match_op() IMatch_opContext
	AllEq_subexpr() []IEq_subexprContext
	Eq_subexpr(i int) IEq_subexprContext
	NOT() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	IN() antlr.TerminalNode
	In_expr() IIn_exprContext
	COMPACT() antlr.TerminalNode
	ISNULL() antlr.TerminalNode
	NOTNULL() antlr.TerminalNode
	IS() antlr.TerminalNode
	NULL() antlr.TerminalNode
	BETWEEN() antlr.TerminalNode
	AND() antlr.TerminalNode
	SYMMETRIC() antlr.TerminalNode
	ASYMMETRIC() antlr.TerminalNode
	AllEQUALS() []antlr.TerminalNode
	EQUALS(i int) antlr.TerminalNode
	AllEQUALS2() []antlr.TerminalNode
	EQUALS2(i int) antlr.TerminalNode
	AllNOT_EQUALS() []antlr.TerminalNode
	NOT_EQUALS(i int) antlr.TerminalNode
	AllNOT_EQUALS2() []antlr.TerminalNode
	NOT_EQUALS2(i int) antlr.TerminalNode
	AllDistinct_from_op() []IDistinct_from_opContext
	Distinct_from_op(i int) IDistinct_from_opContext

	// IsCond_exprContext differentiates from other interfaces.
	IsCond_exprContext()
}

type Cond_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCond_exprContext() *Cond_exprContext {
	var p = new(Cond_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_cond_expr
	return p
}

func InitEmptyCond_exprContext(p *Cond_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_cond_expr
}

func (*Cond_exprContext) IsCond_exprContext() {}

func NewCond_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cond_exprContext {
	var p = new(Cond_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_cond_expr

	return p
}

func (s *Cond_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Cond_exprContext) Match_op() IMatch_opContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatch_opContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatch_opContext)
}

func (s *Cond_exprContext) AllEq_subexpr() []IEq_subexprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEq_subexprContext); ok {
			len++
		}
	}

	tst := make([]IEq_subexprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEq_subexprContext); ok {
			tst[i] = t.(IEq_subexprContext)
			i++
		}
	}

	return tst
}

func (s *Cond_exprContext) Eq_subexpr(i int) IEq_subexprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEq_subexprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEq_subexprContext)
}

func (s *Cond_exprContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNOT, 0)
}

func (s *Cond_exprContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserESCAPE, 0)
}

func (s *Cond_exprContext) IN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIN, 0)
}

func (s *Cond_exprContext) In_expr() IIn_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIn_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIn_exprContext)
}

func (s *Cond_exprContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMPACT, 0)
}

func (s *Cond_exprContext) ISNULL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserISNULL, 0)
}

func (s *Cond_exprContext) NOTNULL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNOTNULL, 0)
}

func (s *Cond_exprContext) IS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIS, 0)
}

func (s *Cond_exprContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNULL, 0)
}

func (s *Cond_exprContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserBETWEEN, 0)
}

func (s *Cond_exprContext) AND() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAND, 0)
}

func (s *Cond_exprContext) SYMMETRIC() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSYMMETRIC, 0)
}

func (s *Cond_exprContext) ASYMMETRIC() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserASYMMETRIC, 0)
}

func (s *Cond_exprContext) AllEQUALS() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserEQUALS)
}

func (s *Cond_exprContext) EQUALS(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEQUALS, i)
}

func (s *Cond_exprContext) AllEQUALS2() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserEQUALS2)
}

func (s *Cond_exprContext) EQUALS2(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEQUALS2, i)
}

func (s *Cond_exprContext) AllNOT_EQUALS() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserNOT_EQUALS)
}

func (s *Cond_exprContext) NOT_EQUALS(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNOT_EQUALS, i)
}

func (s *Cond_exprContext) AllNOT_EQUALS2() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserNOT_EQUALS2)
}

func (s *Cond_exprContext) NOT_EQUALS2(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNOT_EQUALS2, i)
}

func (s *Cond_exprContext) AllDistinct_from_op() []IDistinct_from_opContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDistinct_from_opContext); ok {
			len++
		}
	}

	tst := make([]IDistinct_from_opContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDistinct_from_opContext); ok {
			tst[i] = t.(IDistinct_from_opContext)
			i++
		}
	}

	return tst
}

func (s *Cond_exprContext) Distinct_from_op(i int) IDistinct_from_opContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistinct_from_opContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistinct_from_opContext)
}

func (s *Cond_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cond_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cond_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterCond_expr(s)
	}
}

func (s *Cond_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitCond_expr(s)
	}
}

func (p *SQLv1Antlr4Parser) Cond_expr() (localctx ICond_exprContext) {
	localctx = NewCond_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SQLv1Antlr4ParserRULE_cond_expr)
	var _la int

	var _alt int

	p.SetState(1082)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1032)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserNOT {
			{
				p.SetState(1031)
				p.Match(SQLv1Antlr4ParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1034)
			p.Match_op()
		}
		{
			p.SetState(1035)
			p.Eq_subexpr()
		}
		p.SetState(1038)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1036)
				p.Match(SQLv1Antlr4ParserESCAPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1037)
				p.Eq_subexpr()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1041)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserNOT {
			{
				p.SetState(1040)
				p.Match(SQLv1Antlr4ParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1043)
			p.Match(SQLv1Antlr4ParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1045)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1044)
				p.Match(SQLv1Antlr4ParserCOMPACT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1047)
			p.In_expr()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1057)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1048)
				p.Match(SQLv1Antlr4ParserISNULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(1049)
				p.Match(SQLv1Antlr4ParserNOTNULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(1050)
				p.Match(SQLv1Antlr4ParserIS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1051)
				p.Match(SQLv1Antlr4ParserNULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 4:
			p.SetState(1053)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SQLv1Antlr4ParserIS {
				{
					p.SetState(1052)
					p.Match(SQLv1Antlr4ParserIS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1055)
				p.Match(SQLv1Antlr4ParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1056)
				p.Match(SQLv1Antlr4ParserNULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1060)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserNOT {
			{
				p.SetState(1059)
				p.Match(SQLv1Antlr4ParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1062)
			p.Match(SQLv1Antlr4ParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1064)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1063)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SQLv1Antlr4ParserASYMMETRIC || _la == SQLv1Antlr4ParserSYMMETRIC) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1066)
			p.Eq_subexpr()
		}
		{
			p.SetState(1067)
			p.Match(SQLv1Antlr4ParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1068)
			p.Eq_subexpr()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(1078)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				p.SetState(1075)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case SQLv1Antlr4ParserEQUALS:
					{
						p.SetState(1070)
						p.Match(SQLv1Antlr4ParserEQUALS)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case SQLv1Antlr4ParserEQUALS2:
					{
						p.SetState(1071)
						p.Match(SQLv1Antlr4ParserEQUALS2)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case SQLv1Antlr4ParserNOT_EQUALS:
					{
						p.SetState(1072)
						p.Match(SQLv1Antlr4ParserNOT_EQUALS)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case SQLv1Antlr4ParserNOT_EQUALS2:
					{
						p.SetState(1073)
						p.Match(SQLv1Antlr4ParserNOT_EQUALS2)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case SQLv1Antlr4ParserIS:
					{
						p.SetState(1074)
						p.Distinct_from_op()
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}
				{
					p.SetState(1077)
					p.Eq_subexpr()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(1080)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatch_opContext is an interface to support dynamic dispatch.
type IMatch_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIKE() antlr.TerminalNode
	ILIKE() antlr.TerminalNode
	GLOB() antlr.TerminalNode
	REGEXP() antlr.TerminalNode
	RLIKE() antlr.TerminalNode
	MATCH() antlr.TerminalNode

	// IsMatch_opContext differentiates from other interfaces.
	IsMatch_opContext()
}

type Match_opContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatch_opContext() *Match_opContext {
	var p = new(Match_opContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_match_op
	return p
}

func InitEmptyMatch_opContext(p *Match_opContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_match_op
}

func (*Match_opContext) IsMatch_opContext() {}

func NewMatch_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Match_opContext {
	var p = new(Match_opContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_match_op

	return p
}

func (s *Match_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Match_opContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLIKE, 0)
}

func (s *Match_opContext) ILIKE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserILIKE, 0)
}

func (s *Match_opContext) GLOB() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGLOB, 0)
}

func (s *Match_opContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREGEXP, 0)
}

func (s *Match_opContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRLIKE, 0)
}

func (s *Match_opContext) MATCH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMATCH, 0)
}

func (s *Match_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Match_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Match_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterMatch_op(s)
	}
}

func (s *Match_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitMatch_op(s)
	}
}

func (p *SQLv1Antlr4Parser) Match_op() (localctx IMatch_opContext) {
	localctx = NewMatch_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SQLv1Antlr4ParserRULE_match_op)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1084)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-148)) & ^0x3f) == 0 && ((int64(1)<<(_la-148))&2267742734337) != 0) || _la == SQLv1Antlr4ParserREGEXP || _la == SQLv1Antlr4ParserRLIKE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEq_subexprContext is an interface to support dynamic dispatch.
type IEq_subexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNeq_subexpr() []INeq_subexprContext
	Neq_subexpr(i int) INeq_subexprContext
	AllLESS() []antlr.TerminalNode
	LESS(i int) antlr.TerminalNode
	AllLESS_OR_EQ() []antlr.TerminalNode
	LESS_OR_EQ(i int) antlr.TerminalNode
	AllGREATER() []antlr.TerminalNode
	GREATER(i int) antlr.TerminalNode
	AllGREATER_OR_EQ() []antlr.TerminalNode
	GREATER_OR_EQ(i int) antlr.TerminalNode

	// IsEq_subexprContext differentiates from other interfaces.
	IsEq_subexprContext()
}

type Eq_subexprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEq_subexprContext() *Eq_subexprContext {
	var p = new(Eq_subexprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_eq_subexpr
	return p
}

func InitEmptyEq_subexprContext(p *Eq_subexprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_eq_subexpr
}

func (*Eq_subexprContext) IsEq_subexprContext() {}

func NewEq_subexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Eq_subexprContext {
	var p = new(Eq_subexprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_eq_subexpr

	return p
}

func (s *Eq_subexprContext) GetParser() antlr.Parser { return s.parser }

func (s *Eq_subexprContext) AllNeq_subexpr() []INeq_subexprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INeq_subexprContext); ok {
			len++
		}
	}

	tst := make([]INeq_subexprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INeq_subexprContext); ok {
			tst[i] = t.(INeq_subexprContext)
			i++
		}
	}

	return tst
}

func (s *Eq_subexprContext) Neq_subexpr(i int) INeq_subexprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INeq_subexprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INeq_subexprContext)
}

func (s *Eq_subexprContext) AllLESS() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserLESS)
}

func (s *Eq_subexprContext) LESS(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLESS, i)
}

func (s *Eq_subexprContext) AllLESS_OR_EQ() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserLESS_OR_EQ)
}

func (s *Eq_subexprContext) LESS_OR_EQ(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLESS_OR_EQ, i)
}

func (s *Eq_subexprContext) AllGREATER() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserGREATER)
}

func (s *Eq_subexprContext) GREATER(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGREATER, i)
}

func (s *Eq_subexprContext) AllGREATER_OR_EQ() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserGREATER_OR_EQ)
}

func (s *Eq_subexprContext) GREATER_OR_EQ(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGREATER_OR_EQ, i)
}

func (s *Eq_subexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Eq_subexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Eq_subexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterEq_subexpr(s)
	}
}

func (s *Eq_subexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitEq_subexpr(s)
	}
}

func (p *SQLv1Antlr4Parser) Eq_subexpr() (localctx IEq_subexprContext) {
	localctx = NewEq_subexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SQLv1Antlr4ParserRULE_eq_subexpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1086)
		p.Neq_subexpr()
	}
	p.SetState(1091)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&480) != 0 {
		{
			p.SetState(1087)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&480) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1088)
			p.Neq_subexpr()
		}

		p.SetState(1093)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShift_rightContext is an interface to support dynamic dispatch.
type IShift_rightContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGREATER() []antlr.TerminalNode
	GREATER(i int) antlr.TerminalNode

	// IsShift_rightContext differentiates from other interfaces.
	IsShift_rightContext()
}

type Shift_rightContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShift_rightContext() *Shift_rightContext {
	var p = new(Shift_rightContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_shift_right
	return p
}

func InitEmptyShift_rightContext(p *Shift_rightContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_shift_right
}

func (*Shift_rightContext) IsShift_rightContext() {}

func NewShift_rightContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Shift_rightContext {
	var p = new(Shift_rightContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_shift_right

	return p
}

func (s *Shift_rightContext) GetParser() antlr.Parser { return s.parser }

func (s *Shift_rightContext) AllGREATER() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserGREATER)
}

func (s *Shift_rightContext) GREATER(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGREATER, i)
}

func (s *Shift_rightContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Shift_rightContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Shift_rightContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterShift_right(s)
	}
}

func (s *Shift_rightContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitShift_right(s)
	}
}

func (p *SQLv1Antlr4Parser) Shift_right() (localctx IShift_rightContext) {
	localctx = NewShift_rightContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SQLv1Antlr4ParserRULE_shift_right)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1094)
		p.Match(SQLv1Antlr4ParserGREATER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1095)
		p.Match(SQLv1Antlr4ParserGREATER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRot_rightContext is an interface to support dynamic dispatch.
type IRot_rightContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGREATER() []antlr.TerminalNode
	GREATER(i int) antlr.TerminalNode
	PIPE() antlr.TerminalNode

	// IsRot_rightContext differentiates from other interfaces.
	IsRot_rightContext()
}

type Rot_rightContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRot_rightContext() *Rot_rightContext {
	var p = new(Rot_rightContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_rot_right
	return p
}

func InitEmptyRot_rightContext(p *Rot_rightContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_rot_right
}

func (*Rot_rightContext) IsRot_rightContext() {}

func NewRot_rightContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rot_rightContext {
	var p = new(Rot_rightContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_rot_right

	return p
}

func (s *Rot_rightContext) GetParser() antlr.Parser { return s.parser }

func (s *Rot_rightContext) AllGREATER() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserGREATER)
}

func (s *Rot_rightContext) GREATER(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGREATER, i)
}

func (s *Rot_rightContext) PIPE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPIPE, 0)
}

func (s *Rot_rightContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rot_rightContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rot_rightContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRot_right(s)
	}
}

func (s *Rot_rightContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRot_right(s)
	}
}

func (p *SQLv1Antlr4Parser) Rot_right() (localctx IRot_rightContext) {
	localctx = NewRot_rightContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, SQLv1Antlr4ParserRULE_rot_right)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1097)
		p.Match(SQLv1Antlr4ParserGREATER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1098)
		p.Match(SQLv1Antlr4ParserGREATER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1099)
		p.Match(SQLv1Antlr4ParserPIPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDouble_questionContext is an interface to support dynamic dispatch.
type IDouble_questionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllQUESTION() []antlr.TerminalNode
	QUESTION(i int) antlr.TerminalNode

	// IsDouble_questionContext differentiates from other interfaces.
	IsDouble_questionContext()
}

type Double_questionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDouble_questionContext() *Double_questionContext {
	var p = new(Double_questionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_double_question
	return p
}

func InitEmptyDouble_questionContext(p *Double_questionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_double_question
}

func (*Double_questionContext) IsDouble_questionContext() {}

func NewDouble_questionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Double_questionContext {
	var p = new(Double_questionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_double_question

	return p
}

func (s *Double_questionContext) GetParser() antlr.Parser { return s.parser }

func (s *Double_questionContext) AllQUESTION() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserQUESTION)
}

func (s *Double_questionContext) QUESTION(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserQUESTION, i)
}

func (s *Double_questionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Double_questionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Double_questionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterDouble_question(s)
	}
}

func (s *Double_questionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitDouble_question(s)
	}
}

func (p *SQLv1Antlr4Parser) Double_question() (localctx IDouble_questionContext) {
	localctx = NewDouble_questionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SQLv1Antlr4ParserRULE_double_question)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1101)
		p.Match(SQLv1Antlr4ParserQUESTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1102)
		p.Match(SQLv1Antlr4ParserQUESTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INeq_subexprContext is an interface to support dynamic dispatch.
type INeq_subexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBit_subexpr() []IBit_subexprContext
	Bit_subexpr(i int) IBit_subexprContext
	Double_question() IDouble_questionContext
	Neq_subexpr() INeq_subexprContext
	AllSHIFT_LEFT() []antlr.TerminalNode
	SHIFT_LEFT(i int) antlr.TerminalNode
	AllShift_right() []IShift_rightContext
	Shift_right(i int) IShift_rightContext
	AllROT_LEFT() []antlr.TerminalNode
	ROT_LEFT(i int) antlr.TerminalNode
	AllRot_right() []IRot_rightContext
	Rot_right(i int) IRot_rightContext
	AllAMPERSAND() []antlr.TerminalNode
	AMPERSAND(i int) antlr.TerminalNode
	AllPIPE() []antlr.TerminalNode
	PIPE(i int) antlr.TerminalNode
	AllCARET() []antlr.TerminalNode
	CARET(i int) antlr.TerminalNode
	AllQUESTION() []antlr.TerminalNode
	QUESTION(i int) antlr.TerminalNode

	// IsNeq_subexprContext differentiates from other interfaces.
	IsNeq_subexprContext()
}

type Neq_subexprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNeq_subexprContext() *Neq_subexprContext {
	var p = new(Neq_subexprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_neq_subexpr
	return p
}

func InitEmptyNeq_subexprContext(p *Neq_subexprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_neq_subexpr
}

func (*Neq_subexprContext) IsNeq_subexprContext() {}

func NewNeq_subexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Neq_subexprContext {
	var p = new(Neq_subexprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_neq_subexpr

	return p
}

func (s *Neq_subexprContext) GetParser() antlr.Parser { return s.parser }

func (s *Neq_subexprContext) AllBit_subexpr() []IBit_subexprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBit_subexprContext); ok {
			len++
		}
	}

	tst := make([]IBit_subexprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBit_subexprContext); ok {
			tst[i] = t.(IBit_subexprContext)
			i++
		}
	}

	return tst
}

func (s *Neq_subexprContext) Bit_subexpr(i int) IBit_subexprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBit_subexprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBit_subexprContext)
}

func (s *Neq_subexprContext) Double_question() IDouble_questionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDouble_questionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDouble_questionContext)
}

func (s *Neq_subexprContext) Neq_subexpr() INeq_subexprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INeq_subexprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INeq_subexprContext)
}

func (s *Neq_subexprContext) AllSHIFT_LEFT() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserSHIFT_LEFT)
}

func (s *Neq_subexprContext) SHIFT_LEFT(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSHIFT_LEFT, i)
}

func (s *Neq_subexprContext) AllShift_right() []IShift_rightContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IShift_rightContext); ok {
			len++
		}
	}

	tst := make([]IShift_rightContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IShift_rightContext); ok {
			tst[i] = t.(IShift_rightContext)
			i++
		}
	}

	return tst
}

func (s *Neq_subexprContext) Shift_right(i int) IShift_rightContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShift_rightContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShift_rightContext)
}

func (s *Neq_subexprContext) AllROT_LEFT() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserROT_LEFT)
}

func (s *Neq_subexprContext) ROT_LEFT(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserROT_LEFT, i)
}

func (s *Neq_subexprContext) AllRot_right() []IRot_rightContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRot_rightContext); ok {
			len++
		}
	}

	tst := make([]IRot_rightContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRot_rightContext); ok {
			tst[i] = t.(IRot_rightContext)
			i++
		}
	}

	return tst
}

func (s *Neq_subexprContext) Rot_right(i int) IRot_rightContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRot_rightContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRot_rightContext)
}

func (s *Neq_subexprContext) AllAMPERSAND() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserAMPERSAND)
}

func (s *Neq_subexprContext) AMPERSAND(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAMPERSAND, i)
}

func (s *Neq_subexprContext) AllPIPE() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserPIPE)
}

func (s *Neq_subexprContext) PIPE(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPIPE, i)
}

func (s *Neq_subexprContext) AllCARET() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCARET)
}

func (s *Neq_subexprContext) CARET(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCARET, i)
}

func (s *Neq_subexprContext) AllQUESTION() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserQUESTION)
}

func (s *Neq_subexprContext) QUESTION(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserQUESTION, i)
}

func (s *Neq_subexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Neq_subexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Neq_subexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterNeq_subexpr(s)
	}
}

func (s *Neq_subexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitNeq_subexpr(s)
	}
}

func (p *SQLv1Antlr4Parser) Neq_subexpr() (localctx INeq_subexprContext) {
	localctx = NewNeq_subexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SQLv1Antlr4ParserRULE_neq_subexpr)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1104)
		p.Bit_subexpr()
	}
	p.SetState(1117)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1112)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1105)
					p.Match(SQLv1Antlr4ParserSHIFT_LEFT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				{
					p.SetState(1106)
					p.Shift_right()
				}

			case 3:
				{
					p.SetState(1107)
					p.Match(SQLv1Antlr4ParserROT_LEFT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 4:
				{
					p.SetState(1108)
					p.Rot_right()
				}

			case 5:
				{
					p.SetState(1109)
					p.Match(SQLv1Antlr4ParserAMPERSAND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 6:
				{
					p.SetState(1110)
					p.Match(SQLv1Antlr4ParserPIPE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 7:
				{
					p.SetState(1111)
					p.Match(SQLv1Antlr4ParserCARET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}
			{
				p.SetState(1114)
				p.Bit_subexpr()
			}

		}
		p.SetState(1119)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1128)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1120)
			p.Double_question()
		}
		{
			p.SetState(1121)
			p.Neq_subexpr()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) == 2 {
		p.SetState(1124)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SQLv1Antlr4ParserQUESTION {
			{
				p.SetState(1123)
				p.Match(SQLv1Antlr4ParserQUESTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1126)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBit_subexprContext is an interface to support dynamic dispatch.
type IBit_subexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAdd_subexpr() []IAdd_subexprContext
	Add_subexpr(i int) IAdd_subexprContext
	AllPLUS() []antlr.TerminalNode
	PLUS(i int) antlr.TerminalNode
	AllMINUS() []antlr.TerminalNode
	MINUS(i int) antlr.TerminalNode

	// IsBit_subexprContext differentiates from other interfaces.
	IsBit_subexprContext()
}

type Bit_subexprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBit_subexprContext() *Bit_subexprContext {
	var p = new(Bit_subexprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_bit_subexpr
	return p
}

func InitEmptyBit_subexprContext(p *Bit_subexprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_bit_subexpr
}

func (*Bit_subexprContext) IsBit_subexprContext() {}

func NewBit_subexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bit_subexprContext {
	var p = new(Bit_subexprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_bit_subexpr

	return p
}

func (s *Bit_subexprContext) GetParser() antlr.Parser { return s.parser }

func (s *Bit_subexprContext) AllAdd_subexpr() []IAdd_subexprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAdd_subexprContext); ok {
			len++
		}
	}

	tst := make([]IAdd_subexprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAdd_subexprContext); ok {
			tst[i] = t.(IAdd_subexprContext)
			i++
		}
	}

	return tst
}

func (s *Bit_subexprContext) Add_subexpr(i int) IAdd_subexprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdd_subexprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdd_subexprContext)
}

func (s *Bit_subexprContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserPLUS)
}

func (s *Bit_subexprContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPLUS, i)
}

func (s *Bit_subexprContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserMINUS)
}

func (s *Bit_subexprContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMINUS, i)
}

func (s *Bit_subexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bit_subexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bit_subexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterBit_subexpr(s)
	}
}

func (s *Bit_subexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitBit_subexpr(s)
	}
}

func (p *SQLv1Antlr4Parser) Bit_subexpr() (localctx IBit_subexprContext) {
	localctx = NewBit_subexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SQLv1Antlr4ParserRULE_bit_subexpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1130)
		p.Add_subexpr()
	}
	p.SetState(1135)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserPLUS || _la == SQLv1Antlr4ParserMINUS {
		{
			p.SetState(1131)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLv1Antlr4ParserPLUS || _la == SQLv1Antlr4ParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1132)
			p.Add_subexpr()
		}

		p.SetState(1137)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdd_subexprContext is an interface to support dynamic dispatch.
type IAdd_subexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMul_subexpr() []IMul_subexprContext
	Mul_subexpr(i int) IMul_subexprContext
	AllASTERISK() []antlr.TerminalNode
	ASTERISK(i int) antlr.TerminalNode
	AllSLASH() []antlr.TerminalNode
	SLASH(i int) antlr.TerminalNode
	AllPERCENT() []antlr.TerminalNode
	PERCENT(i int) antlr.TerminalNode

	// IsAdd_subexprContext differentiates from other interfaces.
	IsAdd_subexprContext()
}

type Add_subexprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdd_subexprContext() *Add_subexprContext {
	var p = new(Add_subexprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_add_subexpr
	return p
}

func InitEmptyAdd_subexprContext(p *Add_subexprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_add_subexpr
}

func (*Add_subexprContext) IsAdd_subexprContext() {}

func NewAdd_subexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Add_subexprContext {
	var p = new(Add_subexprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_add_subexpr

	return p
}

func (s *Add_subexprContext) GetParser() antlr.Parser { return s.parser }

func (s *Add_subexprContext) AllMul_subexpr() []IMul_subexprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMul_subexprContext); ok {
			len++
		}
	}

	tst := make([]IMul_subexprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMul_subexprContext); ok {
			tst[i] = t.(IMul_subexprContext)
			i++
		}
	}

	return tst
}

func (s *Add_subexprContext) Mul_subexpr(i int) IMul_subexprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMul_subexprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMul_subexprContext)
}

func (s *Add_subexprContext) AllASTERISK() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserASTERISK)
}

func (s *Add_subexprContext) ASTERISK(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserASTERISK, i)
}

func (s *Add_subexprContext) AllSLASH() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserSLASH)
}

func (s *Add_subexprContext) SLASH(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSLASH, i)
}

func (s *Add_subexprContext) AllPERCENT() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserPERCENT)
}

func (s *Add_subexprContext) PERCENT(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPERCENT, i)
}

func (s *Add_subexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Add_subexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Add_subexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAdd_subexpr(s)
	}
}

func (s *Add_subexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAdd_subexpr(s)
	}
}

func (p *SQLv1Antlr4Parser) Add_subexpr() (localctx IAdd_subexprContext) {
	localctx = NewAdd_subexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, SQLv1Antlr4ParserRULE_add_subexpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1138)
		p.Mul_subexpr()
	}
	p.SetState(1143)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&5767168) != 0 {
		{
			p.SetState(1139)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&5767168) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1140)
			p.Mul_subexpr()
		}

		p.SetState(1145)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMul_subexprContext is an interface to support dynamic dispatch.
type IMul_subexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCon_subexpr() []ICon_subexprContext
	Con_subexpr(i int) ICon_subexprContext
	AllDOUBLE_PIPE() []antlr.TerminalNode
	DOUBLE_PIPE(i int) antlr.TerminalNode

	// IsMul_subexprContext differentiates from other interfaces.
	IsMul_subexprContext()
}

type Mul_subexprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMul_subexprContext() *Mul_subexprContext {
	var p = new(Mul_subexprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_mul_subexpr
	return p
}

func InitEmptyMul_subexprContext(p *Mul_subexprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_mul_subexpr
}

func (*Mul_subexprContext) IsMul_subexprContext() {}

func NewMul_subexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mul_subexprContext {
	var p = new(Mul_subexprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_mul_subexpr

	return p
}

func (s *Mul_subexprContext) GetParser() antlr.Parser { return s.parser }

func (s *Mul_subexprContext) AllCon_subexpr() []ICon_subexprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICon_subexprContext); ok {
			len++
		}
	}

	tst := make([]ICon_subexprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICon_subexprContext); ok {
			tst[i] = t.(ICon_subexprContext)
			i++
		}
	}

	return tst
}

func (s *Mul_subexprContext) Con_subexpr(i int) ICon_subexprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICon_subexprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICon_subexprContext)
}

func (s *Mul_subexprContext) AllDOUBLE_PIPE() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserDOUBLE_PIPE)
}

func (s *Mul_subexprContext) DOUBLE_PIPE(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDOUBLE_PIPE, i)
}

func (s *Mul_subexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mul_subexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mul_subexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterMul_subexpr(s)
	}
}

func (s *Mul_subexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitMul_subexpr(s)
	}
}

func (p *SQLv1Antlr4Parser) Mul_subexpr() (localctx IMul_subexprContext) {
	localctx = NewMul_subexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, SQLv1Antlr4ParserRULE_mul_subexpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1146)
		p.Con_subexpr()
	}
	p.SetState(1151)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserDOUBLE_PIPE {
		{
			p.SetState(1147)
			p.Match(SQLv1Antlr4ParserDOUBLE_PIPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1148)
			p.Con_subexpr()
		}

		p.SetState(1153)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICon_subexprContext is an interface to support dynamic dispatch.
type ICon_subexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Unary_subexpr() IUnary_subexprContext
	Unary_op() IUnary_opContext

	// IsCon_subexprContext differentiates from other interfaces.
	IsCon_subexprContext()
}

type Con_subexprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCon_subexprContext() *Con_subexprContext {
	var p = new(Con_subexprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_con_subexpr
	return p
}

func InitEmptyCon_subexprContext(p *Con_subexprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_con_subexpr
}

func (*Con_subexprContext) IsCon_subexprContext() {}

func NewCon_subexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Con_subexprContext {
	var p = new(Con_subexprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_con_subexpr

	return p
}

func (s *Con_subexprContext) GetParser() antlr.Parser { return s.parser }

func (s *Con_subexprContext) Unary_subexpr() IUnary_subexprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnary_subexprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnary_subexprContext)
}

func (s *Con_subexprContext) Unary_op() IUnary_opContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnary_opContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnary_opContext)
}

func (s *Con_subexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Con_subexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Con_subexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterCon_subexpr(s)
	}
}

func (s *Con_subexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitCon_subexpr(s)
	}
}

func (p *SQLv1Antlr4Parser) Con_subexpr() (localctx ICon_subexprContext) {
	localctx = NewCon_subexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, SQLv1Antlr4ParserRULE_con_subexpr)
	p.SetState(1158)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1154)
			p.Unary_subexpr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1155)
			p.Unary_op()
		}
		{
			p.SetState(1156)
			p.Unary_subexpr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnary_opContext is an interface to support dynamic dispatch.
type IUnary_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	TILDA() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsUnary_opContext differentiates from other interfaces.
	IsUnary_opContext()
}

type Unary_opContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_opContext() *Unary_opContext {
	var p = new(Unary_opContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_unary_op
	return p
}

func InitEmptyUnary_opContext(p *Unary_opContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_unary_op
}

func (*Unary_opContext) IsUnary_opContext() {}

func NewUnary_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_opContext {
	var p = new(Unary_opContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_unary_op

	return p
}

func (s *Unary_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_opContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPLUS, 0)
}

func (s *Unary_opContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMINUS, 0)
}

func (s *Unary_opContext) TILDA() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTILDA, 0)
}

func (s *Unary_opContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNOT, 0)
}

func (s *Unary_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterUnary_op(s)
	}
}

func (s *Unary_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitUnary_op(s)
	}
}

func (p *SQLv1Antlr4Parser) Unary_op() (localctx IUnary_opContext) {
	localctx = NewUnary_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SQLv1Antlr4ParserRULE_unary_op)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1160)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&458752) != 0) || _la == SQLv1Antlr4ParserNOT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnary_subexpr_suffixContext is an interface to support dynamic dispatch.
type IUnary_subexpr_suffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLLATE() antlr.TerminalNode
	An_id() IAn_idContext
	AllKey_expr() []IKey_exprContext
	Key_expr(i int) IKey_exprContext
	AllInvoke_expr() []IInvoke_exprContext
	Invoke_expr(i int) IInvoke_exprContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllBind_parameter() []IBind_parameterContext
	Bind_parameter(i int) IBind_parameterContext
	AllDIGITS() []antlr.TerminalNode
	DIGITS(i int) antlr.TerminalNode
	AllAn_id_or_type() []IAn_id_or_typeContext
	An_id_or_type(i int) IAn_id_or_typeContext

	// IsUnary_subexpr_suffixContext differentiates from other interfaces.
	IsUnary_subexpr_suffixContext()
}

type Unary_subexpr_suffixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_subexpr_suffixContext() *Unary_subexpr_suffixContext {
	var p = new(Unary_subexpr_suffixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_unary_subexpr_suffix
	return p
}

func InitEmptyUnary_subexpr_suffixContext(p *Unary_subexpr_suffixContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_unary_subexpr_suffix
}

func (*Unary_subexpr_suffixContext) IsUnary_subexpr_suffixContext() {}

func NewUnary_subexpr_suffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_subexpr_suffixContext {
	var p = new(Unary_subexpr_suffixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_unary_subexpr_suffix

	return p
}

func (s *Unary_subexpr_suffixContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_subexpr_suffixContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOLLATE, 0)
}

func (s *Unary_subexpr_suffixContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Unary_subexpr_suffixContext) AllKey_expr() []IKey_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKey_exprContext); ok {
			len++
		}
	}

	tst := make([]IKey_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKey_exprContext); ok {
			tst[i] = t.(IKey_exprContext)
			i++
		}
	}

	return tst
}

func (s *Unary_subexpr_suffixContext) Key_expr(i int) IKey_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKey_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKey_exprContext)
}

func (s *Unary_subexpr_suffixContext) AllInvoke_expr() []IInvoke_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInvoke_exprContext); ok {
			len++
		}
	}

	tst := make([]IInvoke_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInvoke_exprContext); ok {
			tst[i] = t.(IInvoke_exprContext)
			i++
		}
	}

	return tst
}

func (s *Unary_subexpr_suffixContext) Invoke_expr(i int) IInvoke_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInvoke_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInvoke_exprContext)
}

func (s *Unary_subexpr_suffixContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserDOT)
}

func (s *Unary_subexpr_suffixContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDOT, i)
}

func (s *Unary_subexpr_suffixContext) AllBind_parameter() []IBind_parameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBind_parameterContext); ok {
			len++
		}
	}

	tst := make([]IBind_parameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBind_parameterContext); ok {
			tst[i] = t.(IBind_parameterContext)
			i++
		}
	}

	return tst
}

func (s *Unary_subexpr_suffixContext) Bind_parameter(i int) IBind_parameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Unary_subexpr_suffixContext) AllDIGITS() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserDIGITS)
}

func (s *Unary_subexpr_suffixContext) DIGITS(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDIGITS, i)
}

func (s *Unary_subexpr_suffixContext) AllAn_id_or_type() []IAn_id_or_typeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			len++
		}
	}

	tst := make([]IAn_id_or_typeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_id_or_typeContext); ok {
			tst[i] = t.(IAn_id_or_typeContext)
			i++
		}
	}

	return tst
}

func (s *Unary_subexpr_suffixContext) An_id_or_type(i int) IAn_id_or_typeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_or_typeContext)
}

func (s *Unary_subexpr_suffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_subexpr_suffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_subexpr_suffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterUnary_subexpr_suffix(s)
	}
}

func (s *Unary_subexpr_suffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitUnary_subexpr_suffix(s)
	}
}

func (p *SQLv1Antlr4Parser) Unary_subexpr_suffix() (localctx IUnary_subexpr_suffixContext) {
	localctx = NewUnary_subexpr_suffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, SQLv1Antlr4ParserRULE_unary_subexpr_suffix)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1174)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4398130397184) != 0 {
		p.SetState(1170)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case SQLv1Antlr4ParserLBRACE_SQUARE:
			{
				p.SetState(1162)
				p.Key_expr()
			}

		case SQLv1Antlr4ParserLPAREN:
			{
				p.SetState(1163)
				p.Invoke_expr()
			}

		case SQLv1Antlr4ParserDOT:
			{
				p.SetState(1164)
				p.Match(SQLv1Antlr4ParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1168)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case SQLv1Antlr4ParserDOLLAR:
				{
					p.SetState(1165)
					p.Bind_parameter()
				}

			case SQLv1Antlr4ParserDIGITS:
				{
					p.SetState(1166)
					p.Match(SQLv1Antlr4ParserDIGITS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALL, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserANY, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCALLABLE, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDICT, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserENUM, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFLOW, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserLIST, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOPTIONAL, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESOURCE, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSET, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSTREAM, SQLv1Antlr4ParserSTRUCT, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTAGGED, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTUPLE, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVARIANT, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWITHOUT, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserSTRING_VALUE, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
				{
					p.SetState(1167)
					p.An_id_or_type()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1176)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1179)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserCOLLATE {
		{
			p.SetState(1177)
			p.Match(SQLv1Antlr4ParserCOLLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1178)
			p.An_id()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnary_casual_subexprContext is an interface to support dynamic dispatch.
type IUnary_casual_subexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Unary_subexpr_suffix() IUnary_subexpr_suffixContext
	Id_expr() IId_exprContext
	Atom_expr() IAtom_exprContext

	// IsUnary_casual_subexprContext differentiates from other interfaces.
	IsUnary_casual_subexprContext()
}

type Unary_casual_subexprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_casual_subexprContext() *Unary_casual_subexprContext {
	var p = new(Unary_casual_subexprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_unary_casual_subexpr
	return p
}

func InitEmptyUnary_casual_subexprContext(p *Unary_casual_subexprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_unary_casual_subexpr
}

func (*Unary_casual_subexprContext) IsUnary_casual_subexprContext() {}

func NewUnary_casual_subexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_casual_subexprContext {
	var p = new(Unary_casual_subexprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_unary_casual_subexpr

	return p
}

func (s *Unary_casual_subexprContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_casual_subexprContext) Unary_subexpr_suffix() IUnary_subexpr_suffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnary_subexpr_suffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnary_subexpr_suffixContext)
}

func (s *Unary_casual_subexprContext) Id_expr() IId_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_exprContext)
}

func (s *Unary_casual_subexprContext) Atom_expr() IAtom_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtom_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtom_exprContext)
}

func (s *Unary_casual_subexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_casual_subexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_casual_subexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterUnary_casual_subexpr(s)
	}
}

func (s *Unary_casual_subexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitUnary_casual_subexpr(s)
	}
}

func (p *SQLv1Antlr4Parser) Unary_casual_subexpr() (localctx IUnary_casual_subexprContext) {
	localctx = NewUnary_casual_subexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, SQLv1Antlr4ParserRULE_unary_casual_subexpr)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1183)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1181)
			p.Id_expr()
		}

	case 2:
		{
			p.SetState(1182)
			p.Atom_expr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(1185)
		p.Unary_subexpr_suffix()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIn_unary_casual_subexprContext is an interface to support dynamic dispatch.
type IIn_unary_casual_subexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Unary_subexpr_suffix() IUnary_subexpr_suffixContext
	Id_expr_in() IId_expr_inContext
	In_atom_expr() IIn_atom_exprContext

	// IsIn_unary_casual_subexprContext differentiates from other interfaces.
	IsIn_unary_casual_subexprContext()
}

type In_unary_casual_subexprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIn_unary_casual_subexprContext() *In_unary_casual_subexprContext {
	var p = new(In_unary_casual_subexprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_in_unary_casual_subexpr
	return p
}

func InitEmptyIn_unary_casual_subexprContext(p *In_unary_casual_subexprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_in_unary_casual_subexpr
}

func (*In_unary_casual_subexprContext) IsIn_unary_casual_subexprContext() {}

func NewIn_unary_casual_subexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *In_unary_casual_subexprContext {
	var p = new(In_unary_casual_subexprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_in_unary_casual_subexpr

	return p
}

func (s *In_unary_casual_subexprContext) GetParser() antlr.Parser { return s.parser }

func (s *In_unary_casual_subexprContext) Unary_subexpr_suffix() IUnary_subexpr_suffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnary_subexpr_suffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnary_subexpr_suffixContext)
}

func (s *In_unary_casual_subexprContext) Id_expr_in() IId_expr_inContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_expr_inContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_expr_inContext)
}

func (s *In_unary_casual_subexprContext) In_atom_expr() IIn_atom_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIn_atom_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIn_atom_exprContext)
}

func (s *In_unary_casual_subexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *In_unary_casual_subexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *In_unary_casual_subexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterIn_unary_casual_subexpr(s)
	}
}

func (s *In_unary_casual_subexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitIn_unary_casual_subexpr(s)
	}
}

func (p *SQLv1Antlr4Parser) In_unary_casual_subexpr() (localctx IIn_unary_casual_subexprContext) {
	localctx = NewIn_unary_casual_subexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SQLv1Antlr4ParserRULE_in_unary_casual_subexpr)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1189)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1187)
			p.Id_expr_in()
		}

	case 2:
		{
			p.SetState(1188)
			p.In_atom_expr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(1191)
		p.Unary_subexpr_suffix()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnary_subexprContext is an interface to support dynamic dispatch.
type IUnary_subexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Unary_casual_subexpr() IUnary_casual_subexprContext
	Json_api_expr() IJson_api_exprContext

	// IsUnary_subexprContext differentiates from other interfaces.
	IsUnary_subexprContext()
}

type Unary_subexprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_subexprContext() *Unary_subexprContext {
	var p = new(Unary_subexprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_unary_subexpr
	return p
}

func InitEmptyUnary_subexprContext(p *Unary_subexprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_unary_subexpr
}

func (*Unary_subexprContext) IsUnary_subexprContext() {}

func NewUnary_subexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_subexprContext {
	var p = new(Unary_subexprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_unary_subexpr

	return p
}

func (s *Unary_subexprContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_subexprContext) Unary_casual_subexpr() IUnary_casual_subexprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnary_casual_subexprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnary_casual_subexprContext)
}

func (s *Unary_subexprContext) Json_api_expr() IJson_api_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_api_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_api_exprContext)
}

func (s *Unary_subexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_subexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_subexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterUnary_subexpr(s)
	}
}

func (s *Unary_subexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitUnary_subexpr(s)
	}
}

func (p *SQLv1Antlr4Parser) Unary_subexpr() (localctx IUnary_subexprContext) {
	localctx = NewUnary_subexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, SQLv1Antlr4ParserRULE_unary_subexpr)
	p.SetState(1195)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1193)
			p.Unary_casual_subexpr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1194)
			p.Json_api_expr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIn_unary_subexprContext is an interface to support dynamic dispatch.
type IIn_unary_subexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	In_unary_casual_subexpr() IIn_unary_casual_subexprContext
	Json_api_expr() IJson_api_exprContext

	// IsIn_unary_subexprContext differentiates from other interfaces.
	IsIn_unary_subexprContext()
}

type In_unary_subexprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIn_unary_subexprContext() *In_unary_subexprContext {
	var p = new(In_unary_subexprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_in_unary_subexpr
	return p
}

func InitEmptyIn_unary_subexprContext(p *In_unary_subexprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_in_unary_subexpr
}

func (*In_unary_subexprContext) IsIn_unary_subexprContext() {}

func NewIn_unary_subexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *In_unary_subexprContext {
	var p = new(In_unary_subexprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_in_unary_subexpr

	return p
}

func (s *In_unary_subexprContext) GetParser() antlr.Parser { return s.parser }

func (s *In_unary_subexprContext) In_unary_casual_subexpr() IIn_unary_casual_subexprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIn_unary_casual_subexprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIn_unary_casual_subexprContext)
}

func (s *In_unary_subexprContext) Json_api_expr() IJson_api_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_api_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_api_exprContext)
}

func (s *In_unary_subexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *In_unary_subexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *In_unary_subexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterIn_unary_subexpr(s)
	}
}

func (s *In_unary_subexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitIn_unary_subexpr(s)
	}
}

func (p *SQLv1Antlr4Parser) In_unary_subexpr() (localctx IIn_unary_subexprContext) {
	localctx = NewIn_unary_subexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, SQLv1Antlr4ParserRULE_in_unary_subexpr)
	p.SetState(1199)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1197)
			p.In_unary_casual_subexpr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1198)
			p.Json_api_expr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IList_literalContext is an interface to support dynamic dispatch.
type IList_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE_SQUARE() antlr.TerminalNode
	RBRACE_SQUARE() antlr.TerminalNode
	Expr_list() IExpr_listContext
	COMMA() antlr.TerminalNode

	// IsList_literalContext differentiates from other interfaces.
	IsList_literalContext()
}

type List_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_literalContext() *List_literalContext {
	var p = new(List_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_list_literal
	return p
}

func InitEmptyList_literalContext(p *List_literalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_list_literal
}

func (*List_literalContext) IsList_literalContext() {}

func NewList_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_literalContext {
	var p = new(List_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_list_literal

	return p
}

func (s *List_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *List_literalContext) LBRACE_SQUARE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLBRACE_SQUARE, 0)
}

func (s *List_literalContext) RBRACE_SQUARE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRBRACE_SQUARE, 0)
}

func (s *List_literalContext) Expr_list() IExpr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_listContext)
}

func (s *List_literalContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, 0)
}

func (s *List_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterList_literal(s)
	}
}

func (s *List_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitList_literal(s)
	}
}

func (p *SQLv1Antlr4Parser) List_literal() (localctx IList_literalContext) {
	localctx = NewList_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, SQLv1Antlr4ParserRULE_list_literal)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1201)
		p.Match(SQLv1Antlr4ParserLBRACE_SQUARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1203)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-14)) & ^0x3f) == 0 && ((int64(1)<<(_la-14))&-562950217396195) != 0) || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&-1) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&-129) != 0) || ((int64((_la-206)) & ^0x3f) == 0 && ((int64(1)<<(_la-206))&-274877906945) != 0) || ((int64((_la-270)) & ^0x3f) == 0 && ((int64(1)<<(_la-270))&576460752303423487) != 0) {
		{
			p.SetState(1202)
			p.Expr_list()
		}

	}
	p.SetState(1206)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(1205)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1208)
		p.Match(SQLv1Antlr4ParserRBRACE_SQUARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_dict_listContext is an interface to support dynamic dispatch.
type IExpr_dict_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpr_dict_listContext differentiates from other interfaces.
	IsExpr_dict_listContext()
}

type Expr_dict_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_dict_listContext() *Expr_dict_listContext {
	var p = new(Expr_dict_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_expr_dict_list
	return p
}

func InitEmptyExpr_dict_listContext(p *Expr_dict_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_expr_dict_list
}

func (*Expr_dict_listContext) IsExpr_dict_listContext() {}

func NewExpr_dict_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_dict_listContext {
	var p = new(Expr_dict_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_expr_dict_list

	return p
}

func (s *Expr_dict_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_dict_listContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_dict_listContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_dict_listContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOLON)
}

func (s *Expr_dict_listContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOLON, i)
}

func (s *Expr_dict_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Expr_dict_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Expr_dict_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_dict_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_dict_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterExpr_dict_list(s)
	}
}

func (s *Expr_dict_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitExpr_dict_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Expr_dict_list() (localctx IExpr_dict_listContext) {
	localctx = NewExpr_dict_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, SQLv1Antlr4ParserRULE_expr_dict_list)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1210)
		p.Expr()
	}
	p.SetState(1213)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserCOLON {
		{
			p.SetState(1211)
			p.Match(SQLv1Antlr4ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1212)
			p.Expr()
		}

	}
	p.SetState(1223)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1215)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1216)
				p.Expr()
			}
			p.SetState(1219)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SQLv1Antlr4ParserCOLON {
				{
					p.SetState(1217)
					p.Match(SQLv1Antlr4ParserCOLON)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1218)
					p.Expr()
				}

			}

		}
		p.SetState(1225)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDict_literalContext is an interface to support dynamic dispatch.
type IDict_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE_CURLY() antlr.TerminalNode
	RBRACE_CURLY() antlr.TerminalNode
	Expr_dict_list() IExpr_dict_listContext
	COMMA() antlr.TerminalNode

	// IsDict_literalContext differentiates from other interfaces.
	IsDict_literalContext()
}

type Dict_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDict_literalContext() *Dict_literalContext {
	var p = new(Dict_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_dict_literal
	return p
}

func InitEmptyDict_literalContext(p *Dict_literalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_dict_literal
}

func (*Dict_literalContext) IsDict_literalContext() {}

func NewDict_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dict_literalContext {
	var p = new(Dict_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_dict_literal

	return p
}

func (s *Dict_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Dict_literalContext) LBRACE_CURLY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLBRACE_CURLY, 0)
}

func (s *Dict_literalContext) RBRACE_CURLY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRBRACE_CURLY, 0)
}

func (s *Dict_literalContext) Expr_dict_list() IExpr_dict_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_dict_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_dict_listContext)
}

func (s *Dict_literalContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, 0)
}

func (s *Dict_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dict_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dict_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterDict_literal(s)
	}
}

func (s *Dict_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitDict_literal(s)
	}
}

func (p *SQLv1Antlr4Parser) Dict_literal() (localctx IDict_literalContext) {
	localctx = NewDict_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, SQLv1Antlr4ParserRULE_dict_literal)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1226)
		p.Match(SQLv1Antlr4ParserLBRACE_CURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1228)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-14)) & ^0x3f) == 0 && ((int64(1)<<(_la-14))&-562950217396195) != 0) || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&-1) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&-129) != 0) || ((int64((_la-206)) & ^0x3f) == 0 && ((int64(1)<<(_la-206))&-274877906945) != 0) || ((int64((_la-270)) & ^0x3f) == 0 && ((int64(1)<<(_la-270))&576460752303423487) != 0) {
		{
			p.SetState(1227)
			p.Expr_dict_list()
		}

	}
	p.SetState(1231)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(1230)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1233)
		p.Match(SQLv1Antlr4ParserRBRACE_CURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_struct_listContext is an interface to support dynamic dispatch.
type IExpr_struct_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpr_struct_listContext differentiates from other interfaces.
	IsExpr_struct_listContext()
}

type Expr_struct_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_struct_listContext() *Expr_struct_listContext {
	var p = new(Expr_struct_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_expr_struct_list
	return p
}

func InitEmptyExpr_struct_listContext(p *Expr_struct_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_expr_struct_list
}

func (*Expr_struct_listContext) IsExpr_struct_listContext() {}

func NewExpr_struct_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_struct_listContext {
	var p = new(Expr_struct_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_expr_struct_list

	return p
}

func (s *Expr_struct_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_struct_listContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_struct_listContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_struct_listContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOLON)
}

func (s *Expr_struct_listContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOLON, i)
}

func (s *Expr_struct_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Expr_struct_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Expr_struct_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_struct_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_struct_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterExpr_struct_list(s)
	}
}

func (s *Expr_struct_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitExpr_struct_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Expr_struct_list() (localctx IExpr_struct_listContext) {
	localctx = NewExpr_struct_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, SQLv1Antlr4ParserRULE_expr_struct_list)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1235)
		p.Expr()
	}
	{
		p.SetState(1236)
		p.Match(SQLv1Antlr4ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1237)
		p.Expr()
	}
	p.SetState(1245)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1238)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1239)
				p.Expr()
			}
			{
				p.SetState(1240)
				p.Match(SQLv1Antlr4ParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1241)
				p.Expr()
			}

		}
		p.SetState(1247)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStruct_literalContext is an interface to support dynamic dispatch.
type IStruct_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRUCT_OPEN() antlr.TerminalNode
	STRUCT_CLOSE() antlr.TerminalNode
	Expr_struct_list() IExpr_struct_listContext
	COMMA() antlr.TerminalNode

	// IsStruct_literalContext differentiates from other interfaces.
	IsStruct_literalContext()
}

type Struct_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_literalContext() *Struct_literalContext {
	var p = new(Struct_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_struct_literal
	return p
}

func InitEmptyStruct_literalContext(p *Struct_literalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_struct_literal
}

func (*Struct_literalContext) IsStruct_literalContext() {}

func NewStruct_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_literalContext {
	var p = new(Struct_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_struct_literal

	return p
}

func (s *Struct_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_literalContext) STRUCT_OPEN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRUCT_OPEN, 0)
}

func (s *Struct_literalContext) STRUCT_CLOSE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRUCT_CLOSE, 0)
}

func (s *Struct_literalContext) Expr_struct_list() IExpr_struct_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_struct_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_struct_listContext)
}

func (s *Struct_literalContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, 0)
}

func (s *Struct_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Struct_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterStruct_literal(s)
	}
}

func (s *Struct_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitStruct_literal(s)
	}
}

func (p *SQLv1Antlr4Parser) Struct_literal() (localctx IStruct_literalContext) {
	localctx = NewStruct_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, SQLv1Antlr4ParserRULE_struct_literal)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1248)
		p.Match(SQLv1Antlr4ParserSTRUCT_OPEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1250)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-14)) & ^0x3f) == 0 && ((int64(1)<<(_la-14))&-562950217396195) != 0) || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&-1) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&-129) != 0) || ((int64((_la-206)) & ^0x3f) == 0 && ((int64(1)<<(_la-206))&-274877906945) != 0) || ((int64((_la-270)) & ^0x3f) == 0 && ((int64(1)<<(_la-270))&576460752303423487) != 0) {
		{
			p.SetState(1249)
			p.Expr_struct_list()
		}

	}
	p.SetState(1253)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(1252)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1255)
		p.Match(SQLv1Antlr4ParserSTRUCT_CLOSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAtom_exprContext is an interface to support dynamic dispatch.
type IAtom_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Literal_value() ILiteral_valueContext
	Bind_parameter() IBind_parameterContext
	Lambda() ILambdaContext
	Cast_expr() ICast_exprContext
	Exists_expr() IExists_exprContext
	Case_expr() ICase_exprContext
	An_id_or_type() IAn_id_or_typeContext
	NAMESPACE() antlr.TerminalNode
	Id_or_type() IId_or_typeContext
	STRING_VALUE() antlr.TerminalNode
	Value_constructor() IValue_constructorContext
	Bitcast_expr() IBitcast_exprContext
	List_literal() IList_literalContext
	Dict_literal() IDict_literalContext
	Struct_literal() IStruct_literalContext

	// IsAtom_exprContext differentiates from other interfaces.
	IsAtom_exprContext()
}

type Atom_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtom_exprContext() *Atom_exprContext {
	var p = new(Atom_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_atom_expr
	return p
}

func InitEmptyAtom_exprContext(p *Atom_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_atom_expr
}

func (*Atom_exprContext) IsAtom_exprContext() {}

func NewAtom_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Atom_exprContext {
	var p = new(Atom_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_atom_expr

	return p
}

func (s *Atom_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Atom_exprContext) Literal_value() ILiteral_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteral_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteral_valueContext)
}

func (s *Atom_exprContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Atom_exprContext) Lambda() ILambdaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaContext)
}

func (s *Atom_exprContext) Cast_expr() ICast_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICast_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICast_exprContext)
}

func (s *Atom_exprContext) Exists_expr() IExists_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExists_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExists_exprContext)
}

func (s *Atom_exprContext) Case_expr() ICase_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICase_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICase_exprContext)
}

func (s *Atom_exprContext) An_id_or_type() IAn_id_or_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_or_typeContext)
}

func (s *Atom_exprContext) NAMESPACE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNAMESPACE, 0)
}

func (s *Atom_exprContext) Id_or_type() IId_or_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_or_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_or_typeContext)
}

func (s *Atom_exprContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRING_VALUE, 0)
}

func (s *Atom_exprContext) Value_constructor() IValue_constructorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValue_constructorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValue_constructorContext)
}

func (s *Atom_exprContext) Bitcast_expr() IBitcast_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitcast_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitcast_exprContext)
}

func (s *Atom_exprContext) List_literal() IList_literalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IList_literalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IList_literalContext)
}

func (s *Atom_exprContext) Dict_literal() IDict_literalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDict_literalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDict_literalContext)
}

func (s *Atom_exprContext) Struct_literal() IStruct_literalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStruct_literalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStruct_literalContext)
}

func (s *Atom_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Atom_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Atom_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAtom_expr(s)
	}
}

func (s *Atom_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAtom_expr(s)
	}
}

func (p *SQLv1Antlr4Parser) Atom_expr() (localctx IAtom_exprContext) {
	localctx = NewAtom_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, SQLv1Antlr4ParserRULE_atom_expr)
	p.SetState(1274)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1257)
			p.Literal_value()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1258)
			p.Bind_parameter()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1259)
			p.Lambda()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1260)
			p.Cast_expr()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1261)
			p.Exists_expr()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1262)
			p.Case_expr()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1263)
			p.An_id_or_type()
		}
		{
			p.SetState(1264)
			p.Match(SQLv1Antlr4ParserNAMESPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1267)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALL, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserANY, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCALLABLE, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDICT, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserENUM, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFLOW, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserLIST, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOPTIONAL, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESOURCE, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSET, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSTREAM, SQLv1Antlr4ParserSTRUCT, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTAGGED, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTUPLE, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVARIANT, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWITHOUT, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
			{
				p.SetState(1265)
				p.Id_or_type()
			}

		case SQLv1Antlr4ParserSTRING_VALUE:
			{
				p.SetState(1266)
				p.Match(SQLv1Antlr4ParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1269)
			p.Value_constructor()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1270)
			p.Bitcast_expr()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1271)
			p.List_literal()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1272)
			p.Dict_literal()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1273)
			p.Struct_literal()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIn_atom_exprContext is an interface to support dynamic dispatch.
type IIn_atom_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Literal_value() ILiteral_valueContext
	Bind_parameter() IBind_parameterContext
	Lambda() ILambdaContext
	Cast_expr() ICast_exprContext
	Case_expr() ICase_exprContext
	An_id_or_type() IAn_id_or_typeContext
	NAMESPACE() antlr.TerminalNode
	Id_or_type() IId_or_typeContext
	STRING_VALUE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	RPAREN() antlr.TerminalNode
	Value_constructor() IValue_constructorContext
	Bitcast_expr() IBitcast_exprContext
	List_literal() IList_literalContext
	Dict_literal() IDict_literalContext
	Struct_literal() IStruct_literalContext

	// IsIn_atom_exprContext differentiates from other interfaces.
	IsIn_atom_exprContext()
}

type In_atom_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIn_atom_exprContext() *In_atom_exprContext {
	var p = new(In_atom_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_in_atom_expr
	return p
}

func InitEmptyIn_atom_exprContext(p *In_atom_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_in_atom_expr
}

func (*In_atom_exprContext) IsIn_atom_exprContext() {}

func NewIn_atom_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *In_atom_exprContext {
	var p = new(In_atom_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_in_atom_expr

	return p
}

func (s *In_atom_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *In_atom_exprContext) Literal_value() ILiteral_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteral_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteral_valueContext)
}

func (s *In_atom_exprContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *In_atom_exprContext) Lambda() ILambdaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaContext)
}

func (s *In_atom_exprContext) Cast_expr() ICast_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICast_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICast_exprContext)
}

func (s *In_atom_exprContext) Case_expr() ICase_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICase_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICase_exprContext)
}

func (s *In_atom_exprContext) An_id_or_type() IAn_id_or_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_or_typeContext)
}

func (s *In_atom_exprContext) NAMESPACE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNAMESPACE, 0)
}

func (s *In_atom_exprContext) Id_or_type() IId_or_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_or_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_or_typeContext)
}

func (s *In_atom_exprContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRING_VALUE, 0)
}

func (s *In_atom_exprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *In_atom_exprContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *In_atom_exprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *In_atom_exprContext) Value_constructor() IValue_constructorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValue_constructorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValue_constructorContext)
}

func (s *In_atom_exprContext) Bitcast_expr() IBitcast_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitcast_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitcast_exprContext)
}

func (s *In_atom_exprContext) List_literal() IList_literalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IList_literalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IList_literalContext)
}

func (s *In_atom_exprContext) Dict_literal() IDict_literalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDict_literalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDict_literalContext)
}

func (s *In_atom_exprContext) Struct_literal() IStruct_literalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStruct_literalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStruct_literalContext)
}

func (s *In_atom_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *In_atom_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *In_atom_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterIn_atom_expr(s)
	}
}

func (s *In_atom_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitIn_atom_expr(s)
	}
}

func (p *SQLv1Antlr4Parser) In_atom_expr() (localctx IIn_atom_exprContext) {
	localctx = NewIn_atom_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SQLv1Antlr4ParserRULE_in_atom_expr)
	p.SetState(1296)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1276)
			p.Literal_value()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1277)
			p.Bind_parameter()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1278)
			p.Lambda()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1279)
			p.Cast_expr()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1280)
			p.Case_expr()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1281)
			p.An_id_or_type()
		}
		{
			p.SetState(1282)
			p.Match(SQLv1Antlr4ParserNAMESPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1285)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALL, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserANY, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCALLABLE, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDICT, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserENUM, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFLOW, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserLIST, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOPTIONAL, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESOURCE, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSET, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSTREAM, SQLv1Antlr4ParserSTRUCT, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTAGGED, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTUPLE, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVARIANT, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWITHOUT, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
			{
				p.SetState(1283)
				p.Id_or_type()
			}

		case SQLv1Antlr4ParserSTRING_VALUE:
			{
				p.SetState(1284)
				p.Match(SQLv1Antlr4ParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1287)
			p.Match(SQLv1Antlr4ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1288)
			p.Select_stmt()
		}
		{
			p.SetState(1289)
			p.Match(SQLv1Antlr4ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1291)
			p.Value_constructor()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1292)
			p.Bitcast_expr()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1293)
			p.List_literal()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1294)
			p.Dict_literal()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1295)
			p.Struct_literal()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICast_exprContext is an interface to support dynamic dispatch.
type ICast_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CAST() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expr() IExprContext
	AS() antlr.TerminalNode
	Type_name_or_bind() IType_name_or_bindContext
	RPAREN() antlr.TerminalNode

	// IsCast_exprContext differentiates from other interfaces.
	IsCast_exprContext()
}

type Cast_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCast_exprContext() *Cast_exprContext {
	var p = new(Cast_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_cast_expr
	return p
}

func InitEmptyCast_exprContext(p *Cast_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_cast_expr
}

func (*Cast_exprContext) IsCast_exprContext() {}

func NewCast_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cast_exprContext {
	var p = new(Cast_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_cast_expr

	return p
}

func (s *Cast_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Cast_exprContext) CAST() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCAST, 0)
}

func (s *Cast_exprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Cast_exprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Cast_exprContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAS, 0)
}

func (s *Cast_exprContext) Type_name_or_bind() IType_name_or_bindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Cast_exprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Cast_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cast_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cast_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterCast_expr(s)
	}
}

func (s *Cast_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitCast_expr(s)
	}
}

func (p *SQLv1Antlr4Parser) Cast_expr() (localctx ICast_exprContext) {
	localctx = NewCast_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SQLv1Antlr4ParserRULE_cast_expr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1298)
		p.Match(SQLv1Antlr4ParserCAST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1299)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1300)
		p.Expr()
	}
	{
		p.SetState(1301)
		p.Match(SQLv1Antlr4ParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1302)
		p.Type_name_or_bind()
	}
	{
		p.SetState(1303)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBitcast_exprContext is an interface to support dynamic dispatch.
type IBitcast_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BITCAST() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expr() IExprContext
	AS() antlr.TerminalNode
	Type_name_simple() IType_name_simpleContext
	RPAREN() antlr.TerminalNode

	// IsBitcast_exprContext differentiates from other interfaces.
	IsBitcast_exprContext()
}

type Bitcast_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitcast_exprContext() *Bitcast_exprContext {
	var p = new(Bitcast_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_bitcast_expr
	return p
}

func InitEmptyBitcast_exprContext(p *Bitcast_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_bitcast_expr
}

func (*Bitcast_exprContext) IsBitcast_exprContext() {}

func NewBitcast_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bitcast_exprContext {
	var p = new(Bitcast_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_bitcast_expr

	return p
}

func (s *Bitcast_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Bitcast_exprContext) BITCAST() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserBITCAST, 0)
}

func (s *Bitcast_exprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Bitcast_exprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Bitcast_exprContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAS, 0)
}

func (s *Bitcast_exprContext) Type_name_simple() IType_name_simpleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_simpleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_simpleContext)
}

func (s *Bitcast_exprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Bitcast_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bitcast_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bitcast_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterBitcast_expr(s)
	}
}

func (s *Bitcast_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitBitcast_expr(s)
	}
}

func (p *SQLv1Antlr4Parser) Bitcast_expr() (localctx IBitcast_exprContext) {
	localctx = NewBitcast_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, SQLv1Antlr4ParserRULE_bitcast_expr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1305)
		p.Match(SQLv1Antlr4ParserBITCAST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1306)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1307)
		p.Expr()
	}
	{
		p.SetState(1308)
		p.Match(SQLv1Antlr4ParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1309)
		p.Type_name_simple()
	}
	{
		p.SetState(1310)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExists_exprContext is an interface to support dynamic dispatch.
type IExists_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXISTS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	Values_stmt() IValues_stmtContext

	// IsExists_exprContext differentiates from other interfaces.
	IsExists_exprContext()
}

type Exists_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExists_exprContext() *Exists_exprContext {
	var p = new(Exists_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_exists_expr
	return p
}

func InitEmptyExists_exprContext(p *Exists_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_exists_expr
}

func (*Exists_exprContext) IsExists_exprContext() {}

func NewExists_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exists_exprContext {
	var p = new(Exists_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_exists_expr

	return p
}

func (s *Exists_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Exists_exprContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXISTS, 0)
}

func (s *Exists_exprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Exists_exprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Exists_exprContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Exists_exprContext) Values_stmt() IValues_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValues_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValues_stmtContext)
}

func (s *Exists_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exists_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Exists_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterExists_expr(s)
	}
}

func (s *Exists_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitExists_expr(s)
	}
}

func (p *SQLv1Antlr4Parser) Exists_expr() (localctx IExists_exprContext) {
	localctx = NewExists_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, SQLv1Antlr4ParserRULE_exists_expr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1312)
		p.Match(SQLv1Antlr4ParserEXISTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1313)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1316)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserLPAREN, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserSELECT:
		{
			p.SetState(1314)
			p.Select_stmt()
		}

	case SQLv1Antlr4ParserVALUES:
		{
			p.SetState(1315)
			p.Values_stmt()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1318)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICase_exprContext is an interface to support dynamic dispatch.
type ICase_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	END() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllWhen_expr() []IWhen_exprContext
	When_expr(i int) IWhen_exprContext
	ELSE() antlr.TerminalNode

	// IsCase_exprContext differentiates from other interfaces.
	IsCase_exprContext()
}

type Case_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_exprContext() *Case_exprContext {
	var p = new(Case_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_case_expr
	return p
}

func InitEmptyCase_exprContext(p *Case_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_case_expr
}

func (*Case_exprContext) IsCase_exprContext() {}

func NewCase_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_exprContext {
	var p = new(Case_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_case_expr

	return p
}

func (s *Case_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_exprContext) CASE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCASE, 0)
}

func (s *Case_exprContext) END() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEND, 0)
}

func (s *Case_exprContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Case_exprContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Case_exprContext) AllWhen_expr() []IWhen_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhen_exprContext); ok {
			len++
		}
	}

	tst := make([]IWhen_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhen_exprContext); ok {
			tst[i] = t.(IWhen_exprContext)
			i++
		}
	}

	return tst
}

func (s *Case_exprContext) When_expr(i int) IWhen_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhen_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhen_exprContext)
}

func (s *Case_exprContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserELSE, 0)
}

func (s *Case_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterCase_expr(s)
	}
}

func (s *Case_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitCase_expr(s)
	}
}

func (p *SQLv1Antlr4Parser) Case_expr() (localctx ICase_exprContext) {
	localctx = NewCase_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, SQLv1Antlr4ParserRULE_case_expr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1320)
		p.Match(SQLv1Antlr4ParserCASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1322)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1321)
			p.Expr()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1325)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SQLv1Antlr4ParserWHEN {
		{
			p.SetState(1324)
			p.When_expr()
		}

		p.SetState(1327)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1331)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserELSE {
		{
			p.SetState(1329)
			p.Match(SQLv1Antlr4ParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1330)
			p.Expr()
		}

	}
	{
		p.SetState(1333)
		p.Match(SQLv1Antlr4ParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaContext is an interface to support dynamic dispatch.
type ILambdaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Smart_parenthesis() ISmart_parenthesisContext
	ARROW() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expr() IExprContext
	RPAREN() antlr.TerminalNode
	LBRACE_CURLY() antlr.TerminalNode
	Lambda_body() ILambda_bodyContext
	RBRACE_CURLY() antlr.TerminalNode

	// IsLambdaContext differentiates from other interfaces.
	IsLambdaContext()
}

type LambdaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaContext() *LambdaContext {
	var p = new(LambdaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_lambda
	return p
}

func InitEmptyLambdaContext(p *LambdaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_lambda
}

func (*LambdaContext) IsLambdaContext() {}

func NewLambdaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaContext {
	var p = new(LambdaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_lambda

	return p
}

func (s *LambdaContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaContext) Smart_parenthesis() ISmart_parenthesisContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISmart_parenthesisContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISmart_parenthesisContext)
}

func (s *LambdaContext) ARROW() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserARROW, 0)
}

func (s *LambdaContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *LambdaContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LambdaContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *LambdaContext) LBRACE_CURLY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLBRACE_CURLY, 0)
}

func (s *LambdaContext) Lambda_body() ILambda_bodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambda_bodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambda_bodyContext)
}

func (s *LambdaContext) RBRACE_CURLY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRBRACE_CURLY, 0)
}

func (s *LambdaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterLambda(s)
	}
}

func (s *LambdaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitLambda(s)
	}
}

func (p *SQLv1Antlr4Parser) Lambda() (localctx ILambdaContext) {
	localctx = NewLambdaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SQLv1Antlr4ParserRULE_lambda)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1335)
		p.Smart_parenthesis()
	}
	p.SetState(1347)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserARROW {
		{
			p.SetState(1336)
			p.Match(SQLv1Antlr4ParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1345)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case SQLv1Antlr4ParserLPAREN:
			{
				p.SetState(1337)
				p.Match(SQLv1Antlr4ParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1338)
				p.Expr()
			}
			{
				p.SetState(1339)
				p.Match(SQLv1Antlr4ParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case SQLv1Antlr4ParserLBRACE_CURLY:
			{
				p.SetState(1341)
				p.Match(SQLv1Antlr4ParserLBRACE_CURLY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1342)
				p.Lambda_body()
			}
			{
				p.SetState(1343)
				p.Match(SQLv1Antlr4ParserRBRACE_CURLY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIn_exprContext is an interface to support dynamic dispatch.
type IIn_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	In_unary_subexpr() IIn_unary_subexprContext

	// IsIn_exprContext differentiates from other interfaces.
	IsIn_exprContext()
}

type In_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIn_exprContext() *In_exprContext {
	var p = new(In_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_in_expr
	return p
}

func InitEmptyIn_exprContext(p *In_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_in_expr
}

func (*In_exprContext) IsIn_exprContext() {}

func NewIn_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *In_exprContext {
	var p = new(In_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_in_expr

	return p
}

func (s *In_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *In_exprContext) In_unary_subexpr() IIn_unary_subexprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIn_unary_subexprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIn_unary_subexprContext)
}

func (s *In_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *In_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *In_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterIn_expr(s)
	}
}

func (s *In_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitIn_expr(s)
	}
}

func (p *SQLv1Antlr4Parser) In_expr() (localctx IIn_exprContext) {
	localctx = NewIn_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, SQLv1Antlr4ParserRULE_in_expr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1349)
		p.In_unary_subexpr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJson_api_exprContext is an interface to support dynamic dispatch.
type IJson_api_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Json_value() IJson_valueContext
	Json_exists() IJson_existsContext
	Json_query() IJson_queryContext

	// IsJson_api_exprContext differentiates from other interfaces.
	IsJson_api_exprContext()
}

type Json_api_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJson_api_exprContext() *Json_api_exprContext {
	var p = new(Json_api_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_api_expr
	return p
}

func InitEmptyJson_api_exprContext(p *Json_api_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_api_expr
}

func (*Json_api_exprContext) IsJson_api_exprContext() {}

func NewJson_api_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Json_api_exprContext {
	var p = new(Json_api_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_api_expr

	return p
}

func (s *Json_api_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Json_api_exprContext) Json_value() IJson_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_valueContext)
}

func (s *Json_api_exprContext) Json_exists() IJson_existsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_existsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_existsContext)
}

func (s *Json_api_exprContext) Json_query() IJson_queryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_queryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_queryContext)
}

func (s *Json_api_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Json_api_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Json_api_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterJson_api_expr(s)
	}
}

func (s *Json_api_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitJson_api_expr(s)
	}
}

func (p *SQLv1Antlr4Parser) Json_api_expr() (localctx IJson_api_exprContext) {
	localctx = NewJson_api_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, SQLv1Antlr4ParserRULE_json_api_expr)
	p.SetState(1354)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserJSON_VALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1351)
			p.Json_value()
		}

	case SQLv1Antlr4ParserJSON_EXISTS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1352)
			p.Json_exists()
		}

	case SQLv1Antlr4ParserJSON_QUERY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1353)
			p.Json_query()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonpath_specContext is an interface to support dynamic dispatch.
type IJsonpath_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_VALUE() antlr.TerminalNode

	// IsJsonpath_specContext differentiates from other interfaces.
	IsJsonpath_specContext()
}

type Jsonpath_specContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonpath_specContext() *Jsonpath_specContext {
	var p = new(Jsonpath_specContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_jsonpath_spec
	return p
}

func InitEmptyJsonpath_specContext(p *Jsonpath_specContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_jsonpath_spec
}

func (*Jsonpath_specContext) IsJsonpath_specContext() {}

func NewJsonpath_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Jsonpath_specContext {
	var p = new(Jsonpath_specContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_jsonpath_spec

	return p
}

func (s *Jsonpath_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Jsonpath_specContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRING_VALUE, 0)
}

func (s *Jsonpath_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Jsonpath_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Jsonpath_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterJsonpath_spec(s)
	}
}

func (s *Jsonpath_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitJsonpath_spec(s)
	}
}

func (p *SQLv1Antlr4Parser) Jsonpath_spec() (localctx IJsonpath_specContext) {
	localctx = NewJsonpath_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, SQLv1Antlr4ParserRULE_jsonpath_spec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1356)
		p.Match(SQLv1Antlr4ParserSTRING_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJson_variable_nameContext is an interface to support dynamic dispatch.
type IJson_variable_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_expr() IId_exprContext
	STRING_VALUE() antlr.TerminalNode

	// IsJson_variable_nameContext differentiates from other interfaces.
	IsJson_variable_nameContext()
}

type Json_variable_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJson_variable_nameContext() *Json_variable_nameContext {
	var p = new(Json_variable_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_variable_name
	return p
}

func InitEmptyJson_variable_nameContext(p *Json_variable_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_variable_name
}

func (*Json_variable_nameContext) IsJson_variable_nameContext() {}

func NewJson_variable_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Json_variable_nameContext {
	var p = new(Json_variable_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_variable_name

	return p
}

func (s *Json_variable_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Json_variable_nameContext) Id_expr() IId_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_exprContext)
}

func (s *Json_variable_nameContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRING_VALUE, 0)
}

func (s *Json_variable_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Json_variable_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Json_variable_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterJson_variable_name(s)
	}
}

func (s *Json_variable_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitJson_variable_name(s)
	}
}

func (p *SQLv1Antlr4Parser) Json_variable_name() (localctx IJson_variable_nameContext) {
	localctx = NewJson_variable_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, SQLv1Antlr4ParserRULE_json_variable_name)
	p.SetState(1360)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1358)
			p.Id_expr()
		}

	case SQLv1Antlr4ParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1359)
			p.Match(SQLv1Antlr4ParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJson_variableContext is an interface to support dynamic dispatch.
type IJson_variableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	AS() antlr.TerminalNode
	Json_variable_name() IJson_variable_nameContext

	// IsJson_variableContext differentiates from other interfaces.
	IsJson_variableContext()
}

type Json_variableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJson_variableContext() *Json_variableContext {
	var p = new(Json_variableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_variable
	return p
}

func InitEmptyJson_variableContext(p *Json_variableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_variable
}

func (*Json_variableContext) IsJson_variableContext() {}

func NewJson_variableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Json_variableContext {
	var p = new(Json_variableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_variable

	return p
}

func (s *Json_variableContext) GetParser() antlr.Parser { return s.parser }

func (s *Json_variableContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Json_variableContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAS, 0)
}

func (s *Json_variableContext) Json_variable_name() IJson_variable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_variable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_variable_nameContext)
}

func (s *Json_variableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Json_variableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Json_variableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterJson_variable(s)
	}
}

func (s *Json_variableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitJson_variable(s)
	}
}

func (p *SQLv1Antlr4Parser) Json_variable() (localctx IJson_variableContext) {
	localctx = NewJson_variableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, SQLv1Antlr4ParserRULE_json_variable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1362)
		p.Expr()
	}
	{
		p.SetState(1363)
		p.Match(SQLv1Antlr4ParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1364)
		p.Json_variable_name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJson_variablesContext is an interface to support dynamic dispatch.
type IJson_variablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllJson_variable() []IJson_variableContext
	Json_variable(i int) IJson_variableContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsJson_variablesContext differentiates from other interfaces.
	IsJson_variablesContext()
}

type Json_variablesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJson_variablesContext() *Json_variablesContext {
	var p = new(Json_variablesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_variables
	return p
}

func InitEmptyJson_variablesContext(p *Json_variablesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_variables
}

func (*Json_variablesContext) IsJson_variablesContext() {}

func NewJson_variablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Json_variablesContext {
	var p = new(Json_variablesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_variables

	return p
}

func (s *Json_variablesContext) GetParser() antlr.Parser { return s.parser }

func (s *Json_variablesContext) AllJson_variable() []IJson_variableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJson_variableContext); ok {
			len++
		}
	}

	tst := make([]IJson_variableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJson_variableContext); ok {
			tst[i] = t.(IJson_variableContext)
			i++
		}
	}

	return tst
}

func (s *Json_variablesContext) Json_variable(i int) IJson_variableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_variableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_variableContext)
}

func (s *Json_variablesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Json_variablesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Json_variablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Json_variablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Json_variablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterJson_variables(s)
	}
}

func (s *Json_variablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitJson_variables(s)
	}
}

func (p *SQLv1Antlr4Parser) Json_variables() (localctx IJson_variablesContext) {
	localctx = NewJson_variablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, SQLv1Antlr4ParserRULE_json_variables)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1366)
		p.Json_variable()
	}
	p.SetState(1371)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(1367)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1368)
			p.Json_variable()
		}

		p.SetState(1373)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJson_common_argsContext is an interface to support dynamic dispatch.
type IJson_common_argsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	COMMA() antlr.TerminalNode
	Jsonpath_spec() IJsonpath_specContext
	PASSING() antlr.TerminalNode
	Json_variables() IJson_variablesContext

	// IsJson_common_argsContext differentiates from other interfaces.
	IsJson_common_argsContext()
}

type Json_common_argsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJson_common_argsContext() *Json_common_argsContext {
	var p = new(Json_common_argsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_common_args
	return p
}

func InitEmptyJson_common_argsContext(p *Json_common_argsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_common_args
}

func (*Json_common_argsContext) IsJson_common_argsContext() {}

func NewJson_common_argsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Json_common_argsContext {
	var p = new(Json_common_argsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_common_args

	return p
}

func (s *Json_common_argsContext) GetParser() antlr.Parser { return s.parser }

func (s *Json_common_argsContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Json_common_argsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, 0)
}

func (s *Json_common_argsContext) Jsonpath_spec() IJsonpath_specContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonpath_specContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonpath_specContext)
}

func (s *Json_common_argsContext) PASSING() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPASSING, 0)
}

func (s *Json_common_argsContext) Json_variables() IJson_variablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_variablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_variablesContext)
}

func (s *Json_common_argsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Json_common_argsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Json_common_argsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterJson_common_args(s)
	}
}

func (s *Json_common_argsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitJson_common_args(s)
	}
}

func (p *SQLv1Antlr4Parser) Json_common_args() (localctx IJson_common_argsContext) {
	localctx = NewJson_common_argsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, SQLv1Antlr4ParserRULE_json_common_args)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1374)
		p.Expr()
	}
	{
		p.SetState(1375)
		p.Match(SQLv1Antlr4ParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1376)
		p.Jsonpath_spec()
	}
	p.SetState(1379)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserPASSING {
		{
			p.SetState(1377)
			p.Match(SQLv1Antlr4ParserPASSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1378)
			p.Json_variables()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJson_case_handlerContext is an interface to support dynamic dispatch.
type IJson_case_handlerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ERROR() antlr.TerminalNode
	NULL() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	Expr() IExprContext

	// IsJson_case_handlerContext differentiates from other interfaces.
	IsJson_case_handlerContext()
}

type Json_case_handlerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJson_case_handlerContext() *Json_case_handlerContext {
	var p = new(Json_case_handlerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_case_handler
	return p
}

func InitEmptyJson_case_handlerContext(p *Json_case_handlerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_case_handler
}

func (*Json_case_handlerContext) IsJson_case_handlerContext() {}

func NewJson_case_handlerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Json_case_handlerContext {
	var p = new(Json_case_handlerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_case_handler

	return p
}

func (s *Json_case_handlerContext) GetParser() antlr.Parser { return s.parser }

func (s *Json_case_handlerContext) ERROR() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserERROR, 0)
}

func (s *Json_case_handlerContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNULL, 0)
}

func (s *Json_case_handlerContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDEFAULT, 0)
}

func (s *Json_case_handlerContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Json_case_handlerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Json_case_handlerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Json_case_handlerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterJson_case_handler(s)
	}
}

func (s *Json_case_handlerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitJson_case_handler(s)
	}
}

func (p *SQLv1Antlr4Parser) Json_case_handler() (localctx IJson_case_handlerContext) {
	localctx = NewJson_case_handlerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, SQLv1Antlr4ParserRULE_json_case_handler)
	p.SetState(1385)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserERROR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1381)
			p.Match(SQLv1Antlr4ParserERROR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserNULL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1382)
			p.Match(SQLv1Antlr4ParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserDEFAULT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1383)
			p.Match(SQLv1Antlr4ParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1384)
			p.Expr()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJson_valueContext is an interface to support dynamic dispatch.
type IJson_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JSON_VALUE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Json_common_args() IJson_common_argsContext
	RPAREN() antlr.TerminalNode
	RETURNING() antlr.TerminalNode
	Type_name_simple() IType_name_simpleContext
	AllJson_case_handler() []IJson_case_handlerContext
	Json_case_handler(i int) IJson_case_handlerContext
	AllON() []antlr.TerminalNode
	ON(i int) antlr.TerminalNode
	AllEMPTY() []antlr.TerminalNode
	EMPTY(i int) antlr.TerminalNode
	AllERROR() []antlr.TerminalNode
	ERROR(i int) antlr.TerminalNode

	// IsJson_valueContext differentiates from other interfaces.
	IsJson_valueContext()
}

type Json_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJson_valueContext() *Json_valueContext {
	var p = new(Json_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_value
	return p
}

func InitEmptyJson_valueContext(p *Json_valueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_value
}

func (*Json_valueContext) IsJson_valueContext() {}

func NewJson_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Json_valueContext {
	var p = new(Json_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_value

	return p
}

func (s *Json_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Json_valueContext) JSON_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserJSON_VALUE, 0)
}

func (s *Json_valueContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Json_valueContext) Json_common_args() IJson_common_argsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_common_argsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_common_argsContext)
}

func (s *Json_valueContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Json_valueContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRETURNING, 0)
}

func (s *Json_valueContext) Type_name_simple() IType_name_simpleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_simpleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_simpleContext)
}

func (s *Json_valueContext) AllJson_case_handler() []IJson_case_handlerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJson_case_handlerContext); ok {
			len++
		}
	}

	tst := make([]IJson_case_handlerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJson_case_handlerContext); ok {
			tst[i] = t.(IJson_case_handlerContext)
			i++
		}
	}

	return tst
}

func (s *Json_valueContext) Json_case_handler(i int) IJson_case_handlerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_case_handlerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_case_handlerContext)
}

func (s *Json_valueContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserON)
}

func (s *Json_valueContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserON, i)
}

func (s *Json_valueContext) AllEMPTY() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserEMPTY)
}

func (s *Json_valueContext) EMPTY(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEMPTY, i)
}

func (s *Json_valueContext) AllERROR() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserERROR)
}

func (s *Json_valueContext) ERROR(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserERROR, i)
}

func (s *Json_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Json_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Json_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterJson_value(s)
	}
}

func (s *Json_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitJson_value(s)
	}
}

func (p *SQLv1Antlr4Parser) Json_value() (localctx IJson_valueContext) {
	localctx = NewJson_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, SQLv1Antlr4ParserRULE_json_value)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1387)
		p.Match(SQLv1Antlr4ParserJSON_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1388)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1389)
		p.Json_common_args()
	}
	p.SetState(1392)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserRETURNING {
		{
			p.SetState(1390)
			p.Match(SQLv1Antlr4ParserRETURNING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1391)
			p.Type_name_simple()
		}

	}
	p.SetState(1400)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserDEFAULT || _la == SQLv1Antlr4ParserERROR || _la == SQLv1Antlr4ParserNULL {
		{
			p.SetState(1394)
			p.Json_case_handler()
		}
		{
			p.SetState(1395)
			p.Match(SQLv1Antlr4ParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1396)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLv1Antlr4ParserEMPTY || _la == SQLv1Antlr4ParserERROR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		p.SetState(1402)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1403)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJson_exists_handlerContext is an interface to support dynamic dispatch.
type IJson_exists_handlerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	AllERROR() []antlr.TerminalNode
	ERROR(i int) antlr.TerminalNode
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode
	UNKNOWN() antlr.TerminalNode

	// IsJson_exists_handlerContext differentiates from other interfaces.
	IsJson_exists_handlerContext()
}

type Json_exists_handlerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJson_exists_handlerContext() *Json_exists_handlerContext {
	var p = new(Json_exists_handlerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_exists_handler
	return p
}

func InitEmptyJson_exists_handlerContext(p *Json_exists_handlerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_exists_handler
}

func (*Json_exists_handlerContext) IsJson_exists_handlerContext() {}

func NewJson_exists_handlerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Json_exists_handlerContext {
	var p = new(Json_exists_handlerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_exists_handler

	return p
}

func (s *Json_exists_handlerContext) GetParser() antlr.Parser { return s.parser }

func (s *Json_exists_handlerContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserON, 0)
}

func (s *Json_exists_handlerContext) AllERROR() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserERROR)
}

func (s *Json_exists_handlerContext) ERROR(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserERROR, i)
}

func (s *Json_exists_handlerContext) TRUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTRUE, 0)
}

func (s *Json_exists_handlerContext) FALSE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFALSE, 0)
}

func (s *Json_exists_handlerContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUNKNOWN, 0)
}

func (s *Json_exists_handlerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Json_exists_handlerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Json_exists_handlerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterJson_exists_handler(s)
	}
}

func (s *Json_exists_handlerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitJson_exists_handler(s)
	}
}

func (p *SQLv1Antlr4Parser) Json_exists_handler() (localctx IJson_exists_handlerContext) {
	localctx = NewJson_exists_handlerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, SQLv1Antlr4ParserRULE_json_exists_handler)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1405)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLv1Antlr4ParserERROR || _la == SQLv1Antlr4ParserFALSE || _la == SQLv1Antlr4ParserTRUE || _la == SQLv1Antlr4ParserUNKNOWN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1406)
		p.Match(SQLv1Antlr4ParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1407)
		p.Match(SQLv1Antlr4ParserERROR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJson_existsContext is an interface to support dynamic dispatch.
type IJson_existsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JSON_EXISTS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Json_common_args() IJson_common_argsContext
	RPAREN() antlr.TerminalNode
	Json_exists_handler() IJson_exists_handlerContext

	// IsJson_existsContext differentiates from other interfaces.
	IsJson_existsContext()
}

type Json_existsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJson_existsContext() *Json_existsContext {
	var p = new(Json_existsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_exists
	return p
}

func InitEmptyJson_existsContext(p *Json_existsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_exists
}

func (*Json_existsContext) IsJson_existsContext() {}

func NewJson_existsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Json_existsContext {
	var p = new(Json_existsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_exists

	return p
}

func (s *Json_existsContext) GetParser() antlr.Parser { return s.parser }

func (s *Json_existsContext) JSON_EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserJSON_EXISTS, 0)
}

func (s *Json_existsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Json_existsContext) Json_common_args() IJson_common_argsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_common_argsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_common_argsContext)
}

func (s *Json_existsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Json_existsContext) Json_exists_handler() IJson_exists_handlerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_exists_handlerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_exists_handlerContext)
}

func (s *Json_existsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Json_existsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Json_existsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterJson_exists(s)
	}
}

func (s *Json_existsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitJson_exists(s)
	}
}

func (p *SQLv1Antlr4Parser) Json_exists() (localctx IJson_existsContext) {
	localctx = NewJson_existsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, SQLv1Antlr4ParserRULE_json_exists)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1409)
		p.Match(SQLv1Antlr4ParserJSON_EXISTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1410)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1411)
		p.Json_common_args()
	}
	p.SetState(1413)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserERROR || _la == SQLv1Antlr4ParserFALSE || _la == SQLv1Antlr4ParserTRUE || _la == SQLv1Antlr4ParserUNKNOWN {
		{
			p.SetState(1412)
			p.Json_exists_handler()
		}

	}
	{
		p.SetState(1415)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJson_query_wrapperContext is an interface to support dynamic dispatch.
type IJson_query_wrapperContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITHOUT() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	WITH() antlr.TerminalNode
	CONDITIONAL() antlr.TerminalNode
	UNCONDITIONAL() antlr.TerminalNode

	// IsJson_query_wrapperContext differentiates from other interfaces.
	IsJson_query_wrapperContext()
}

type Json_query_wrapperContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJson_query_wrapperContext() *Json_query_wrapperContext {
	var p = new(Json_query_wrapperContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_query_wrapper
	return p
}

func InitEmptyJson_query_wrapperContext(p *Json_query_wrapperContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_query_wrapper
}

func (*Json_query_wrapperContext) IsJson_query_wrapperContext() {}

func NewJson_query_wrapperContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Json_query_wrapperContext {
	var p = new(Json_query_wrapperContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_query_wrapper

	return p
}

func (s *Json_query_wrapperContext) GetParser() antlr.Parser { return s.parser }

func (s *Json_query_wrapperContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWITHOUT, 0)
}

func (s *Json_query_wrapperContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserARRAY, 0)
}

func (s *Json_query_wrapperContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWITH, 0)
}

func (s *Json_query_wrapperContext) CONDITIONAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCONDITIONAL, 0)
}

func (s *Json_query_wrapperContext) UNCONDITIONAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUNCONDITIONAL, 0)
}

func (s *Json_query_wrapperContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Json_query_wrapperContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Json_query_wrapperContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterJson_query_wrapper(s)
	}
}

func (s *Json_query_wrapperContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitJson_query_wrapper(s)
	}
}

func (p *SQLv1Antlr4Parser) Json_query_wrapper() (localctx IJson_query_wrapperContext) {
	localctx = NewJson_query_wrapperContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, SQLv1Antlr4ParserRULE_json_query_wrapper)
	var _la int

	p.SetState(1428)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserWITHOUT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1417)
			p.Match(SQLv1Antlr4ParserWITHOUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1419)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserARRAY {
			{
				p.SetState(1418)
				p.Match(SQLv1Antlr4ParserARRAY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case SQLv1Antlr4ParserWITH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1421)
			p.Match(SQLv1Antlr4ParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1423)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserCONDITIONAL || _la == SQLv1Antlr4ParserUNCONDITIONAL {
			{
				p.SetState(1422)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SQLv1Antlr4ParserCONDITIONAL || _la == SQLv1Antlr4ParserUNCONDITIONAL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1426)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserARRAY {
			{
				p.SetState(1425)
				p.Match(SQLv1Antlr4ParserARRAY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJson_query_handlerContext is an interface to support dynamic dispatch.
type IJson_query_handlerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ERROR() antlr.TerminalNode
	NULL() antlr.TerminalNode
	EMPTY() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	OBJECT() antlr.TerminalNode

	// IsJson_query_handlerContext differentiates from other interfaces.
	IsJson_query_handlerContext()
}

type Json_query_handlerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJson_query_handlerContext() *Json_query_handlerContext {
	var p = new(Json_query_handlerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_query_handler
	return p
}

func InitEmptyJson_query_handlerContext(p *Json_query_handlerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_query_handler
}

func (*Json_query_handlerContext) IsJson_query_handlerContext() {}

func NewJson_query_handlerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Json_query_handlerContext {
	var p = new(Json_query_handlerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_query_handler

	return p
}

func (s *Json_query_handlerContext) GetParser() antlr.Parser { return s.parser }

func (s *Json_query_handlerContext) ERROR() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserERROR, 0)
}

func (s *Json_query_handlerContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNULL, 0)
}

func (s *Json_query_handlerContext) EMPTY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEMPTY, 0)
}

func (s *Json_query_handlerContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserARRAY, 0)
}

func (s *Json_query_handlerContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOBJECT, 0)
}

func (s *Json_query_handlerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Json_query_handlerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Json_query_handlerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterJson_query_handler(s)
	}
}

func (s *Json_query_handlerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitJson_query_handler(s)
	}
}

func (p *SQLv1Antlr4Parser) Json_query_handler() (localctx IJson_query_handlerContext) {
	localctx = NewJson_query_handlerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, SQLv1Antlr4ParserRULE_json_query_handler)
	p.SetState(1436)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1430)
			p.Match(SQLv1Antlr4ParserERROR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1431)
			p.Match(SQLv1Antlr4ParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1432)
			p.Match(SQLv1Antlr4ParserEMPTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1433)
			p.Match(SQLv1Antlr4ParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1434)
			p.Match(SQLv1Antlr4ParserEMPTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1435)
			p.Match(SQLv1Antlr4ParserOBJECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJson_queryContext is an interface to support dynamic dispatch.
type IJson_queryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JSON_QUERY() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Json_common_args() IJson_common_argsContext
	RPAREN() antlr.TerminalNode
	Json_query_wrapper() IJson_query_wrapperContext
	WRAPPER() antlr.TerminalNode
	AllJson_query_handler() []IJson_query_handlerContext
	Json_query_handler(i int) IJson_query_handlerContext
	AllON() []antlr.TerminalNode
	ON(i int) antlr.TerminalNode
	EMPTY() antlr.TerminalNode
	ERROR() antlr.TerminalNode

	// IsJson_queryContext differentiates from other interfaces.
	IsJson_queryContext()
}

type Json_queryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJson_queryContext() *Json_queryContext {
	var p = new(Json_queryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_query
	return p
}

func InitEmptyJson_queryContext(p *Json_queryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_query
}

func (*Json_queryContext) IsJson_queryContext() {}

func NewJson_queryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Json_queryContext {
	var p = new(Json_queryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_json_query

	return p
}

func (s *Json_queryContext) GetParser() antlr.Parser { return s.parser }

func (s *Json_queryContext) JSON_QUERY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserJSON_QUERY, 0)
}

func (s *Json_queryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Json_queryContext) Json_common_args() IJson_common_argsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_common_argsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_common_argsContext)
}

func (s *Json_queryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Json_queryContext) Json_query_wrapper() IJson_query_wrapperContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_query_wrapperContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_query_wrapperContext)
}

func (s *Json_queryContext) WRAPPER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWRAPPER, 0)
}

func (s *Json_queryContext) AllJson_query_handler() []IJson_query_handlerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJson_query_handlerContext); ok {
			len++
		}
	}

	tst := make([]IJson_query_handlerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJson_query_handlerContext); ok {
			tst[i] = t.(IJson_query_handlerContext)
			i++
		}
	}

	return tst
}

func (s *Json_queryContext) Json_query_handler(i int) IJson_query_handlerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJson_query_handlerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJson_query_handlerContext)
}

func (s *Json_queryContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserON)
}

func (s *Json_queryContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserON, i)
}

func (s *Json_queryContext) EMPTY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEMPTY, 0)
}

func (s *Json_queryContext) ERROR() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserERROR, 0)
}

func (s *Json_queryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Json_queryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Json_queryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterJson_query(s)
	}
}

func (s *Json_queryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitJson_query(s)
	}
}

func (p *SQLv1Antlr4Parser) Json_query() (localctx IJson_queryContext) {
	localctx = NewJson_queryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, SQLv1Antlr4ParserRULE_json_query)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1438)
		p.Match(SQLv1Antlr4ParserJSON_QUERY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1439)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1440)
		p.Json_common_args()
	}
	p.SetState(1444)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserWITH || _la == SQLv1Antlr4ParserWITHOUT {
		{
			p.SetState(1441)
			p.Json_query_wrapper()
		}
		{
			p.SetState(1442)
			p.Match(SQLv1Antlr4ParserWRAPPER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1450)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 82, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1446)
			p.Json_query_handler()
		}
		{
			p.SetState(1447)
			p.Match(SQLv1Antlr4ParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1448)
			p.Match(SQLv1Antlr4ParserEMPTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1456)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserEMPTY || _la == SQLv1Antlr4ParserERROR || _la == SQLv1Antlr4ParserNULL {
		{
			p.SetState(1452)
			p.Json_query_handler()
		}
		{
			p.SetState(1453)
			p.Match(SQLv1Antlr4ParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1454)
			p.Match(SQLv1Antlr4ParserERROR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1458)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISmart_parenthesisContext is an interface to support dynamic dispatch.
type ISmart_parenthesisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Named_expr_list() INamed_expr_listContext
	COMMA() antlr.TerminalNode

	// IsSmart_parenthesisContext differentiates from other interfaces.
	IsSmart_parenthesisContext()
}

type Smart_parenthesisContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySmart_parenthesisContext() *Smart_parenthesisContext {
	var p = new(Smart_parenthesisContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_smart_parenthesis
	return p
}

func InitEmptySmart_parenthesisContext(p *Smart_parenthesisContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_smart_parenthesis
}

func (*Smart_parenthesisContext) IsSmart_parenthesisContext() {}

func NewSmart_parenthesisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Smart_parenthesisContext {
	var p = new(Smart_parenthesisContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_smart_parenthesis

	return p
}

func (s *Smart_parenthesisContext) GetParser() antlr.Parser { return s.parser }

func (s *Smart_parenthesisContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Smart_parenthesisContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Smart_parenthesisContext) Named_expr_list() INamed_expr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_expr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_expr_listContext)
}

func (s *Smart_parenthesisContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, 0)
}

func (s *Smart_parenthesisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Smart_parenthesisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Smart_parenthesisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSmart_parenthesis(s)
	}
}

func (s *Smart_parenthesisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSmart_parenthesis(s)
	}
}

func (p *SQLv1Antlr4Parser) Smart_parenthesis() (localctx ISmart_parenthesisContext) {
	localctx = NewSmart_parenthesisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, SQLv1Antlr4ParserRULE_smart_parenthesis)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1460)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1462)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-14)) & ^0x3f) == 0 && ((int64(1)<<(_la-14))&-562950217396195) != 0) || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&-1) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&-129) != 0) || ((int64((_la-206)) & ^0x3f) == 0 && ((int64(1)<<(_la-206))&-274877906945) != 0) || ((int64((_la-270)) & ^0x3f) == 0 && ((int64(1)<<(_la-270))&576460752303423487) != 0) {
		{
			p.SetState(1461)
			p.Named_expr_list()
		}

	}
	p.SetState(1465)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(1464)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1467)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_listContext is an interface to support dynamic dispatch.
type IExpr_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpr_listContext differentiates from other interfaces.
	IsExpr_listContext()
}

type Expr_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_listContext() *Expr_listContext {
	var p = new(Expr_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_expr_list
	return p
}

func InitEmptyExpr_listContext(p *Expr_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_expr_list
}

func (*Expr_listContext) IsExpr_listContext() {}

func NewExpr_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_listContext {
	var p = new(Expr_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_expr_list

	return p
}

func (s *Expr_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_listContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_listContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Expr_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Expr_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterExpr_list(s)
	}
}

func (s *Expr_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitExpr_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Expr_list() (localctx IExpr_listContext) {
	localctx = NewExpr_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, SQLv1Antlr4ParserRULE_expr_list)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1469)
		p.Expr()
	}
	p.SetState(1474)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1470)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1471)
				p.Expr()
			}

		}
		p.SetState(1476)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPure_column_listContext is an interface to support dynamic dispatch.
type IPure_column_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllAn_id() []IAn_idContext
	An_id(i int) IAn_idContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPure_column_listContext differentiates from other interfaces.
	IsPure_column_listContext()
}

type Pure_column_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPure_column_listContext() *Pure_column_listContext {
	var p = new(Pure_column_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_pure_column_list
	return p
}

func InitEmptyPure_column_listContext(p *Pure_column_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_pure_column_list
}

func (*Pure_column_listContext) IsPure_column_listContext() {}

func NewPure_column_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pure_column_listContext {
	var p = new(Pure_column_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_pure_column_list

	return p
}

func (s *Pure_column_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Pure_column_listContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Pure_column_listContext) AllAn_id() []IAn_idContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_idContext); ok {
			len++
		}
	}

	tst := make([]IAn_idContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_idContext); ok {
			tst[i] = t.(IAn_idContext)
			i++
		}
	}

	return tst
}

func (s *Pure_column_listContext) An_id(i int) IAn_idContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Pure_column_listContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Pure_column_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Pure_column_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Pure_column_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pure_column_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pure_column_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterPure_column_list(s)
	}
}

func (s *Pure_column_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitPure_column_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Pure_column_list() (localctx IPure_column_listContext) {
	localctx = NewPure_column_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, SQLv1Antlr4ParserRULE_pure_column_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1477)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1478)
		p.An_id()
	}
	p.SetState(1483)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(1479)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1480)
			p.An_id()
		}

		p.SetState(1485)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1486)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPure_column_or_namedContext is an interface to support dynamic dispatch.
type IPure_column_or_namedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Bind_parameter() IBind_parameterContext
	An_id() IAn_idContext

	// IsPure_column_or_namedContext differentiates from other interfaces.
	IsPure_column_or_namedContext()
}

type Pure_column_or_namedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPure_column_or_namedContext() *Pure_column_or_namedContext {
	var p = new(Pure_column_or_namedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_pure_column_or_named
	return p
}

func InitEmptyPure_column_or_namedContext(p *Pure_column_or_namedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_pure_column_or_named
}

func (*Pure_column_or_namedContext) IsPure_column_or_namedContext() {}

func NewPure_column_or_namedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pure_column_or_namedContext {
	var p = new(Pure_column_or_namedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_pure_column_or_named

	return p
}

func (s *Pure_column_or_namedContext) GetParser() antlr.Parser { return s.parser }

func (s *Pure_column_or_namedContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Pure_column_or_namedContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Pure_column_or_namedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pure_column_or_namedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pure_column_or_namedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterPure_column_or_named(s)
	}
}

func (s *Pure_column_or_namedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitPure_column_or_named(s)
	}
}

func (p *SQLv1Antlr4Parser) Pure_column_or_named() (localctx IPure_column_or_namedContext) {
	localctx = NewPure_column_or_namedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, SQLv1Antlr4ParserRULE_pure_column_or_named)
	p.SetState(1490)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserDOLLAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1488)
			p.Bind_parameter()
		}

	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALL, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserANY, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSTREAM, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWITHOUT, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserSTRING_VALUE, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1489)
			p.An_id()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPure_column_or_named_listContext is an interface to support dynamic dispatch.
type IPure_column_or_named_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllPure_column_or_named() []IPure_column_or_namedContext
	Pure_column_or_named(i int) IPure_column_or_namedContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPure_column_or_named_listContext differentiates from other interfaces.
	IsPure_column_or_named_listContext()
}

type Pure_column_or_named_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPure_column_or_named_listContext() *Pure_column_or_named_listContext {
	var p = new(Pure_column_or_named_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_pure_column_or_named_list
	return p
}

func InitEmptyPure_column_or_named_listContext(p *Pure_column_or_named_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_pure_column_or_named_list
}

func (*Pure_column_or_named_listContext) IsPure_column_or_named_listContext() {}

func NewPure_column_or_named_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pure_column_or_named_listContext {
	var p = new(Pure_column_or_named_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_pure_column_or_named_list

	return p
}

func (s *Pure_column_or_named_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Pure_column_or_named_listContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Pure_column_or_named_listContext) AllPure_column_or_named() []IPure_column_or_namedContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPure_column_or_namedContext); ok {
			len++
		}
	}

	tst := make([]IPure_column_or_namedContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPure_column_or_namedContext); ok {
			tst[i] = t.(IPure_column_or_namedContext)
			i++
		}
	}

	return tst
}

func (s *Pure_column_or_named_listContext) Pure_column_or_named(i int) IPure_column_or_namedContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPure_column_or_namedContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPure_column_or_namedContext)
}

func (s *Pure_column_or_named_listContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Pure_column_or_named_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Pure_column_or_named_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Pure_column_or_named_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pure_column_or_named_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pure_column_or_named_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterPure_column_or_named_list(s)
	}
}

func (s *Pure_column_or_named_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitPure_column_or_named_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Pure_column_or_named_list() (localctx IPure_column_or_named_listContext) {
	localctx = NewPure_column_or_named_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, SQLv1Antlr4ParserRULE_pure_column_or_named_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1492)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1493)
		p.Pure_column_or_named()
	}
	p.SetState(1498)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(1494)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1495)
			p.Pure_column_or_named()
		}

		p.SetState(1500)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1501)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumn_nameContext is an interface to support dynamic dispatch.
type IColumn_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Opt_id_prefix() IOpt_id_prefixContext
	An_id() IAn_idContext

	// IsColumn_nameContext differentiates from other interfaces.
	IsColumn_nameContext()
}

type Column_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_nameContext() *Column_nameContext {
	var p = new(Column_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_column_name
	return p
}

func InitEmptyColumn_nameContext(p *Column_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_column_name
}

func (*Column_nameContext) IsColumn_nameContext() {}

func NewColumn_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_nameContext {
	var p = new(Column_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_column_name

	return p
}

func (s *Column_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_nameContext) Opt_id_prefix() IOpt_id_prefixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_id_prefixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_id_prefixContext)
}

func (s *Column_nameContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Column_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Column_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterColumn_name(s)
	}
}

func (s *Column_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitColumn_name(s)
	}
}

func (p *SQLv1Antlr4Parser) Column_name() (localctx IColumn_nameContext) {
	localctx = NewColumn_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, SQLv1Antlr4ParserRULE_column_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1503)
		p.Opt_id_prefix()
	}
	{
		p.SetState(1504)
		p.An_id()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithout_column_nameContext is an interface to support dynamic dispatch.
type IWithout_column_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAn_id() []IAn_idContext
	An_id(i int) IAn_idContext
	DOT() antlr.TerminalNode
	An_id_without() IAn_id_withoutContext

	// IsWithout_column_nameContext differentiates from other interfaces.
	IsWithout_column_nameContext()
}

type Without_column_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithout_column_nameContext() *Without_column_nameContext {
	var p = new(Without_column_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_without_column_name
	return p
}

func InitEmptyWithout_column_nameContext(p *Without_column_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_without_column_name
}

func (*Without_column_nameContext) IsWithout_column_nameContext() {}

func NewWithout_column_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Without_column_nameContext {
	var p = new(Without_column_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_without_column_name

	return p
}

func (s *Without_column_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Without_column_nameContext) AllAn_id() []IAn_idContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_idContext); ok {
			len++
		}
	}

	tst := make([]IAn_idContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_idContext); ok {
			tst[i] = t.(IAn_idContext)
			i++
		}
	}

	return tst
}

func (s *Without_column_nameContext) An_id(i int) IAn_idContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Without_column_nameContext) DOT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDOT, 0)
}

func (s *Without_column_nameContext) An_id_without() IAn_id_withoutContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_withoutContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_withoutContext)
}

func (s *Without_column_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Without_column_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Without_column_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterWithout_column_name(s)
	}
}

func (s *Without_column_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitWithout_column_name(s)
	}
}

func (p *SQLv1Antlr4Parser) Without_column_name() (localctx IWithout_column_nameContext) {
	localctx = NewWithout_column_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, SQLv1Antlr4ParserRULE_without_column_name)
	p.SetState(1511)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 90, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1506)
			p.An_id()
		}
		{
			p.SetState(1507)
			p.Match(SQLv1Antlr4ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1508)
			p.An_id()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1510)
			p.An_id_without()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumn_listContext is an interface to support dynamic dispatch.
type IColumn_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumn_name() []IColumn_nameContext
	Column_name(i int) IColumn_nameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumn_listContext differentiates from other interfaces.
	IsColumn_listContext()
}

type Column_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_listContext() *Column_listContext {
	var p = new(Column_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_column_list
	return p
}

func InitEmptyColumn_listContext(p *Column_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_column_list
}

func (*Column_listContext) IsColumn_listContext() {}

func NewColumn_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_listContext {
	var p = new(Column_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_column_list

	return p
}

func (s *Column_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_listContext) AllColumn_name() []IColumn_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumn_nameContext); ok {
			len++
		}
	}

	tst := make([]IColumn_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumn_nameContext); ok {
			tst[i] = t.(IColumn_nameContext)
			i++
		}
	}

	return tst
}

func (s *Column_listContext) Column_name(i int) IColumn_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Column_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Column_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Column_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Column_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterColumn_list(s)
	}
}

func (s *Column_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitColumn_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Column_list() (localctx IColumn_listContext) {
	localctx = NewColumn_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, SQLv1Antlr4ParserRULE_column_list)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1513)
		p.Column_name()
	}
	p.SetState(1518)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1514)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1515)
				p.Column_name()
			}

		}
		p.SetState(1520)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1522)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(1521)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithout_column_listContext is an interface to support dynamic dispatch.
type IWithout_column_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllWithout_column_name() []IWithout_column_nameContext
	Without_column_name(i int) IWithout_column_nameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWithout_column_listContext differentiates from other interfaces.
	IsWithout_column_listContext()
}

type Without_column_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithout_column_listContext() *Without_column_listContext {
	var p = new(Without_column_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_without_column_list
	return p
}

func InitEmptyWithout_column_listContext(p *Without_column_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_without_column_list
}

func (*Without_column_listContext) IsWithout_column_listContext() {}

func NewWithout_column_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Without_column_listContext {
	var p = new(Without_column_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_without_column_list

	return p
}

func (s *Without_column_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Without_column_listContext) AllWithout_column_name() []IWithout_column_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWithout_column_nameContext); ok {
			len++
		}
	}

	tst := make([]IWithout_column_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWithout_column_nameContext); ok {
			tst[i] = t.(IWithout_column_nameContext)
			i++
		}
	}

	return tst
}

func (s *Without_column_listContext) Without_column_name(i int) IWithout_column_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithout_column_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithout_column_nameContext)
}

func (s *Without_column_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Without_column_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Without_column_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Without_column_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Without_column_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterWithout_column_list(s)
	}
}

func (s *Without_column_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitWithout_column_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Without_column_list() (localctx IWithout_column_listContext) {
	localctx = NewWithout_column_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, SQLv1Antlr4ParserRULE_without_column_list)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1524)
		p.Without_column_name()
	}
	p.SetState(1529)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1525)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1526)
				p.Without_column_name()
			}

		}
		p.SetState(1531)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1533)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(1532)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamed_exprContext is an interface to support dynamic dispatch.
type INamed_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	AS() antlr.TerminalNode
	An_id_or_type() IAn_id_or_typeContext

	// IsNamed_exprContext differentiates from other interfaces.
	IsNamed_exprContext()
}

type Named_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_exprContext() *Named_exprContext {
	var p = new(Named_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_named_expr
	return p
}

func InitEmptyNamed_exprContext(p *Named_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_named_expr
}

func (*Named_exprContext) IsNamed_exprContext() {}

func NewNamed_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_exprContext {
	var p = new(Named_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_named_expr

	return p
}

func (s *Named_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_exprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Named_exprContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAS, 0)
}

func (s *Named_exprContext) An_id_or_type() IAn_id_or_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_or_typeContext)
}

func (s *Named_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Named_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterNamed_expr(s)
	}
}

func (s *Named_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitNamed_expr(s)
	}
}

func (p *SQLv1Antlr4Parser) Named_expr() (localctx INamed_exprContext) {
	localctx = NewNamed_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, SQLv1Antlr4ParserRULE_named_expr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1535)
		p.Expr()
	}
	p.SetState(1538)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserAS {
		{
			p.SetState(1536)
			p.Match(SQLv1Antlr4ParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1537)
			p.An_id_or_type()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamed_expr_listContext is an interface to support dynamic dispatch.
type INamed_expr_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNamed_expr() []INamed_exprContext
	Named_expr(i int) INamed_exprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsNamed_expr_listContext differentiates from other interfaces.
	IsNamed_expr_listContext()
}

type Named_expr_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_expr_listContext() *Named_expr_listContext {
	var p = new(Named_expr_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_named_expr_list
	return p
}

func InitEmptyNamed_expr_listContext(p *Named_expr_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_named_expr_list
}

func (*Named_expr_listContext) IsNamed_expr_listContext() {}

func NewNamed_expr_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_expr_listContext {
	var p = new(Named_expr_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_named_expr_list

	return p
}

func (s *Named_expr_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_expr_listContext) AllNamed_expr() []INamed_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamed_exprContext); ok {
			len++
		}
	}

	tst := make([]INamed_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamed_exprContext); ok {
			tst[i] = t.(INamed_exprContext)
			i++
		}
	}

	return tst
}

func (s *Named_expr_listContext) Named_expr(i int) INamed_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_exprContext)
}

func (s *Named_expr_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Named_expr_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Named_expr_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_expr_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Named_expr_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterNamed_expr_list(s)
	}
}

func (s *Named_expr_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitNamed_expr_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Named_expr_list() (localctx INamed_expr_listContext) {
	localctx = NewNamed_expr_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, SQLv1Antlr4ParserRULE_named_expr_list)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1540)
		p.Named_expr()
	}
	p.SetState(1545)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1541)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1542)
				p.Named_expr()
			}

		}
		p.SetState(1547)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInvoke_exprContext is an interface to support dynamic dispatch.
type IInvoke_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Invoke_expr_tail() IInvoke_expr_tailContext
	Opt_set_quantifier() IOpt_set_quantifierContext
	Named_expr_list() INamed_expr_listContext
	ASTERISK() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsInvoke_exprContext differentiates from other interfaces.
	IsInvoke_exprContext()
}

type Invoke_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInvoke_exprContext() *Invoke_exprContext {
	var p = new(Invoke_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_invoke_expr
	return p
}

func InitEmptyInvoke_exprContext(p *Invoke_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_invoke_expr
}

func (*Invoke_exprContext) IsInvoke_exprContext() {}

func NewInvoke_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Invoke_exprContext {
	var p = new(Invoke_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_invoke_expr

	return p
}

func (s *Invoke_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Invoke_exprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Invoke_exprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Invoke_exprContext) Invoke_expr_tail() IInvoke_expr_tailContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInvoke_expr_tailContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInvoke_expr_tailContext)
}

func (s *Invoke_exprContext) Opt_set_quantifier() IOpt_set_quantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_set_quantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_set_quantifierContext)
}

func (s *Invoke_exprContext) Named_expr_list() INamed_expr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_expr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_expr_listContext)
}

func (s *Invoke_exprContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserASTERISK, 0)
}

func (s *Invoke_exprContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, 0)
}

func (s *Invoke_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Invoke_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Invoke_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterInvoke_expr(s)
	}
}

func (s *Invoke_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitInvoke_expr(s)
	}
}

func (p *SQLv1Antlr4Parser) Invoke_expr() (localctx IInvoke_exprContext) {
	localctx = NewInvoke_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, SQLv1Antlr4ParserRULE_invoke_expr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1548)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1555)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserSTRUCT_OPEN, SQLv1Antlr4ParserPLUS, SQLv1Antlr4ParserMINUS, SQLv1Antlr4ParserTILDA, SQLv1Antlr4ParserLPAREN, SQLv1Antlr4ParserDOLLAR, SQLv1Antlr4ParserLBRACE_CURLY, SQLv1Antlr4ParserLBRACE_SQUARE, SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALL, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserANY, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCALLABLE, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDICT, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserENUM, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFALSE, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFLOW, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserLIST, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOPTIONAL, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESOURCE, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSET, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSTREAM, SQLv1Antlr4ParserSTRUCT, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTAGGED, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTRUE, SQLv1Antlr4ParserTUPLE, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVARIANT, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWITHOUT, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserSTRING_VALUE, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED, SQLv1Antlr4ParserDIGITS, SQLv1Antlr4ParserINTEGER_VALUE, SQLv1Antlr4ParserREAL, SQLv1Antlr4ParserBLOB:
		{
			p.SetState(1549)
			p.Opt_set_quantifier()
		}
		{
			p.SetState(1550)
			p.Named_expr_list()
		}
		p.SetState(1552)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserCOMMA {
			{
				p.SetState(1551)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case SQLv1Antlr4ParserASTERISK:
		{
			p.SetState(1554)
			p.Match(SQLv1Antlr4ParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserRPAREN:

	default:
	}
	{
		p.SetState(1557)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1558)
		p.Invoke_expr_tail()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInvoke_expr_tailContext is an interface to support dynamic dispatch.
type IInvoke_expr_tailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Null_treatment() INull_treatmentContext
	Filter_clause() IFilter_clauseContext
	OVER() antlr.TerminalNode
	Window_name_or_specification() IWindow_name_or_specificationContext

	// IsInvoke_expr_tailContext differentiates from other interfaces.
	IsInvoke_expr_tailContext()
}

type Invoke_expr_tailContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInvoke_expr_tailContext() *Invoke_expr_tailContext {
	var p = new(Invoke_expr_tailContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_invoke_expr_tail
	return p
}

func InitEmptyInvoke_expr_tailContext(p *Invoke_expr_tailContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_invoke_expr_tail
}

func (*Invoke_expr_tailContext) IsInvoke_expr_tailContext() {}

func NewInvoke_expr_tailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Invoke_expr_tailContext {
	var p = new(Invoke_expr_tailContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_invoke_expr_tail

	return p
}

func (s *Invoke_expr_tailContext) GetParser() antlr.Parser { return s.parser }

func (s *Invoke_expr_tailContext) Null_treatment() INull_treatmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INull_treatmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INull_treatmentContext)
}

func (s *Invoke_expr_tailContext) Filter_clause() IFilter_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilter_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilter_clauseContext)
}

func (s *Invoke_expr_tailContext) OVER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOVER, 0)
}

func (s *Invoke_expr_tailContext) Window_name_or_specification() IWindow_name_or_specificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_name_or_specificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_name_or_specificationContext)
}

func (s *Invoke_expr_tailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Invoke_expr_tailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Invoke_expr_tailContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterInvoke_expr_tail(s)
	}
}

func (s *Invoke_expr_tailContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitInvoke_expr_tail(s)
	}
}

func (p *SQLv1Antlr4Parser) Invoke_expr_tail() (localctx IInvoke_expr_tailContext) {
	localctx = NewInvoke_expr_tailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, SQLv1Antlr4ParserRULE_invoke_expr_tail)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1562)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1560)
			p.Null_treatment()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1561)
			p.Filter_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1566)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserOVER {
		{
			p.SetState(1564)
			p.Match(SQLv1Antlr4ParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1565)
			p.Window_name_or_specification()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsing_call_exprContext is an interface to support dynamic dispatch.
type IUsing_call_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Invoke_expr() IInvoke_exprContext
	AllAn_id_or_type() []IAn_id_or_typeContext
	An_id_or_type(i int) IAn_id_or_typeContext
	NAMESPACE() antlr.TerminalNode
	An_id_expr() IAn_id_exprContext
	Bind_parameter() IBind_parameterContext
	EXTERNAL() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode

	// IsUsing_call_exprContext differentiates from other interfaces.
	IsUsing_call_exprContext()
}

type Using_call_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsing_call_exprContext() *Using_call_exprContext {
	var p = new(Using_call_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_using_call_expr
	return p
}

func InitEmptyUsing_call_exprContext(p *Using_call_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_using_call_expr
}

func (*Using_call_exprContext) IsUsing_call_exprContext() {}

func NewUsing_call_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Using_call_exprContext {
	var p = new(Using_call_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_using_call_expr

	return p
}

func (s *Using_call_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Using_call_exprContext) Invoke_expr() IInvoke_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInvoke_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInvoke_exprContext)
}

func (s *Using_call_exprContext) AllAn_id_or_type() []IAn_id_or_typeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			len++
		}
	}

	tst := make([]IAn_id_or_typeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_id_or_typeContext); ok {
			tst[i] = t.(IAn_id_or_typeContext)
			i++
		}
	}

	return tst
}

func (s *Using_call_exprContext) An_id_or_type(i int) IAn_id_or_typeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_or_typeContext)
}

func (s *Using_call_exprContext) NAMESPACE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNAMESPACE, 0)
}

func (s *Using_call_exprContext) An_id_expr() IAn_id_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_exprContext)
}

func (s *Using_call_exprContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Using_call_exprContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXTERNAL, 0)
}

func (s *Using_call_exprContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFUNCTION, 0)
}

func (s *Using_call_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Using_call_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Using_call_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterUsing_call_expr(s)
	}
}

func (s *Using_call_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitUsing_call_expr(s)
	}
}

func (p *SQLv1Antlr4Parser) Using_call_expr() (localctx IUsing_call_exprContext) {
	localctx = NewUsing_call_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, SQLv1Antlr4ParserRULE_using_call_expr)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1576)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1568)
			p.An_id_or_type()
		}
		{
			p.SetState(1569)
			p.Match(SQLv1Antlr4ParserNAMESPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1570)
			p.An_id_or_type()
		}

	case 2:
		{
			p.SetState(1572)
			p.An_id_expr()
		}

	case 3:
		{
			p.SetState(1573)
			p.Bind_parameter()
		}

	case 4:
		{
			p.SetState(1574)
			p.Match(SQLv1Antlr4ParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1575)
			p.Match(SQLv1Antlr4ParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(1578)
		p.Invoke_expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKey_exprContext is an interface to support dynamic dispatch.
type IKey_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE_SQUARE() antlr.TerminalNode
	Expr() IExprContext
	RBRACE_SQUARE() antlr.TerminalNode

	// IsKey_exprContext differentiates from other interfaces.
	IsKey_exprContext()
}

type Key_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKey_exprContext() *Key_exprContext {
	var p = new(Key_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_key_expr
	return p
}

func InitEmptyKey_exprContext(p *Key_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_key_expr
}

func (*Key_exprContext) IsKey_exprContext() {}

func NewKey_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Key_exprContext {
	var p = new(Key_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_key_expr

	return p
}

func (s *Key_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Key_exprContext) LBRACE_SQUARE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLBRACE_SQUARE, 0)
}

func (s *Key_exprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Key_exprContext) RBRACE_SQUARE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRBRACE_SQUARE, 0)
}

func (s *Key_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Key_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Key_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterKey_expr(s)
	}
}

func (s *Key_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitKey_expr(s)
	}
}

func (p *SQLv1Antlr4Parser) Key_expr() (localctx IKey_exprContext) {
	localctx = NewKey_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, SQLv1Antlr4ParserRULE_key_expr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1580)
		p.Match(SQLv1Antlr4ParserLBRACE_SQUARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1581)
		p.Expr()
	}
	{
		p.SetState(1582)
		p.Match(SQLv1Antlr4ParserRBRACE_SQUARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhen_exprContext is an interface to support dynamic dispatch.
type IWhen_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHEN() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	THEN() antlr.TerminalNode

	// IsWhen_exprContext differentiates from other interfaces.
	IsWhen_exprContext()
}

type When_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhen_exprContext() *When_exprContext {
	var p = new(When_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_when_expr
	return p
}

func InitEmptyWhen_exprContext(p *When_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_when_expr
}

func (*When_exprContext) IsWhen_exprContext() {}

func NewWhen_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *When_exprContext {
	var p = new(When_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_when_expr

	return p
}

func (s *When_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *When_exprContext) WHEN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWHEN, 0)
}

func (s *When_exprContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *When_exprContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *When_exprContext) THEN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTHEN, 0)
}

func (s *When_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *When_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *When_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterWhen_expr(s)
	}
}

func (s *When_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitWhen_expr(s)
	}
}

func (p *SQLv1Antlr4Parser) When_expr() (localctx IWhen_exprContext) {
	localctx = NewWhen_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, SQLv1Antlr4ParserRULE_when_expr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1584)
		p.Match(SQLv1Antlr4ParserWHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1585)
		p.Expr()
	}
	{
		p.SetState(1586)
		p.Match(SQLv1Antlr4ParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1587)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteral_valueContext is an interface to support dynamic dispatch.
type ILiteral_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Integer() IIntegerContext
	Real_() IRealContext
	STRING_VALUE() antlr.TerminalNode
	BLOB() antlr.TerminalNode
	NULL() antlr.TerminalNode
	CURRENT_TIME() antlr.TerminalNode
	CURRENT_DATE() antlr.TerminalNode
	CURRENT_TIMESTAMP() antlr.TerminalNode
	Bool_value() IBool_valueContext
	EMPTY_ACTION() antlr.TerminalNode

	// IsLiteral_valueContext differentiates from other interfaces.
	IsLiteral_valueContext()
}

type Literal_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteral_valueContext() *Literal_valueContext {
	var p = new(Literal_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_literal_value
	return p
}

func InitEmptyLiteral_valueContext(p *Literal_valueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_literal_value
}

func (*Literal_valueContext) IsLiteral_valueContext() {}

func NewLiteral_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Literal_valueContext {
	var p = new(Literal_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_literal_value

	return p
}

func (s *Literal_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Literal_valueContext) Integer() IIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerContext)
}

func (s *Literal_valueContext) Real_() IRealContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRealContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRealContext)
}

func (s *Literal_valueContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRING_VALUE, 0)
}

func (s *Literal_valueContext) BLOB() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserBLOB, 0)
}

func (s *Literal_valueContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNULL, 0)
}

func (s *Literal_valueContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCURRENT_TIME, 0)
}

func (s *Literal_valueContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCURRENT_DATE, 0)
}

func (s *Literal_valueContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCURRENT_TIMESTAMP, 0)
}

func (s *Literal_valueContext) Bool_value() IBool_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_valueContext)
}

func (s *Literal_valueContext) EMPTY_ACTION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEMPTY_ACTION, 0)
}

func (s *Literal_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Literal_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Literal_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterLiteral_value(s)
	}
}

func (s *Literal_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitLiteral_value(s)
	}
}

func (p *SQLv1Antlr4Parser) Literal_value() (localctx ILiteral_valueContext) {
	localctx = NewLiteral_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, SQLv1Antlr4ParserRULE_literal_value)
	p.SetState(1599)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserDIGITS, SQLv1Antlr4ParserINTEGER_VALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1589)
			p.Integer()
		}

	case SQLv1Antlr4ParserREAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1590)
			p.Real_()
		}

	case SQLv1Antlr4ParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1591)
			p.Match(SQLv1Antlr4ParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserBLOB:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1592)
			p.Match(SQLv1Antlr4ParserBLOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserNULL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1593)
			p.Match(SQLv1Antlr4ParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserCURRENT_TIME:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1594)
			p.Match(SQLv1Antlr4ParserCURRENT_TIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserCURRENT_DATE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1595)
			p.Match(SQLv1Antlr4ParserCURRENT_DATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserCURRENT_TIMESTAMP:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1596)
			p.Match(SQLv1Antlr4ParserCURRENT_TIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserFALSE, SQLv1Antlr4ParserTRUE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1597)
			p.Bool_value()
		}

	case SQLv1Antlr4ParserEMPTY_ACTION:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1598)
			p.Match(SQLv1Antlr4ParserEMPTY_ACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBind_parameterContext is an interface to support dynamic dispatch.
type IBind_parameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOLLAR() antlr.TerminalNode
	An_id_or_type() IAn_id_or_typeContext
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBind_parameterContext differentiates from other interfaces.
	IsBind_parameterContext()
}

type Bind_parameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBind_parameterContext() *Bind_parameterContext {
	var p = new(Bind_parameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_bind_parameter
	return p
}

func InitEmptyBind_parameterContext(p *Bind_parameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_bind_parameter
}

func (*Bind_parameterContext) IsBind_parameterContext() {}

func NewBind_parameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bind_parameterContext {
	var p = new(Bind_parameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_bind_parameter

	return p
}

func (s *Bind_parameterContext) GetParser() antlr.Parser { return s.parser }

func (s *Bind_parameterContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDOLLAR, 0)
}

func (s *Bind_parameterContext) An_id_or_type() IAn_id_or_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_or_typeContext)
}

func (s *Bind_parameterContext) TRUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTRUE, 0)
}

func (s *Bind_parameterContext) FALSE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFALSE, 0)
}

func (s *Bind_parameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_parameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bind_parameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterBind_parameter(s)
	}
}

func (s *Bind_parameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitBind_parameter(s)
	}
}

func (p *SQLv1Antlr4Parser) Bind_parameter() (localctx IBind_parameterContext) {
	localctx = NewBind_parameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, SQLv1Antlr4ParserRULE_bind_parameter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1601)
		p.Match(SQLv1Antlr4ParserDOLLAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1605)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALL, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserANY, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCALLABLE, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDICT, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserENUM, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFLOW, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserLIST, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOPTIONAL, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESOURCE, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSET, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSTREAM, SQLv1Antlr4ParserSTRUCT, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTAGGED, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTUPLE, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVARIANT, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWITHOUT, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserSTRING_VALUE, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		{
			p.SetState(1602)
			p.An_id_or_type()
		}

	case SQLv1Antlr4ParserTRUE:
		{
			p.SetState(1603)
			p.Match(SQLv1Antlr4ParserTRUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserFALSE:
		{
			p.SetState(1604)
			p.Match(SQLv1Antlr4ParserFALSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_bind_parameterContext is an interface to support dynamic dispatch.
type IOpt_bind_parameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Bind_parameter() IBind_parameterContext
	QUESTION() antlr.TerminalNode

	// IsOpt_bind_parameterContext differentiates from other interfaces.
	IsOpt_bind_parameterContext()
}

type Opt_bind_parameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_bind_parameterContext() *Opt_bind_parameterContext {
	var p = new(Opt_bind_parameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_opt_bind_parameter
	return p
}

func InitEmptyOpt_bind_parameterContext(p *Opt_bind_parameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_opt_bind_parameter
}

func (*Opt_bind_parameterContext) IsOpt_bind_parameterContext() {}

func NewOpt_bind_parameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_bind_parameterContext {
	var p = new(Opt_bind_parameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_opt_bind_parameter

	return p
}

func (s *Opt_bind_parameterContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_bind_parameterContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Opt_bind_parameterContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserQUESTION, 0)
}

func (s *Opt_bind_parameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_bind_parameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_bind_parameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterOpt_bind_parameter(s)
	}
}

func (s *Opt_bind_parameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitOpt_bind_parameter(s)
	}
}

func (p *SQLv1Antlr4Parser) Opt_bind_parameter() (localctx IOpt_bind_parameterContext) {
	localctx = NewOpt_bind_parameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, SQLv1Antlr4ParserRULE_opt_bind_parameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1607)
		p.Bind_parameter()
	}
	p.SetState(1609)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserQUESTION {
		{
			p.SetState(1608)
			p.Match(SQLv1Antlr4ParserQUESTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBind_parameter_listContext is an interface to support dynamic dispatch.
type IBind_parameter_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBind_parameter() []IBind_parameterContext
	Bind_parameter(i int) IBind_parameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsBind_parameter_listContext differentiates from other interfaces.
	IsBind_parameter_listContext()
}

type Bind_parameter_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBind_parameter_listContext() *Bind_parameter_listContext {
	var p = new(Bind_parameter_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_bind_parameter_list
	return p
}

func InitEmptyBind_parameter_listContext(p *Bind_parameter_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_bind_parameter_list
}

func (*Bind_parameter_listContext) IsBind_parameter_listContext() {}

func NewBind_parameter_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bind_parameter_listContext {
	var p = new(Bind_parameter_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_bind_parameter_list

	return p
}

func (s *Bind_parameter_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Bind_parameter_listContext) AllBind_parameter() []IBind_parameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBind_parameterContext); ok {
			len++
		}
	}

	tst := make([]IBind_parameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBind_parameterContext); ok {
			tst[i] = t.(IBind_parameterContext)
			i++
		}
	}

	return tst
}

func (s *Bind_parameter_listContext) Bind_parameter(i int) IBind_parameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Bind_parameter_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Bind_parameter_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Bind_parameter_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_parameter_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bind_parameter_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterBind_parameter_list(s)
	}
}

func (s *Bind_parameter_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitBind_parameter_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Bind_parameter_list() (localctx IBind_parameter_listContext) {
	localctx = NewBind_parameter_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, SQLv1Antlr4ParserRULE_bind_parameter_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1611)
		p.Bind_parameter()
	}
	p.SetState(1616)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(1612)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1613)
			p.Bind_parameter()
		}

		p.SetState(1618)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamed_bind_parameterContext is an interface to support dynamic dispatch.
type INamed_bind_parameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBind_parameter() []IBind_parameterContext
	Bind_parameter(i int) IBind_parameterContext
	AS() antlr.TerminalNode

	// IsNamed_bind_parameterContext differentiates from other interfaces.
	IsNamed_bind_parameterContext()
}

type Named_bind_parameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_bind_parameterContext() *Named_bind_parameterContext {
	var p = new(Named_bind_parameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_named_bind_parameter
	return p
}

func InitEmptyNamed_bind_parameterContext(p *Named_bind_parameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_named_bind_parameter
}

func (*Named_bind_parameterContext) IsNamed_bind_parameterContext() {}

func NewNamed_bind_parameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_bind_parameterContext {
	var p = new(Named_bind_parameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_named_bind_parameter

	return p
}

func (s *Named_bind_parameterContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_bind_parameterContext) AllBind_parameter() []IBind_parameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBind_parameterContext); ok {
			len++
		}
	}

	tst := make([]IBind_parameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBind_parameterContext); ok {
			tst[i] = t.(IBind_parameterContext)
			i++
		}
	}

	return tst
}

func (s *Named_bind_parameterContext) Bind_parameter(i int) IBind_parameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Named_bind_parameterContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAS, 0)
}

func (s *Named_bind_parameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_bind_parameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Named_bind_parameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterNamed_bind_parameter(s)
	}
}

func (s *Named_bind_parameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitNamed_bind_parameter(s)
	}
}

func (p *SQLv1Antlr4Parser) Named_bind_parameter() (localctx INamed_bind_parameterContext) {
	localctx = NewNamed_bind_parameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, SQLv1Antlr4ParserRULE_named_bind_parameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1619)
		p.Bind_parameter()
	}
	p.SetState(1622)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserAS {
		{
			p.SetState(1620)
			p.Match(SQLv1Antlr4ParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1621)
			p.Bind_parameter()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamed_bind_parameter_listContext is an interface to support dynamic dispatch.
type INamed_bind_parameter_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNamed_bind_parameter() []INamed_bind_parameterContext
	Named_bind_parameter(i int) INamed_bind_parameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsNamed_bind_parameter_listContext differentiates from other interfaces.
	IsNamed_bind_parameter_listContext()
}

type Named_bind_parameter_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_bind_parameter_listContext() *Named_bind_parameter_listContext {
	var p = new(Named_bind_parameter_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_named_bind_parameter_list
	return p
}

func InitEmptyNamed_bind_parameter_listContext(p *Named_bind_parameter_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_named_bind_parameter_list
}

func (*Named_bind_parameter_listContext) IsNamed_bind_parameter_listContext() {}

func NewNamed_bind_parameter_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_bind_parameter_listContext {
	var p = new(Named_bind_parameter_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_named_bind_parameter_list

	return p
}

func (s *Named_bind_parameter_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_bind_parameter_listContext) AllNamed_bind_parameter() []INamed_bind_parameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamed_bind_parameterContext); ok {
			len++
		}
	}

	tst := make([]INamed_bind_parameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamed_bind_parameterContext); ok {
			tst[i] = t.(INamed_bind_parameterContext)
			i++
		}
	}

	return tst
}

func (s *Named_bind_parameter_listContext) Named_bind_parameter(i int) INamed_bind_parameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_bind_parameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_bind_parameterContext)
}

func (s *Named_bind_parameter_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Named_bind_parameter_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Named_bind_parameter_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_bind_parameter_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Named_bind_parameter_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterNamed_bind_parameter_list(s)
	}
}

func (s *Named_bind_parameter_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitNamed_bind_parameter_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Named_bind_parameter_list() (localctx INamed_bind_parameter_listContext) {
	localctx = NewNamed_bind_parameter_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, SQLv1Antlr4ParserRULE_named_bind_parameter_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1624)
		p.Named_bind_parameter()
	}
	p.SetState(1629)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(1625)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1626)
			p.Named_bind_parameter()
		}

		p.SetState(1631)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISigned_numberContext is an interface to support dynamic dispatch.
type ISigned_numberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Integer() IIntegerContext
	Real_() IRealContext
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsSigned_numberContext differentiates from other interfaces.
	IsSigned_numberContext()
}

type Signed_numberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySigned_numberContext() *Signed_numberContext {
	var p = new(Signed_numberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_signed_number
	return p
}

func InitEmptySigned_numberContext(p *Signed_numberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_signed_number
}

func (*Signed_numberContext) IsSigned_numberContext() {}

func NewSigned_numberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Signed_numberContext {
	var p = new(Signed_numberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_signed_number

	return p
}

func (s *Signed_numberContext) GetParser() antlr.Parser { return s.parser }

func (s *Signed_numberContext) Integer() IIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerContext)
}

func (s *Signed_numberContext) Real_() IRealContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRealContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRealContext)
}

func (s *Signed_numberContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPLUS, 0)
}

func (s *Signed_numberContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMINUS, 0)
}

func (s *Signed_numberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Signed_numberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Signed_numberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSigned_number(s)
	}
}

func (s *Signed_numberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSigned_number(s)
	}
}

func (p *SQLv1Antlr4Parser) Signed_number() (localctx ISigned_numberContext) {
	localctx = NewSigned_numberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, SQLv1Antlr4ParserRULE_signed_number)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1633)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserPLUS || _la == SQLv1Antlr4ParserMINUS {
		{
			p.SetState(1632)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLv1Antlr4ParserPLUS || _la == SQLv1Antlr4ParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1637)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserDIGITS, SQLv1Antlr4ParserINTEGER_VALUE:
		{
			p.SetState(1635)
			p.Integer()
		}

	case SQLv1Antlr4ParserREAL:
		{
			p.SetState(1636)
			p.Real_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_name_simpleContext is an interface to support dynamic dispatch.
type IType_name_simpleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id_pure() IAn_id_pureContext

	// IsType_name_simpleContext differentiates from other interfaces.
	IsType_name_simpleContext()
}

type Type_name_simpleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_simpleContext() *Type_name_simpleContext {
	var p = new(Type_name_simpleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_simple
	return p
}

func InitEmptyType_name_simpleContext(p *Type_name_simpleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_simple
}

func (*Type_name_simpleContext) IsType_name_simpleContext() {}

func NewType_name_simpleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_simpleContext {
	var p = new(Type_name_simpleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_simple

	return p
}

func (s *Type_name_simpleContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_simpleContext) An_id_pure() IAn_id_pureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_pureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_pureContext)
}

func (s *Type_name_simpleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_simpleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_name_simpleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterType_name_simple(s)
	}
}

func (s *Type_name_simpleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitType_name_simple(s)
	}
}

func (p *SQLv1Antlr4Parser) Type_name_simple() (localctx IType_name_simpleContext) {
	localctx = NewType_name_simpleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, SQLv1Antlr4ParserRULE_type_name_simple)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1639)
		p.An_id_pure()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInteger_or_bindContext is an interface to support dynamic dispatch.
type IInteger_or_bindContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Integer() IIntegerContext
	Bind_parameter() IBind_parameterContext

	// IsInteger_or_bindContext differentiates from other interfaces.
	IsInteger_or_bindContext()
}

type Integer_or_bindContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInteger_or_bindContext() *Integer_or_bindContext {
	var p = new(Integer_or_bindContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_integer_or_bind
	return p
}

func InitEmptyInteger_or_bindContext(p *Integer_or_bindContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_integer_or_bind
}

func (*Integer_or_bindContext) IsInteger_or_bindContext() {}

func NewInteger_or_bindContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Integer_or_bindContext {
	var p = new(Integer_or_bindContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_integer_or_bind

	return p
}

func (s *Integer_or_bindContext) GetParser() antlr.Parser { return s.parser }

func (s *Integer_or_bindContext) Integer() IIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerContext)
}

func (s *Integer_or_bindContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Integer_or_bindContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Integer_or_bindContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Integer_or_bindContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterInteger_or_bind(s)
	}
}

func (s *Integer_or_bindContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitInteger_or_bind(s)
	}
}

func (p *SQLv1Antlr4Parser) Integer_or_bind() (localctx IInteger_or_bindContext) {
	localctx = NewInteger_or_bindContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, SQLv1Antlr4ParserRULE_integer_or_bind)
	p.SetState(1643)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserDIGITS, SQLv1Antlr4ParserINTEGER_VALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1641)
			p.Integer()
		}

	case SQLv1Antlr4ParserDOLLAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1642)
			p.Bind_parameter()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_name_tagContext is an interface to support dynamic dispatch.
type IType_name_tagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id() IIdContext
	STRING_VALUE() antlr.TerminalNode
	Bind_parameter() IBind_parameterContext

	// IsType_name_tagContext differentiates from other interfaces.
	IsType_name_tagContext()
}

type Type_name_tagContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_tagContext() *Type_name_tagContext {
	var p = new(Type_name_tagContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_tag
	return p
}

func InitEmptyType_name_tagContext(p *Type_name_tagContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_tag
}

func (*Type_name_tagContext) IsType_name_tagContext() {}

func NewType_name_tagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_tagContext {
	var p = new(Type_name_tagContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_tag

	return p
}

func (s *Type_name_tagContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_tagContext) Id() IIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *Type_name_tagContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRING_VALUE, 0)
}

func (s *Type_name_tagContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Type_name_tagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_tagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_name_tagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterType_name_tag(s)
	}
}

func (s *Type_name_tagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitType_name_tag(s)
	}
}

func (p *SQLv1Antlr4Parser) Type_name_tag() (localctx IType_name_tagContext) {
	localctx = NewType_name_tagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, SQLv1Antlr4ParserRULE_type_name_tag)
	p.SetState(1648)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALL, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserANY, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSTREAM, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWITHOUT, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1645)
			p.Id()
		}

	case SQLv1Antlr4ParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1646)
			p.Match(SQLv1Antlr4ParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserDOLLAR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1647)
			p.Bind_parameter()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStruct_argContext is an interface to support dynamic dispatch.
type IStruct_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_name_tag() IType_name_tagContext
	COLON() antlr.TerminalNode
	Type_name_or_bind() IType_name_or_bindContext

	// IsStruct_argContext differentiates from other interfaces.
	IsStruct_argContext()
}

type Struct_argContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_argContext() *Struct_argContext {
	var p = new(Struct_argContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_struct_arg
	return p
}

func InitEmptyStruct_argContext(p *Struct_argContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_struct_arg
}

func (*Struct_argContext) IsStruct_argContext() {}

func NewStruct_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_argContext {
	var p = new(Struct_argContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_struct_arg

	return p
}

func (s *Struct_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_argContext) Type_name_tag() IType_name_tagContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_tagContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_tagContext)
}

func (s *Struct_argContext) COLON() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOLON, 0)
}

func (s *Struct_argContext) Type_name_or_bind() IType_name_or_bindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Struct_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Struct_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterStruct_arg(s)
	}
}

func (s *Struct_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitStruct_arg(s)
	}
}

func (p *SQLv1Antlr4Parser) Struct_arg() (localctx IStruct_argContext) {
	localctx = NewStruct_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, SQLv1Antlr4ParserRULE_struct_arg)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1650)
		p.Type_name_tag()
	}
	{
		p.SetState(1651)
		p.Match(SQLv1Antlr4ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1652)
		p.Type_name_or_bind()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStruct_arg_positionalContext is an interface to support dynamic dispatch.
type IStruct_arg_positionalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_name_tag() IType_name_tagContext
	Type_name_or_bind() IType_name_or_bindContext
	NULL() antlr.TerminalNode
	NOT() antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsStruct_arg_positionalContext differentiates from other interfaces.
	IsStruct_arg_positionalContext()
}

type Struct_arg_positionalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_arg_positionalContext() *Struct_arg_positionalContext {
	var p = new(Struct_arg_positionalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_struct_arg_positional
	return p
}

func InitEmptyStruct_arg_positionalContext(p *Struct_arg_positionalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_struct_arg_positional
}

func (*Struct_arg_positionalContext) IsStruct_arg_positionalContext() {}

func NewStruct_arg_positionalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_arg_positionalContext {
	var p = new(Struct_arg_positionalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_struct_arg_positional

	return p
}

func (s *Struct_arg_positionalContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_arg_positionalContext) Type_name_tag() IType_name_tagContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_tagContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_tagContext)
}

func (s *Struct_arg_positionalContext) Type_name_or_bind() IType_name_or_bindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Struct_arg_positionalContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNULL, 0)
}

func (s *Struct_arg_positionalContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNOT, 0)
}

func (s *Struct_arg_positionalContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAS, 0)
}

func (s *Struct_arg_positionalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_arg_positionalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Struct_arg_positionalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterStruct_arg_positional(s)
	}
}

func (s *Struct_arg_positionalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitStruct_arg_positional(s)
	}
}

func (p *SQLv1Antlr4Parser) Struct_arg_positional() (localctx IStruct_arg_positionalContext) {
	localctx = NewStruct_arg_positionalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, SQLv1Antlr4ParserRULE_struct_arg_positional)
	var _la int

	p.SetState(1666)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1654)
			p.Type_name_tag()
		}
		{
			p.SetState(1655)
			p.Type_name_or_bind()
		}
		p.SetState(1660)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserNOT || _la == SQLv1Antlr4ParserNULL {
			p.SetState(1657)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SQLv1Antlr4ParserNOT {
				{
					p.SetState(1656)
					p.Match(SQLv1Antlr4ParserNOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1659)
				p.Match(SQLv1Antlr4ParserNULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1662)
			p.Type_name_or_bind()
		}
		{
			p.SetState(1663)
			p.Match(SQLv1Antlr4ParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1664)
			p.Type_name_tag()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariant_argContext is an interface to support dynamic dispatch.
type IVariant_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_name_or_bind() IType_name_or_bindContext
	Type_name_tag() IType_name_tagContext
	COLON() antlr.TerminalNode

	// IsVariant_argContext differentiates from other interfaces.
	IsVariant_argContext()
}

type Variant_argContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariant_argContext() *Variant_argContext {
	var p = new(Variant_argContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_variant_arg
	return p
}

func InitEmptyVariant_argContext(p *Variant_argContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_variant_arg
}

func (*Variant_argContext) IsVariant_argContext() {}

func NewVariant_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variant_argContext {
	var p = new(Variant_argContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_variant_arg

	return p
}

func (s *Variant_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Variant_argContext) Type_name_or_bind() IType_name_or_bindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Variant_argContext) Type_name_tag() IType_name_tagContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_tagContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_tagContext)
}

func (s *Variant_argContext) COLON() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOLON, 0)
}

func (s *Variant_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variant_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variant_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterVariant_arg(s)
	}
}

func (s *Variant_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitVariant_arg(s)
	}
}

func (p *SQLv1Antlr4Parser) Variant_arg() (localctx IVariant_argContext) {
	localctx = NewVariant_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, SQLv1Antlr4ParserRULE_variant_arg)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1671)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 115, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1668)
			p.Type_name_tag()
		}
		{
			p.SetState(1669)
			p.Match(SQLv1Antlr4ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1673)
		p.Type_name_or_bind()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICallable_argContext is an interface to support dynamic dispatch.
type ICallable_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Variant_arg() IVariant_argContext
	LBRACE_CURLY() antlr.TerminalNode
	AUTOMAP() antlr.TerminalNode
	RBRACE_CURLY() antlr.TerminalNode

	// IsCallable_argContext differentiates from other interfaces.
	IsCallable_argContext()
}

type Callable_argContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallable_argContext() *Callable_argContext {
	var p = new(Callable_argContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_callable_arg
	return p
}

func InitEmptyCallable_argContext(p *Callable_argContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_callable_arg
}

func (*Callable_argContext) IsCallable_argContext() {}

func NewCallable_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Callable_argContext {
	var p = new(Callable_argContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_callable_arg

	return p
}

func (s *Callable_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Callable_argContext) Variant_arg() IVariant_argContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariant_argContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariant_argContext)
}

func (s *Callable_argContext) LBRACE_CURLY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLBRACE_CURLY, 0)
}

func (s *Callable_argContext) AUTOMAP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAUTOMAP, 0)
}

func (s *Callable_argContext) RBRACE_CURLY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRBRACE_CURLY, 0)
}

func (s *Callable_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Callable_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Callable_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterCallable_arg(s)
	}
}

func (s *Callable_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitCallable_arg(s)
	}
}

func (p *SQLv1Antlr4Parser) Callable_arg() (localctx ICallable_argContext) {
	localctx = NewCallable_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, SQLv1Antlr4ParserRULE_callable_arg)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1675)
		p.Variant_arg()
	}
	p.SetState(1679)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserLBRACE_CURLY {
		{
			p.SetState(1676)
			p.Match(SQLv1Antlr4ParserLBRACE_CURLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1677)
			p.Match(SQLv1Antlr4ParserAUTOMAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1678)
			p.Match(SQLv1Antlr4ParserRBRACE_CURLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICallable_arg_listContext is an interface to support dynamic dispatch.
type ICallable_arg_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCallable_arg() []ICallable_argContext
	Callable_arg(i int) ICallable_argContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCallable_arg_listContext differentiates from other interfaces.
	IsCallable_arg_listContext()
}

type Callable_arg_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallable_arg_listContext() *Callable_arg_listContext {
	var p = new(Callable_arg_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_callable_arg_list
	return p
}

func InitEmptyCallable_arg_listContext(p *Callable_arg_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_callable_arg_list
}

func (*Callable_arg_listContext) IsCallable_arg_listContext() {}

func NewCallable_arg_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Callable_arg_listContext {
	var p = new(Callable_arg_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_callable_arg_list

	return p
}

func (s *Callable_arg_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Callable_arg_listContext) AllCallable_arg() []ICallable_argContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICallable_argContext); ok {
			len++
		}
	}

	tst := make([]ICallable_argContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICallable_argContext); ok {
			tst[i] = t.(ICallable_argContext)
			i++
		}
	}

	return tst
}

func (s *Callable_arg_listContext) Callable_arg(i int) ICallable_argContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallable_argContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallable_argContext)
}

func (s *Callable_arg_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Callable_arg_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Callable_arg_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Callable_arg_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Callable_arg_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterCallable_arg_list(s)
	}
}

func (s *Callable_arg_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitCallable_arg_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Callable_arg_list() (localctx ICallable_arg_listContext) {
	localctx = NewCallable_arg_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, SQLv1Antlr4ParserRULE_callable_arg_list)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1681)
		p.Callable_arg()
	}
	p.SetState(1686)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 117, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1682)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1683)
				p.Callable_arg()
			}

		}
		p.SetState(1688)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 117, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_name_decimalContext is an interface to support dynamic dispatch.
type IType_name_decimalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECIMAL() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllInteger_or_bind() []IInteger_or_bindContext
	Integer_or_bind(i int) IInteger_or_bindContext
	COMMA() antlr.TerminalNode
	RPAREN() antlr.TerminalNode

	// IsType_name_decimalContext differentiates from other interfaces.
	IsType_name_decimalContext()
}

type Type_name_decimalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_decimalContext() *Type_name_decimalContext {
	var p = new(Type_name_decimalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_decimal
	return p
}

func InitEmptyType_name_decimalContext(p *Type_name_decimalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_decimal
}

func (*Type_name_decimalContext) IsType_name_decimalContext() {}

func NewType_name_decimalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_decimalContext {
	var p = new(Type_name_decimalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_decimal

	return p
}

func (s *Type_name_decimalContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_decimalContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDECIMAL, 0)
}

func (s *Type_name_decimalContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Type_name_decimalContext) AllInteger_or_bind() []IInteger_or_bindContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInteger_or_bindContext); ok {
			len++
		}
	}

	tst := make([]IInteger_or_bindContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInteger_or_bindContext); ok {
			tst[i] = t.(IInteger_or_bindContext)
			i++
		}
	}

	return tst
}

func (s *Type_name_decimalContext) Integer_or_bind(i int) IInteger_or_bindContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInteger_or_bindContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInteger_or_bindContext)
}

func (s *Type_name_decimalContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, 0)
}

func (s *Type_name_decimalContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Type_name_decimalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_decimalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_name_decimalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterType_name_decimal(s)
	}
}

func (s *Type_name_decimalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitType_name_decimal(s)
	}
}

func (p *SQLv1Antlr4Parser) Type_name_decimal() (localctx IType_name_decimalContext) {
	localctx = NewType_name_decimalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, SQLv1Antlr4ParserRULE_type_name_decimal)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1689)
		p.Match(SQLv1Antlr4ParserDECIMAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1690)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1691)
		p.Integer_or_bind()
	}
	{
		p.SetState(1692)
		p.Match(SQLv1Antlr4ParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1693)
		p.Integer_or_bind()
	}
	{
		p.SetState(1694)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_name_optionalContext is an interface to support dynamic dispatch.
type IType_name_optionalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPTIONAL() antlr.TerminalNode
	LESS() antlr.TerminalNode
	Type_name_or_bind() IType_name_or_bindContext
	GREATER() antlr.TerminalNode

	// IsType_name_optionalContext differentiates from other interfaces.
	IsType_name_optionalContext()
}

type Type_name_optionalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_optionalContext() *Type_name_optionalContext {
	var p = new(Type_name_optionalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_optional
	return p
}

func InitEmptyType_name_optionalContext(p *Type_name_optionalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_optional
}

func (*Type_name_optionalContext) IsType_name_optionalContext() {}

func NewType_name_optionalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_optionalContext {
	var p = new(Type_name_optionalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_optional

	return p
}

func (s *Type_name_optionalContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_optionalContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOPTIONAL, 0)
}

func (s *Type_name_optionalContext) LESS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLESS, 0)
}

func (s *Type_name_optionalContext) Type_name_or_bind() IType_name_or_bindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Type_name_optionalContext) GREATER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGREATER, 0)
}

func (s *Type_name_optionalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_optionalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_name_optionalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterType_name_optional(s)
	}
}

func (s *Type_name_optionalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitType_name_optional(s)
	}
}

func (p *SQLv1Antlr4Parser) Type_name_optional() (localctx IType_name_optionalContext) {
	localctx = NewType_name_optionalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, SQLv1Antlr4ParserRULE_type_name_optional)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1696)
		p.Match(SQLv1Antlr4ParserOPTIONAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1697)
		p.Match(SQLv1Antlr4ParserLESS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1698)
		p.Type_name_or_bind()
	}
	{
		p.SetState(1699)
		p.Match(SQLv1Antlr4ParserGREATER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_name_tupleContext is an interface to support dynamic dispatch.
type IType_name_tupleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TUPLE() antlr.TerminalNode
	LESS() antlr.TerminalNode
	GREATER() antlr.TerminalNode
	NOT_EQUALS2() antlr.TerminalNode
	AllType_name_or_bind() []IType_name_or_bindContext
	Type_name_or_bind(i int) IType_name_or_bindContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsType_name_tupleContext differentiates from other interfaces.
	IsType_name_tupleContext()
}

type Type_name_tupleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_tupleContext() *Type_name_tupleContext {
	var p = new(Type_name_tupleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_tuple
	return p
}

func InitEmptyType_name_tupleContext(p *Type_name_tupleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_tuple
}

func (*Type_name_tupleContext) IsType_name_tupleContext() {}

func NewType_name_tupleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_tupleContext {
	var p = new(Type_name_tupleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_tuple

	return p
}

func (s *Type_name_tupleContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_tupleContext) TUPLE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTUPLE, 0)
}

func (s *Type_name_tupleContext) LESS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLESS, 0)
}

func (s *Type_name_tupleContext) GREATER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGREATER, 0)
}

func (s *Type_name_tupleContext) NOT_EQUALS2() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNOT_EQUALS2, 0)
}

func (s *Type_name_tupleContext) AllType_name_or_bind() []IType_name_or_bindContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			len++
		}
	}

	tst := make([]IType_name_or_bindContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IType_name_or_bindContext); ok {
			tst[i] = t.(IType_name_or_bindContext)
			i++
		}
	}

	return tst
}

func (s *Type_name_tupleContext) Type_name_or_bind(i int) IType_name_or_bindContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Type_name_tupleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Type_name_tupleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Type_name_tupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_tupleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_name_tupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterType_name_tuple(s)
	}
}

func (s *Type_name_tupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitType_name_tuple(s)
	}
}

func (p *SQLv1Antlr4Parser) Type_name_tuple() (localctx IType_name_tupleContext) {
	localctx = NewType_name_tupleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, SQLv1Antlr4ParserRULE_type_name_tuple)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1701)
		p.Match(SQLv1Antlr4ParserTUPLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1718)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserLESS:
		{
			p.SetState(1702)
			p.Match(SQLv1Antlr4ParserLESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1714)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserDOLLAR || _la == SQLv1Antlr4ParserCALLABLE || ((int64((_la-99)) & ^0x3f) == 0 && ((int64(1)<<(_la-99))&4398054900737) != 0) || ((int64((_la-186)) & ^0x3f) == 0 && ((int64(1)<<(_la-186))&4611686018494496769) != 0) || ((int64((_la-270)) & ^0x3f) == 0 && ((int64(1)<<(_la-270))&31529595572453473) != 0) {
			{
				p.SetState(1703)
				p.Type_name_or_bind()
			}
			p.SetState(1708)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1704)
						p.Match(SQLv1Antlr4ParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1705)
						p.Type_name_or_bind()
					}

				}
				p.SetState(1710)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			p.SetState(1712)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SQLv1Antlr4ParserCOMMA {
				{
					p.SetState(1711)
					p.Match(SQLv1Antlr4ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		}
		{
			p.SetState(1716)
			p.Match(SQLv1Antlr4ParserGREATER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserNOT_EQUALS2:
		{
			p.SetState(1717)
			p.Match(SQLv1Antlr4ParserNOT_EQUALS2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_name_structContext is an interface to support dynamic dispatch.
type IType_name_structContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRUCT() antlr.TerminalNode
	LESS() antlr.TerminalNode
	GREATER() antlr.TerminalNode
	NOT_EQUALS2() antlr.TerminalNode
	AllStruct_arg() []IStruct_argContext
	Struct_arg(i int) IStruct_argContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsType_name_structContext differentiates from other interfaces.
	IsType_name_structContext()
}

type Type_name_structContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_structContext() *Type_name_structContext {
	var p = new(Type_name_structContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_struct
	return p
}

func InitEmptyType_name_structContext(p *Type_name_structContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_struct
}

func (*Type_name_structContext) IsType_name_structContext() {}

func NewType_name_structContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_structContext {
	var p = new(Type_name_structContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_struct

	return p
}

func (s *Type_name_structContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_structContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRUCT, 0)
}

func (s *Type_name_structContext) LESS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLESS, 0)
}

func (s *Type_name_structContext) GREATER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGREATER, 0)
}

func (s *Type_name_structContext) NOT_EQUALS2() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNOT_EQUALS2, 0)
}

func (s *Type_name_structContext) AllStruct_arg() []IStruct_argContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStruct_argContext); ok {
			len++
		}
	}

	tst := make([]IStruct_argContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStruct_argContext); ok {
			tst[i] = t.(IStruct_argContext)
			i++
		}
	}

	return tst
}

func (s *Type_name_structContext) Struct_arg(i int) IStruct_argContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStruct_argContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStruct_argContext)
}

func (s *Type_name_structContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Type_name_structContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Type_name_structContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_structContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_name_structContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterType_name_struct(s)
	}
}

func (s *Type_name_structContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitType_name_struct(s)
	}
}

func (p *SQLv1Antlr4Parser) Type_name_struct() (localctx IType_name_structContext) {
	localctx = NewType_name_structContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, SQLv1Antlr4ParserRULE_type_name_struct)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1720)
		p.Match(SQLv1Antlr4ParserSTRUCT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1737)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserLESS:
		{
			p.SetState(1721)
			p.Match(SQLv1Antlr4ParserLESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1733)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-32)) & ^0x3f) == 0 && ((int64(1)<<(_la-32))&-1101659113471) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&-9043483205574657) != 0) || ((int64((_la-160)) & ^0x3f) == 0 && ((int64(1)<<(_la-160))&-4503599694479361) != 0) || ((int64((_la-224)) & ^0x3f) == 0 && ((int64(1)<<(_la-224))&9218798068465401855) != 0) || ((int64((_la-288)) & ^0x3f) == 0 && ((int64(1)<<(_la-288))&137422175487) != 0) {
			{
				p.SetState(1722)
				p.Struct_arg()
			}
			p.SetState(1727)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1723)
						p.Match(SQLv1Antlr4ParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1724)
						p.Struct_arg()
					}

				}
				p.SetState(1729)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			p.SetState(1731)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SQLv1Antlr4ParserCOMMA {
				{
					p.SetState(1730)
					p.Match(SQLv1Antlr4ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		}
		{
			p.SetState(1735)
			p.Match(SQLv1Antlr4ParserGREATER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserNOT_EQUALS2:
		{
			p.SetState(1736)
			p.Match(SQLv1Antlr4ParserNOT_EQUALS2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_name_variantContext is an interface to support dynamic dispatch.
type IType_name_variantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VARIANT() antlr.TerminalNode
	LESS() antlr.TerminalNode
	AllVariant_arg() []IVariant_argContext
	Variant_arg(i int) IVariant_argContext
	GREATER() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsType_name_variantContext differentiates from other interfaces.
	IsType_name_variantContext()
}

type Type_name_variantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_variantContext() *Type_name_variantContext {
	var p = new(Type_name_variantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_variant
	return p
}

func InitEmptyType_name_variantContext(p *Type_name_variantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_variant
}

func (*Type_name_variantContext) IsType_name_variantContext() {}

func NewType_name_variantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_variantContext {
	var p = new(Type_name_variantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_variant

	return p
}

func (s *Type_name_variantContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_variantContext) VARIANT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserVARIANT, 0)
}

func (s *Type_name_variantContext) LESS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLESS, 0)
}

func (s *Type_name_variantContext) AllVariant_arg() []IVariant_argContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariant_argContext); ok {
			len++
		}
	}

	tst := make([]IVariant_argContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariant_argContext); ok {
			tst[i] = t.(IVariant_argContext)
			i++
		}
	}

	return tst
}

func (s *Type_name_variantContext) Variant_arg(i int) IVariant_argContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariant_argContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariant_argContext)
}

func (s *Type_name_variantContext) GREATER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGREATER, 0)
}

func (s *Type_name_variantContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Type_name_variantContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Type_name_variantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_variantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_name_variantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterType_name_variant(s)
	}
}

func (s *Type_name_variantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitType_name_variant(s)
	}
}

func (p *SQLv1Antlr4Parser) Type_name_variant() (localctx IType_name_variantContext) {
	localctx = NewType_name_variantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, SQLv1Antlr4ParserRULE_type_name_variant)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1739)
		p.Match(SQLv1Antlr4ParserVARIANT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1740)
		p.Match(SQLv1Antlr4ParserLESS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1741)
		p.Variant_arg()
	}
	p.SetState(1746)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1742)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1743)
				p.Variant_arg()
			}

		}
		p.SetState(1748)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1750)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(1749)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1752)
		p.Match(SQLv1Antlr4ParserGREATER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_name_listContext is an interface to support dynamic dispatch.
type IType_name_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIST() antlr.TerminalNode
	LESS() antlr.TerminalNode
	Type_name_or_bind() IType_name_or_bindContext
	GREATER() antlr.TerminalNode

	// IsType_name_listContext differentiates from other interfaces.
	IsType_name_listContext()
}

type Type_name_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_listContext() *Type_name_listContext {
	var p = new(Type_name_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_list
	return p
}

func InitEmptyType_name_listContext(p *Type_name_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_list
}

func (*Type_name_listContext) IsType_name_listContext() {}

func NewType_name_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_listContext {
	var p = new(Type_name_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_list

	return p
}

func (s *Type_name_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_listContext) LIST() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLIST, 0)
}

func (s *Type_name_listContext) LESS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLESS, 0)
}

func (s *Type_name_listContext) Type_name_or_bind() IType_name_or_bindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Type_name_listContext) GREATER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGREATER, 0)
}

func (s *Type_name_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_name_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterType_name_list(s)
	}
}

func (s *Type_name_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitType_name_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Type_name_list() (localctx IType_name_listContext) {
	localctx = NewType_name_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, SQLv1Antlr4ParserRULE_type_name_list)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1754)
		p.Match(SQLv1Antlr4ParserLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1755)
		p.Match(SQLv1Antlr4ParserLESS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1756)
		p.Type_name_or_bind()
	}
	{
		p.SetState(1757)
		p.Match(SQLv1Antlr4ParserGREATER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_name_streamContext is an interface to support dynamic dispatch.
type IType_name_streamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STREAM() antlr.TerminalNode
	LESS() antlr.TerminalNode
	Type_name_or_bind() IType_name_or_bindContext
	GREATER() antlr.TerminalNode

	// IsType_name_streamContext differentiates from other interfaces.
	IsType_name_streamContext()
}

type Type_name_streamContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_streamContext() *Type_name_streamContext {
	var p = new(Type_name_streamContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_stream
	return p
}

func InitEmptyType_name_streamContext(p *Type_name_streamContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_stream
}

func (*Type_name_streamContext) IsType_name_streamContext() {}

func NewType_name_streamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_streamContext {
	var p = new(Type_name_streamContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_stream

	return p
}

func (s *Type_name_streamContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_streamContext) STREAM() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTREAM, 0)
}

func (s *Type_name_streamContext) LESS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLESS, 0)
}

func (s *Type_name_streamContext) Type_name_or_bind() IType_name_or_bindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Type_name_streamContext) GREATER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGREATER, 0)
}

func (s *Type_name_streamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_streamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_name_streamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterType_name_stream(s)
	}
}

func (s *Type_name_streamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitType_name_stream(s)
	}
}

func (p *SQLv1Antlr4Parser) Type_name_stream() (localctx IType_name_streamContext) {
	localctx = NewType_name_streamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, SQLv1Antlr4ParserRULE_type_name_stream)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1759)
		p.Match(SQLv1Antlr4ParserSTREAM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1760)
		p.Match(SQLv1Antlr4ParserLESS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1761)
		p.Type_name_or_bind()
	}
	{
		p.SetState(1762)
		p.Match(SQLv1Antlr4ParserGREATER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_name_flowContext is an interface to support dynamic dispatch.
type IType_name_flowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FLOW() antlr.TerminalNode
	LESS() antlr.TerminalNode
	Type_name_or_bind() IType_name_or_bindContext
	GREATER() antlr.TerminalNode

	// IsType_name_flowContext differentiates from other interfaces.
	IsType_name_flowContext()
}

type Type_name_flowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_flowContext() *Type_name_flowContext {
	var p = new(Type_name_flowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_flow
	return p
}

func InitEmptyType_name_flowContext(p *Type_name_flowContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_flow
}

func (*Type_name_flowContext) IsType_name_flowContext() {}

func NewType_name_flowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_flowContext {
	var p = new(Type_name_flowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_flow

	return p
}

func (s *Type_name_flowContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_flowContext) FLOW() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFLOW, 0)
}

func (s *Type_name_flowContext) LESS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLESS, 0)
}

func (s *Type_name_flowContext) Type_name_or_bind() IType_name_or_bindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Type_name_flowContext) GREATER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGREATER, 0)
}

func (s *Type_name_flowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_flowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_name_flowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterType_name_flow(s)
	}
}

func (s *Type_name_flowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitType_name_flow(s)
	}
}

func (p *SQLv1Antlr4Parser) Type_name_flow() (localctx IType_name_flowContext) {
	localctx = NewType_name_flowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, SQLv1Antlr4ParserRULE_type_name_flow)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1764)
		p.Match(SQLv1Antlr4ParserFLOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1765)
		p.Match(SQLv1Antlr4ParserLESS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1766)
		p.Type_name_or_bind()
	}
	{
		p.SetState(1767)
		p.Match(SQLv1Antlr4ParserGREATER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_name_dictContext is an interface to support dynamic dispatch.
type IType_name_dictContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DICT() antlr.TerminalNode
	LESS() antlr.TerminalNode
	AllType_name_or_bind() []IType_name_or_bindContext
	Type_name_or_bind(i int) IType_name_or_bindContext
	COMMA() antlr.TerminalNode
	GREATER() antlr.TerminalNode

	// IsType_name_dictContext differentiates from other interfaces.
	IsType_name_dictContext()
}

type Type_name_dictContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_dictContext() *Type_name_dictContext {
	var p = new(Type_name_dictContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_dict
	return p
}

func InitEmptyType_name_dictContext(p *Type_name_dictContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_dict
}

func (*Type_name_dictContext) IsType_name_dictContext() {}

func NewType_name_dictContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_dictContext {
	var p = new(Type_name_dictContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_dict

	return p
}

func (s *Type_name_dictContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_dictContext) DICT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDICT, 0)
}

func (s *Type_name_dictContext) LESS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLESS, 0)
}

func (s *Type_name_dictContext) AllType_name_or_bind() []IType_name_or_bindContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			len++
		}
	}

	tst := make([]IType_name_or_bindContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IType_name_or_bindContext); ok {
			tst[i] = t.(IType_name_or_bindContext)
			i++
		}
	}

	return tst
}

func (s *Type_name_dictContext) Type_name_or_bind(i int) IType_name_or_bindContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Type_name_dictContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, 0)
}

func (s *Type_name_dictContext) GREATER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGREATER, 0)
}

func (s *Type_name_dictContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_dictContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_name_dictContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterType_name_dict(s)
	}
}

func (s *Type_name_dictContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitType_name_dict(s)
	}
}

func (p *SQLv1Antlr4Parser) Type_name_dict() (localctx IType_name_dictContext) {
	localctx = NewType_name_dictContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, SQLv1Antlr4ParserRULE_type_name_dict)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1769)
		p.Match(SQLv1Antlr4ParserDICT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1770)
		p.Match(SQLv1Antlr4ParserLESS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1771)
		p.Type_name_or_bind()
	}
	{
		p.SetState(1772)
		p.Match(SQLv1Antlr4ParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1773)
		p.Type_name_or_bind()
	}
	{
		p.SetState(1774)
		p.Match(SQLv1Antlr4ParserGREATER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_name_setContext is an interface to support dynamic dispatch.
type IType_name_setContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	LESS() antlr.TerminalNode
	Type_name_or_bind() IType_name_or_bindContext
	GREATER() antlr.TerminalNode

	// IsType_name_setContext differentiates from other interfaces.
	IsType_name_setContext()
}

type Type_name_setContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_setContext() *Type_name_setContext {
	var p = new(Type_name_setContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_set
	return p
}

func InitEmptyType_name_setContext(p *Type_name_setContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_set
}

func (*Type_name_setContext) IsType_name_setContext() {}

func NewType_name_setContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_setContext {
	var p = new(Type_name_setContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_set

	return p
}

func (s *Type_name_setContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_setContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSET, 0)
}

func (s *Type_name_setContext) LESS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLESS, 0)
}

func (s *Type_name_setContext) Type_name_or_bind() IType_name_or_bindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Type_name_setContext) GREATER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGREATER, 0)
}

func (s *Type_name_setContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_setContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_name_setContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterType_name_set(s)
	}
}

func (s *Type_name_setContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitType_name_set(s)
	}
}

func (p *SQLv1Antlr4Parser) Type_name_set() (localctx IType_name_setContext) {
	localctx = NewType_name_setContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, SQLv1Antlr4ParserRULE_type_name_set)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1776)
		p.Match(SQLv1Antlr4ParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1777)
		p.Match(SQLv1Antlr4ParserLESS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1778)
		p.Type_name_or_bind()
	}
	{
		p.SetState(1779)
		p.Match(SQLv1Antlr4ParserGREATER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_name_enumContext is an interface to support dynamic dispatch.
type IType_name_enumContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENUM() antlr.TerminalNode
	LESS() antlr.TerminalNode
	AllType_name_tag() []IType_name_tagContext
	Type_name_tag(i int) IType_name_tagContext
	GREATER() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsType_name_enumContext differentiates from other interfaces.
	IsType_name_enumContext()
}

type Type_name_enumContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_enumContext() *Type_name_enumContext {
	var p = new(Type_name_enumContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_enum
	return p
}

func InitEmptyType_name_enumContext(p *Type_name_enumContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_enum
}

func (*Type_name_enumContext) IsType_name_enumContext() {}

func NewType_name_enumContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_enumContext {
	var p = new(Type_name_enumContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_enum

	return p
}

func (s *Type_name_enumContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_enumContext) ENUM() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserENUM, 0)
}

func (s *Type_name_enumContext) LESS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLESS, 0)
}

func (s *Type_name_enumContext) AllType_name_tag() []IType_name_tagContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IType_name_tagContext); ok {
			len++
		}
	}

	tst := make([]IType_name_tagContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IType_name_tagContext); ok {
			tst[i] = t.(IType_name_tagContext)
			i++
		}
	}

	return tst
}

func (s *Type_name_enumContext) Type_name_tag(i int) IType_name_tagContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_tagContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_tagContext)
}

func (s *Type_name_enumContext) GREATER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGREATER, 0)
}

func (s *Type_name_enumContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Type_name_enumContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Type_name_enumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_enumContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_name_enumContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterType_name_enum(s)
	}
}

func (s *Type_name_enumContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitType_name_enum(s)
	}
}

func (p *SQLv1Antlr4Parser) Type_name_enum() (localctx IType_name_enumContext) {
	localctx = NewType_name_enumContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, SQLv1Antlr4ParserRULE_type_name_enum)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1781)
		p.Match(SQLv1Antlr4ParserENUM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1782)
		p.Match(SQLv1Antlr4ParserLESS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1783)
		p.Type_name_tag()
	}
	p.SetState(1788)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 128, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1784)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1785)
				p.Type_name_tag()
			}

		}
		p.SetState(1790)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 128, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1792)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(1791)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1794)
		p.Match(SQLv1Antlr4ParserGREATER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_name_resourceContext is an interface to support dynamic dispatch.
type IType_name_resourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESOURCE() antlr.TerminalNode
	LESS() antlr.TerminalNode
	Type_name_tag() IType_name_tagContext
	GREATER() antlr.TerminalNode

	// IsType_name_resourceContext differentiates from other interfaces.
	IsType_name_resourceContext()
}

type Type_name_resourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_resourceContext() *Type_name_resourceContext {
	var p = new(Type_name_resourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_resource
	return p
}

func InitEmptyType_name_resourceContext(p *Type_name_resourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_resource
}

func (*Type_name_resourceContext) IsType_name_resourceContext() {}

func NewType_name_resourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_resourceContext {
	var p = new(Type_name_resourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_resource

	return p
}

func (s *Type_name_resourceContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_resourceContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRESOURCE, 0)
}

func (s *Type_name_resourceContext) LESS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLESS, 0)
}

func (s *Type_name_resourceContext) Type_name_tag() IType_name_tagContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_tagContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_tagContext)
}

func (s *Type_name_resourceContext) GREATER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGREATER, 0)
}

func (s *Type_name_resourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_resourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_name_resourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterType_name_resource(s)
	}
}

func (s *Type_name_resourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitType_name_resource(s)
	}
}

func (p *SQLv1Antlr4Parser) Type_name_resource() (localctx IType_name_resourceContext) {
	localctx = NewType_name_resourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, SQLv1Antlr4ParserRULE_type_name_resource)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1796)
		p.Match(SQLv1Antlr4ParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1797)
		p.Match(SQLv1Antlr4ParserLESS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1798)
		p.Type_name_tag()
	}
	{
		p.SetState(1799)
		p.Match(SQLv1Antlr4ParserGREATER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_name_taggedContext is an interface to support dynamic dispatch.
type IType_name_taggedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TAGGED() antlr.TerminalNode
	LESS() antlr.TerminalNode
	Type_name_or_bind() IType_name_or_bindContext
	COMMA() antlr.TerminalNode
	Type_name_tag() IType_name_tagContext
	GREATER() antlr.TerminalNode

	// IsType_name_taggedContext differentiates from other interfaces.
	IsType_name_taggedContext()
}

type Type_name_taggedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_taggedContext() *Type_name_taggedContext {
	var p = new(Type_name_taggedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_tagged
	return p
}

func InitEmptyType_name_taggedContext(p *Type_name_taggedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_tagged
}

func (*Type_name_taggedContext) IsType_name_taggedContext() {}

func NewType_name_taggedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_taggedContext {
	var p = new(Type_name_taggedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_tagged

	return p
}

func (s *Type_name_taggedContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_taggedContext) TAGGED() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTAGGED, 0)
}

func (s *Type_name_taggedContext) LESS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLESS, 0)
}

func (s *Type_name_taggedContext) Type_name_or_bind() IType_name_or_bindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Type_name_taggedContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, 0)
}

func (s *Type_name_taggedContext) Type_name_tag() IType_name_tagContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_tagContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_tagContext)
}

func (s *Type_name_taggedContext) GREATER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGREATER, 0)
}

func (s *Type_name_taggedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_taggedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_name_taggedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterType_name_tagged(s)
	}
}

func (s *Type_name_taggedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitType_name_tagged(s)
	}
}

func (p *SQLv1Antlr4Parser) Type_name_tagged() (localctx IType_name_taggedContext) {
	localctx = NewType_name_taggedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, SQLv1Antlr4ParserRULE_type_name_tagged)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1801)
		p.Match(SQLv1Antlr4ParserTAGGED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1802)
		p.Match(SQLv1Antlr4ParserLESS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1803)
		p.Type_name_or_bind()
	}
	{
		p.SetState(1804)
		p.Match(SQLv1Antlr4ParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1805)
		p.Type_name_tag()
	}
	{
		p.SetState(1806)
		p.Match(SQLv1Antlr4ParserGREATER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_name_callableContext is an interface to support dynamic dispatch.
type IType_name_callableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CALLABLE() antlr.TerminalNode
	LESS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ARROW() antlr.TerminalNode
	Type_name_or_bind() IType_name_or_bindContext
	GREATER() antlr.TerminalNode
	AllCallable_arg_list() []ICallable_arg_listContext
	Callable_arg_list(i int) ICallable_arg_listContext
	COMMA() antlr.TerminalNode
	LBRACE_SQUARE() antlr.TerminalNode
	RBRACE_SQUARE() antlr.TerminalNode

	// IsType_name_callableContext differentiates from other interfaces.
	IsType_name_callableContext()
}

type Type_name_callableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_callableContext() *Type_name_callableContext {
	var p = new(Type_name_callableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_callable
	return p
}

func InitEmptyType_name_callableContext(p *Type_name_callableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_callable
}

func (*Type_name_callableContext) IsType_name_callableContext() {}

func NewType_name_callableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_callableContext {
	var p = new(Type_name_callableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_callable

	return p
}

func (s *Type_name_callableContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_callableContext) CALLABLE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCALLABLE, 0)
}

func (s *Type_name_callableContext) LESS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLESS, 0)
}

func (s *Type_name_callableContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Type_name_callableContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Type_name_callableContext) ARROW() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserARROW, 0)
}

func (s *Type_name_callableContext) Type_name_or_bind() IType_name_or_bindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Type_name_callableContext) GREATER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGREATER, 0)
}

func (s *Type_name_callableContext) AllCallable_arg_list() []ICallable_arg_listContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICallable_arg_listContext); ok {
			len++
		}
	}

	tst := make([]ICallable_arg_listContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICallable_arg_listContext); ok {
			tst[i] = t.(ICallable_arg_listContext)
			i++
		}
	}

	return tst
}

func (s *Type_name_callableContext) Callable_arg_list(i int) ICallable_arg_listContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallable_arg_listContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallable_arg_listContext)
}

func (s *Type_name_callableContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, 0)
}

func (s *Type_name_callableContext) LBRACE_SQUARE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLBRACE_SQUARE, 0)
}

func (s *Type_name_callableContext) RBRACE_SQUARE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRBRACE_SQUARE, 0)
}

func (s *Type_name_callableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_callableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_name_callableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterType_name_callable(s)
	}
}

func (s *Type_name_callableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitType_name_callable(s)
	}
}

func (p *SQLv1Antlr4Parser) Type_name_callable() (localctx IType_name_callableContext) {
	localctx = NewType_name_callableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, SQLv1Antlr4ParserRULE_type_name_callable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1808)
		p.Match(SQLv1Antlr4ParserCALLABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1809)
		p.Match(SQLv1Antlr4ParserLESS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1810)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1812)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-32)) & ^0x3f) == 0 && ((int64(1)<<(_la-32))&-2147485695) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&-9008298766368769) != 0) || ((int64((_la-160)) & ^0x3f) == 0 && ((int64(1)<<(_la-160))&-1) != 0) || ((int64((_la-224)) & ^0x3f) == 0 && ((int64(1)<<(_la-224))&-1048577) != 0) || ((int64((_la-288)) & ^0x3f) == 0 && ((int64(1)<<(_la-288))&137438953215) != 0) {
		{
			p.SetState(1811)
			p.Callable_arg_list()
		}

	}
	p.SetState(1815)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(1814)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1821)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserLBRACE_SQUARE {
		{
			p.SetState(1817)
			p.Match(SQLv1Antlr4ParserLBRACE_SQUARE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1818)
			p.Callable_arg_list()
		}
		{
			p.SetState(1819)
			p.Match(SQLv1Antlr4ParserRBRACE_SQUARE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1823)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1824)
		p.Match(SQLv1Antlr4ParserARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1825)
		p.Type_name_or_bind()
	}
	{
		p.SetState(1826)
		p.Match(SQLv1Antlr4ParserGREATER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_name_compositeContext is an interface to support dynamic dispatch.
type IType_name_compositeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_name_optional() IType_name_optionalContext
	Type_name_tuple() IType_name_tupleContext
	Type_name_struct() IType_name_structContext
	Type_name_variant() IType_name_variantContext
	Type_name_list() IType_name_listContext
	Type_name_stream() IType_name_streamContext
	Type_name_flow() IType_name_flowContext
	Type_name_dict() IType_name_dictContext
	Type_name_set() IType_name_setContext
	Type_name_enum() IType_name_enumContext
	Type_name_resource() IType_name_resourceContext
	Type_name_tagged() IType_name_taggedContext
	Type_name_callable() IType_name_callableContext
	AllQUESTION() []antlr.TerminalNode
	QUESTION(i int) antlr.TerminalNode

	// IsType_name_compositeContext differentiates from other interfaces.
	IsType_name_compositeContext()
}

type Type_name_compositeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_compositeContext() *Type_name_compositeContext {
	var p = new(Type_name_compositeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_composite
	return p
}

func InitEmptyType_name_compositeContext(p *Type_name_compositeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_composite
}

func (*Type_name_compositeContext) IsType_name_compositeContext() {}

func NewType_name_compositeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_compositeContext {
	var p = new(Type_name_compositeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_composite

	return p
}

func (s *Type_name_compositeContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_compositeContext) Type_name_optional() IType_name_optionalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_optionalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_optionalContext)
}

func (s *Type_name_compositeContext) Type_name_tuple() IType_name_tupleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_tupleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_tupleContext)
}

func (s *Type_name_compositeContext) Type_name_struct() IType_name_structContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_structContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_structContext)
}

func (s *Type_name_compositeContext) Type_name_variant() IType_name_variantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_variantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_variantContext)
}

func (s *Type_name_compositeContext) Type_name_list() IType_name_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_listContext)
}

func (s *Type_name_compositeContext) Type_name_stream() IType_name_streamContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_streamContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_streamContext)
}

func (s *Type_name_compositeContext) Type_name_flow() IType_name_flowContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_flowContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_flowContext)
}

func (s *Type_name_compositeContext) Type_name_dict() IType_name_dictContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_dictContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_dictContext)
}

func (s *Type_name_compositeContext) Type_name_set() IType_name_setContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_setContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_setContext)
}

func (s *Type_name_compositeContext) Type_name_enum() IType_name_enumContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_enumContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_enumContext)
}

func (s *Type_name_compositeContext) Type_name_resource() IType_name_resourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_resourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_resourceContext)
}

func (s *Type_name_compositeContext) Type_name_tagged() IType_name_taggedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_taggedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_taggedContext)
}

func (s *Type_name_compositeContext) Type_name_callable() IType_name_callableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_callableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_callableContext)
}

func (s *Type_name_compositeContext) AllQUESTION() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserQUESTION)
}

func (s *Type_name_compositeContext) QUESTION(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserQUESTION, i)
}

func (s *Type_name_compositeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_compositeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_name_compositeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterType_name_composite(s)
	}
}

func (s *Type_name_compositeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitType_name_composite(s)
	}
}

func (p *SQLv1Antlr4Parser) Type_name_composite() (localctx IType_name_compositeContext) {
	localctx = NewType_name_compositeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, SQLv1Antlr4ParserRULE_type_name_composite)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1841)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserOPTIONAL:
		{
			p.SetState(1828)
			p.Type_name_optional()
		}

	case SQLv1Antlr4ParserTUPLE:
		{
			p.SetState(1829)
			p.Type_name_tuple()
		}

	case SQLv1Antlr4ParserSTRUCT:
		{
			p.SetState(1830)
			p.Type_name_struct()
		}

	case SQLv1Antlr4ParserVARIANT:
		{
			p.SetState(1831)
			p.Type_name_variant()
		}

	case SQLv1Antlr4ParserLIST:
		{
			p.SetState(1832)
			p.Type_name_list()
		}

	case SQLv1Antlr4ParserSTREAM:
		{
			p.SetState(1833)
			p.Type_name_stream()
		}

	case SQLv1Antlr4ParserFLOW:
		{
			p.SetState(1834)
			p.Type_name_flow()
		}

	case SQLv1Antlr4ParserDICT:
		{
			p.SetState(1835)
			p.Type_name_dict()
		}

	case SQLv1Antlr4ParserSET:
		{
			p.SetState(1836)
			p.Type_name_set()
		}

	case SQLv1Antlr4ParserENUM:
		{
			p.SetState(1837)
			p.Type_name_enum()
		}

	case SQLv1Antlr4ParserRESOURCE:
		{
			p.SetState(1838)
			p.Type_name_resource()
		}

	case SQLv1Antlr4ParserTAGGED:
		{
			p.SetState(1839)
			p.Type_name_tagged()
		}

	case SQLv1Antlr4ParserCALLABLE:
		{
			p.SetState(1840)
			p.Type_name_callable()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1846)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserQUESTION {
		{
			p.SetState(1843)
			p.Match(SQLv1Antlr4ParserQUESTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1848)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_nameContext is an interface to support dynamic dispatch.
type IType_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_name_composite() IType_name_compositeContext
	Type_name_decimal() IType_name_decimalContext
	Type_name_simple() IType_name_simpleContext
	AllQUESTION() []antlr.TerminalNode
	QUESTION(i int) antlr.TerminalNode

	// IsType_nameContext differentiates from other interfaces.
	IsType_nameContext()
}

type Type_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_nameContext() *Type_nameContext {
	var p = new(Type_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name
	return p
}

func InitEmptyType_nameContext(p *Type_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name
}

func (*Type_nameContext) IsType_nameContext() {}

func NewType_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_nameContext {
	var p = new(Type_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name

	return p
}

func (s *Type_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_nameContext) Type_name_composite() IType_name_compositeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_compositeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_compositeContext)
}

func (s *Type_nameContext) Type_name_decimal() IType_name_decimalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_decimalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_decimalContext)
}

func (s *Type_nameContext) Type_name_simple() IType_name_simpleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_simpleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_simpleContext)
}

func (s *Type_nameContext) AllQUESTION() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserQUESTION)
}

func (s *Type_nameContext) QUESTION(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserQUESTION, i)
}

func (s *Type_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterType_name(s)
	}
}

func (s *Type_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitType_name(s)
	}
}

func (p *SQLv1Antlr4Parser) Type_name() (localctx IType_nameContext) {
	localctx = NewType_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, SQLv1Antlr4ParserRULE_type_name)
	var _la int

	p.SetState(1860)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserCALLABLE, SQLv1Antlr4ParserDICT, SQLv1Antlr4ParserENUM, SQLv1Antlr4ParserFLOW, SQLv1Antlr4ParserLIST, SQLv1Antlr4ParserOPTIONAL, SQLv1Antlr4ParserRESOURCE, SQLv1Antlr4ParserSET, SQLv1Antlr4ParserSTREAM, SQLv1Antlr4ParserSTRUCT, SQLv1Antlr4ParserTAGGED, SQLv1Antlr4ParserTUPLE, SQLv1Antlr4ParserVARIANT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1849)
			p.Type_name_composite()
		}

	case SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserSTRING_VALUE, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1852)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case SQLv1Antlr4ParserDECIMAL:
			{
				p.SetState(1850)
				p.Type_name_decimal()
			}

		case SQLv1Antlr4ParserSTRING_VALUE, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
			{
				p.SetState(1851)
				p.Type_name_simple()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(1857)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SQLv1Antlr4ParserQUESTION {
			{
				p.SetState(1854)
				p.Match(SQLv1Antlr4ParserQUESTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1859)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_name_or_bindContext is an interface to support dynamic dispatch.
type IType_name_or_bindContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_name() IType_nameContext
	Bind_parameter() IBind_parameterContext

	// IsType_name_or_bindContext differentiates from other interfaces.
	IsType_name_or_bindContext()
}

type Type_name_or_bindContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_or_bindContext() *Type_name_or_bindContext {
	var p = new(Type_name_or_bindContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_or_bind
	return p
}

func InitEmptyType_name_or_bindContext(p *Type_name_or_bindContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_or_bind
}

func (*Type_name_or_bindContext) IsType_name_or_bindContext() {}

func NewType_name_or_bindContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_or_bindContext {
	var p = new(Type_name_or_bindContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_name_or_bind

	return p
}

func (s *Type_name_or_bindContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_or_bindContext) Type_name() IType_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_nameContext)
}

func (s *Type_name_or_bindContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Type_name_or_bindContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_or_bindContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_name_or_bindContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterType_name_or_bind(s)
	}
}

func (s *Type_name_or_bindContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitType_name_or_bind(s)
	}
}

func (p *SQLv1Antlr4Parser) Type_name_or_bind() (localctx IType_name_or_bindContext) {
	localctx = NewType_name_or_bindContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, SQLv1Antlr4ParserRULE_type_name_or_bind)
	p.SetState(1864)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserCALLABLE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDICT, SQLv1Antlr4ParserENUM, SQLv1Antlr4ParserFLOW, SQLv1Antlr4ParserLIST, SQLv1Antlr4ParserOPTIONAL, SQLv1Antlr4ParserRESOURCE, SQLv1Antlr4ParserSET, SQLv1Antlr4ParserSTREAM, SQLv1Antlr4ParserSTRUCT, SQLv1Antlr4ParserTAGGED, SQLv1Antlr4ParserTUPLE, SQLv1Antlr4ParserVARIANT, SQLv1Antlr4ParserSTRING_VALUE, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1862)
			p.Type_name()
		}

	case SQLv1Antlr4ParserDOLLAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1863)
			p.Bind_parameter()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValue_constructor_literalContext is an interface to support dynamic dispatch.
type IValue_constructor_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_VALUE() antlr.TerminalNode

	// IsValue_constructor_literalContext differentiates from other interfaces.
	IsValue_constructor_literalContext()
}

type Value_constructor_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_constructor_literalContext() *Value_constructor_literalContext {
	var p = new(Value_constructor_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_value_constructor_literal
	return p
}

func InitEmptyValue_constructor_literalContext(p *Value_constructor_literalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_value_constructor_literal
}

func (*Value_constructor_literalContext) IsValue_constructor_literalContext() {}

func NewValue_constructor_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_constructor_literalContext {
	var p = new(Value_constructor_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_value_constructor_literal

	return p
}

func (s *Value_constructor_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Value_constructor_literalContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRING_VALUE, 0)
}

func (s *Value_constructor_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_constructor_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Value_constructor_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterValue_constructor_literal(s)
	}
}

func (s *Value_constructor_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitValue_constructor_literal(s)
	}
}

func (p *SQLv1Antlr4Parser) Value_constructor_literal() (localctx IValue_constructor_literalContext) {
	localctx = NewValue_constructor_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, SQLv1Antlr4ParserRULE_value_constructor_literal)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1866)
		p.Match(SQLv1Antlr4ParserSTRING_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValue_constructorContext is an interface to support dynamic dispatch.
type IValue_constructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VARIANT() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ENUM() antlr.TerminalNode
	CALLABLE() antlr.TerminalNode

	// IsValue_constructorContext differentiates from other interfaces.
	IsValue_constructorContext()
}

type Value_constructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_constructorContext() *Value_constructorContext {
	var p = new(Value_constructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_value_constructor
	return p
}

func InitEmptyValue_constructorContext(p *Value_constructorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_value_constructor
}

func (*Value_constructorContext) IsValue_constructorContext() {}

func NewValue_constructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_constructorContext {
	var p = new(Value_constructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_value_constructor

	return p
}

func (s *Value_constructorContext) GetParser() antlr.Parser { return s.parser }

func (s *Value_constructorContext) VARIANT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserVARIANT, 0)
}

func (s *Value_constructorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Value_constructorContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Value_constructorContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Value_constructorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Value_constructorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Value_constructorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Value_constructorContext) ENUM() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserENUM, 0)
}

func (s *Value_constructorContext) CALLABLE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCALLABLE, 0)
}

func (s *Value_constructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_constructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Value_constructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterValue_constructor(s)
	}
}

func (s *Value_constructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitValue_constructor(s)
	}
}

func (p *SQLv1Antlr4Parser) Value_constructor() (localctx IValue_constructorContext) {
	localctx = NewValue_constructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, SQLv1Antlr4ParserRULE_value_constructor)
	p.SetState(1891)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserVARIANT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1868)
			p.Match(SQLv1Antlr4ParserVARIANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1869)
			p.Match(SQLv1Antlr4ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1870)
			p.Expr()
		}
		{
			p.SetState(1871)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1872)
			p.Expr()
		}
		{
			p.SetState(1873)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1874)
			p.Expr()
		}
		{
			p.SetState(1875)
			p.Match(SQLv1Antlr4ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserENUM:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1877)
			p.Match(SQLv1Antlr4ParserENUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1878)
			p.Match(SQLv1Antlr4ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1879)
			p.Expr()
		}
		{
			p.SetState(1880)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1881)
			p.Expr()
		}
		{
			p.SetState(1882)
			p.Match(SQLv1Antlr4ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserCALLABLE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1884)
			p.Match(SQLv1Antlr4ParserCALLABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1885)
			p.Match(SQLv1Antlr4ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1886)
			p.Expr()
		}
		{
			p.SetState(1887)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1888)
			p.Expr()
		}
		{
			p.SetState(1889)
			p.Match(SQLv1Antlr4ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclare_stmtContext is an interface to support dynamic dispatch.
type IDeclare_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECLARE() antlr.TerminalNode
	Bind_parameter() IBind_parameterContext
	AS() antlr.TerminalNode
	Type_name() IType_nameContext
	EQUALS() antlr.TerminalNode
	Literal_value() ILiteral_valueContext

	// IsDeclare_stmtContext differentiates from other interfaces.
	IsDeclare_stmtContext()
}

type Declare_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_stmtContext() *Declare_stmtContext {
	var p = new(Declare_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_declare_stmt
	return p
}

func InitEmptyDeclare_stmtContext(p *Declare_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_declare_stmt
}

func (*Declare_stmtContext) IsDeclare_stmtContext() {}

func NewDeclare_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_stmtContext {
	var p = new(Declare_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_declare_stmt

	return p
}

func (s *Declare_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_stmtContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDECLARE, 0)
}

func (s *Declare_stmtContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Declare_stmtContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAS, 0)
}

func (s *Declare_stmtContext) Type_name() IType_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_nameContext)
}

func (s *Declare_stmtContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEQUALS, 0)
}

func (s *Declare_stmtContext) Literal_value() ILiteral_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteral_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteral_valueContext)
}

func (s *Declare_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declare_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterDeclare_stmt(s)
	}
}

func (s *Declare_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitDeclare_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Declare_stmt() (localctx IDeclare_stmtContext) {
	localctx = NewDeclare_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, SQLv1Antlr4ParserRULE_declare_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1893)
		p.Match(SQLv1Antlr4ParserDECLARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1894)
		p.Bind_parameter()
	}
	{
		p.SetState(1895)
		p.Match(SQLv1Antlr4ParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1896)
		p.Type_name()
	}
	p.SetState(1899)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserEQUALS {
		{
			p.SetState(1897)
			p.Match(SQLv1Antlr4ParserEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1898)
			p.Literal_value()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModule_pathContext is an interface to support dynamic dispatch.
type IModule_pathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAn_id() []IAn_idContext
	An_id(i int) IAn_idContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsModule_pathContext differentiates from other interfaces.
	IsModule_pathContext()
}

type Module_pathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_pathContext() *Module_pathContext {
	var p = new(Module_pathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_module_path
	return p
}

func InitEmptyModule_pathContext(p *Module_pathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_module_path
}

func (*Module_pathContext) IsModule_pathContext() {}

func NewModule_pathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_pathContext {
	var p = new(Module_pathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_module_path

	return p
}

func (s *Module_pathContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_pathContext) AllAn_id() []IAn_idContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_idContext); ok {
			len++
		}
	}

	tst := make([]IAn_idContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_idContext); ok {
			tst[i] = t.(IAn_idContext)
			i++
		}
	}

	return tst
}

func (s *Module_pathContext) An_id(i int) IAn_idContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Module_pathContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserDOT)
}

func (s *Module_pathContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDOT, i)
}

func (s *Module_pathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_pathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_pathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterModule_path(s)
	}
}

func (s *Module_pathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitModule_path(s)
	}
}

func (p *SQLv1Antlr4Parser) Module_path() (localctx IModule_pathContext) {
	localctx = NewModule_pathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, SQLv1Antlr4ParserRULE_module_path)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1902)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserDOT {
		{
			p.SetState(1901)
			p.Match(SQLv1Antlr4ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1904)
		p.An_id()
	}
	p.SetState(1909)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserDOT {
		{
			p.SetState(1905)
			p.Match(SQLv1Antlr4ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1906)
			p.An_id()
		}

		p.SetState(1911)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImport_stmtContext is an interface to support dynamic dispatch.
type IImport_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPORT() antlr.TerminalNode
	Module_path() IModule_pathContext
	SYMBOLS() antlr.TerminalNode
	Named_bind_parameter_list() INamed_bind_parameter_listContext

	// IsImport_stmtContext differentiates from other interfaces.
	IsImport_stmtContext()
}

type Import_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_stmtContext() *Import_stmtContext {
	var p = new(Import_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_import_stmt
	return p
}

func InitEmptyImport_stmtContext(p *Import_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_import_stmt
}

func (*Import_stmtContext) IsImport_stmtContext() {}

func NewImport_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_stmtContext {
	var p = new(Import_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_import_stmt

	return p
}

func (s *Import_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_stmtContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIMPORT, 0)
}

func (s *Import_stmtContext) Module_path() IModule_pathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModule_pathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModule_pathContext)
}

func (s *Import_stmtContext) SYMBOLS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSYMBOLS, 0)
}

func (s *Import_stmtContext) Named_bind_parameter_list() INamed_bind_parameter_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_bind_parameter_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_bind_parameter_listContext)
}

func (s *Import_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterImport_stmt(s)
	}
}

func (s *Import_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitImport_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Import_stmt() (localctx IImport_stmtContext) {
	localctx = NewImport_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, SQLv1Antlr4ParserRULE_import_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1912)
		p.Match(SQLv1Antlr4ParserIMPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1913)
		p.Module_path()
	}
	{
		p.SetState(1914)
		p.Match(SQLv1Antlr4ParserSYMBOLS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1915)
		p.Named_bind_parameter_list()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExport_stmtContext is an interface to support dynamic dispatch.
type IExport_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXPORT() antlr.TerminalNode
	Bind_parameter_list() IBind_parameter_listContext

	// IsExport_stmtContext differentiates from other interfaces.
	IsExport_stmtContext()
}

type Export_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExport_stmtContext() *Export_stmtContext {
	var p = new(Export_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_export_stmt
	return p
}

func InitEmptyExport_stmtContext(p *Export_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_export_stmt
}

func (*Export_stmtContext) IsExport_stmtContext() {}

func NewExport_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Export_stmtContext {
	var p = new(Export_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_export_stmt

	return p
}

func (s *Export_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Export_stmtContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXPORT, 0)
}

func (s *Export_stmtContext) Bind_parameter_list() IBind_parameter_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameter_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameter_listContext)
}

func (s *Export_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Export_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Export_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterExport_stmt(s)
	}
}

func (s *Export_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitExport_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Export_stmt() (localctx IExport_stmtContext) {
	localctx = NewExport_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, SQLv1Antlr4ParserRULE_export_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1917)
		p.Match(SQLv1Antlr4ParserEXPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1918)
		p.Bind_parameter_list()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICall_actionContext is an interface to support dynamic dispatch.
type ICall_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Bind_parameter() IBind_parameterContext
	EMPTY_ACTION() antlr.TerminalNode
	Expr_list() IExpr_listContext

	// IsCall_actionContext differentiates from other interfaces.
	IsCall_actionContext()
}

type Call_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCall_actionContext() *Call_actionContext {
	var p = new(Call_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_call_action
	return p
}

func InitEmptyCall_actionContext(p *Call_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_call_action
}

func (*Call_actionContext) IsCall_actionContext() {}

func NewCall_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Call_actionContext {
	var p = new(Call_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_call_action

	return p
}

func (s *Call_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Call_actionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Call_actionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Call_actionContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Call_actionContext) EMPTY_ACTION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEMPTY_ACTION, 0)
}

func (s *Call_actionContext) Expr_list() IExpr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_listContext)
}

func (s *Call_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Call_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Call_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterCall_action(s)
	}
}

func (s *Call_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitCall_action(s)
	}
}

func (p *SQLv1Antlr4Parser) Call_action() (localctx ICall_actionContext) {
	localctx = NewCall_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, SQLv1Antlr4ParserRULE_call_action)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1922)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserDOLLAR:
		{
			p.SetState(1920)
			p.Bind_parameter()
		}

	case SQLv1Antlr4ParserEMPTY_ACTION:
		{
			p.SetState(1921)
			p.Match(SQLv1Antlr4ParserEMPTY_ACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1924)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1926)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-14)) & ^0x3f) == 0 && ((int64(1)<<(_la-14))&-562950217396195) != 0) || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&-1) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&-129) != 0) || ((int64((_la-206)) & ^0x3f) == 0 && ((int64(1)<<(_la-206))&-274877906945) != 0) || ((int64((_la-270)) & ^0x3f) == 0 && ((int64(1)<<(_la-270))&576460752303423487) != 0) {
		{
			p.SetState(1925)
			p.Expr_list()
		}

	}
	{
		p.SetState(1928)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInline_actionContext is an interface to support dynamic dispatch.
type IInline_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BEGIN() antlr.TerminalNode
	Define_action_or_subquery_body() IDefine_action_or_subquery_bodyContext
	END() antlr.TerminalNode
	DO() antlr.TerminalNode

	// IsInline_actionContext differentiates from other interfaces.
	IsInline_actionContext()
}

type Inline_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInline_actionContext() *Inline_actionContext {
	var p = new(Inline_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_inline_action
	return p
}

func InitEmptyInline_actionContext(p *Inline_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_inline_action
}

func (*Inline_actionContext) IsInline_actionContext() {}

func NewInline_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inline_actionContext {
	var p = new(Inline_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_inline_action

	return p
}

func (s *Inline_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Inline_actionContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserBEGIN, 0)
}

func (s *Inline_actionContext) Define_action_or_subquery_body() IDefine_action_or_subquery_bodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefine_action_or_subquery_bodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefine_action_or_subquery_bodyContext)
}

func (s *Inline_actionContext) END() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEND, 0)
}

func (s *Inline_actionContext) DO() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDO, 0)
}

func (s *Inline_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inline_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inline_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterInline_action(s)
	}
}

func (s *Inline_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitInline_action(s)
	}
}

func (p *SQLv1Antlr4Parser) Inline_action() (localctx IInline_actionContext) {
	localctx = NewInline_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, SQLv1Antlr4ParserRULE_inline_action)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1930)
		p.Match(SQLv1Antlr4ParserBEGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1931)
		p.Define_action_or_subquery_body()
	}
	{
		p.SetState(1932)
		p.Match(SQLv1Antlr4ParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1933)
		p.Match(SQLv1Antlr4ParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDo_stmtContext is an interface to support dynamic dispatch.
type IDo_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DO() antlr.TerminalNode
	Call_action() ICall_actionContext
	Inline_action() IInline_actionContext

	// IsDo_stmtContext differentiates from other interfaces.
	IsDo_stmtContext()
}

type Do_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDo_stmtContext() *Do_stmtContext {
	var p = new(Do_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_do_stmt
	return p
}

func InitEmptyDo_stmtContext(p *Do_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_do_stmt
}

func (*Do_stmtContext) IsDo_stmtContext() {}

func NewDo_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Do_stmtContext {
	var p = new(Do_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_do_stmt

	return p
}

func (s *Do_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Do_stmtContext) DO() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDO, 0)
}

func (s *Do_stmtContext) Call_action() ICall_actionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICall_actionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICall_actionContext)
}

func (s *Do_stmtContext) Inline_action() IInline_actionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInline_actionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInline_actionContext)
}

func (s *Do_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Do_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Do_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterDo_stmt(s)
	}
}

func (s *Do_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitDo_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Do_stmt() (localctx IDo_stmtContext) {
	localctx = NewDo_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, SQLv1Antlr4ParserRULE_do_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1935)
		p.Match(SQLv1Antlr4ParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1938)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserDOLLAR, SQLv1Antlr4ParserEMPTY_ACTION:
		{
			p.SetState(1936)
			p.Call_action()
		}

	case SQLv1Antlr4ParserBEGIN:
		{
			p.SetState(1937)
			p.Inline_action()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPragma_stmtContext is an interface to support dynamic dispatch.
type IPragma_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRAGMA() antlr.TerminalNode
	Opt_id_prefix_or_type() IOpt_id_prefix_or_typeContext
	An_id() IAn_idContext
	EQUALS() antlr.TerminalNode
	AllPragma_value() []IPragma_valueContext
	Pragma_value(i int) IPragma_valueContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPragma_stmtContext differentiates from other interfaces.
	IsPragma_stmtContext()
}

type Pragma_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPragma_stmtContext() *Pragma_stmtContext {
	var p = new(Pragma_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_pragma_stmt
	return p
}

func InitEmptyPragma_stmtContext(p *Pragma_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_pragma_stmt
}

func (*Pragma_stmtContext) IsPragma_stmtContext() {}

func NewPragma_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pragma_stmtContext {
	var p = new(Pragma_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_pragma_stmt

	return p
}

func (s *Pragma_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Pragma_stmtContext) PRAGMA() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPRAGMA, 0)
}

func (s *Pragma_stmtContext) Opt_id_prefix_or_type() IOpt_id_prefix_or_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_id_prefix_or_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_id_prefix_or_typeContext)
}

func (s *Pragma_stmtContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Pragma_stmtContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEQUALS, 0)
}

func (s *Pragma_stmtContext) AllPragma_value() []IPragma_valueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPragma_valueContext); ok {
			len++
		}
	}

	tst := make([]IPragma_valueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPragma_valueContext); ok {
			tst[i] = t.(IPragma_valueContext)
			i++
		}
	}

	return tst
}

func (s *Pragma_stmtContext) Pragma_value(i int) IPragma_valueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPragma_valueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPragma_valueContext)
}

func (s *Pragma_stmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Pragma_stmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Pragma_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Pragma_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Pragma_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pragma_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pragma_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterPragma_stmt(s)
	}
}

func (s *Pragma_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitPragma_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Pragma_stmt() (localctx IPragma_stmtContext) {
	localctx = NewPragma_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, SQLv1Antlr4ParserRULE_pragma_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1940)
		p.Match(SQLv1Antlr4ParserPRAGMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1941)
		p.Opt_id_prefix_or_type()
	}
	{
		p.SetState(1942)
		p.An_id()
	}
	p.SetState(1956)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserEQUALS:
		{
			p.SetState(1943)
			p.Match(SQLv1Antlr4ParserEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1944)
			p.Pragma_value()
		}

	case SQLv1Antlr4ParserLPAREN:
		{
			p.SetState(1945)
			p.Match(SQLv1Antlr4ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1946)
			p.Pragma_value()
		}
		p.SetState(1951)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SQLv1Antlr4ParserCOMMA {
			{
				p.SetState(1947)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1948)
				p.Pragma_value()
			}

			p.SetState(1953)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1954)
			p.Match(SQLv1Antlr4ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserEOF, SQLv1Antlr4ParserSEMICOLON, SQLv1Antlr4ParserEND:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPragma_valueContext is an interface to support dynamic dispatch.
type IPragma_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Signed_number() ISigned_numberContext
	Id() IIdContext
	STRING_VALUE() antlr.TerminalNode
	Bool_value() IBool_valueContext
	Bind_parameter() IBind_parameterContext

	// IsPragma_valueContext differentiates from other interfaces.
	IsPragma_valueContext()
}

type Pragma_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPragma_valueContext() *Pragma_valueContext {
	var p = new(Pragma_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_pragma_value
	return p
}

func InitEmptyPragma_valueContext(p *Pragma_valueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_pragma_value
}

func (*Pragma_valueContext) IsPragma_valueContext() {}

func NewPragma_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pragma_valueContext {
	var p = new(Pragma_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_pragma_value

	return p
}

func (s *Pragma_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Pragma_valueContext) Signed_number() ISigned_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISigned_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISigned_numberContext)
}

func (s *Pragma_valueContext) Id() IIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *Pragma_valueContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRING_VALUE, 0)
}

func (s *Pragma_valueContext) Bool_value() IBool_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_valueContext)
}

func (s *Pragma_valueContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Pragma_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pragma_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pragma_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterPragma_value(s)
	}
}

func (s *Pragma_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitPragma_value(s)
	}
}

func (p *SQLv1Antlr4Parser) Pragma_value() (localctx IPragma_valueContext) {
	localctx = NewPragma_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, SQLv1Antlr4ParserRULE_pragma_value)
	p.SetState(1963)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserPLUS, SQLv1Antlr4ParserMINUS, SQLv1Antlr4ParserDIGITS, SQLv1Antlr4ParserINTEGER_VALUE, SQLv1Antlr4ParserREAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1958)
			p.Signed_number()
		}

	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALL, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserANY, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSTREAM, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWITHOUT, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1959)
			p.Id()
		}

	case SQLv1Antlr4ParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1960)
			p.Match(SQLv1Antlr4ParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserFALSE, SQLv1Antlr4ParserTRUE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1961)
			p.Bool_value()
		}

	case SQLv1Antlr4ParserDOLLAR:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1962)
			p.Bind_parameter()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISort_specificationContext is an interface to support dynamic dispatch.
type ISort_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsSort_specificationContext differentiates from other interfaces.
	IsSort_specificationContext()
}

type Sort_specificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySort_specificationContext() *Sort_specificationContext {
	var p = new(Sort_specificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_sort_specification
	return p
}

func InitEmptySort_specificationContext(p *Sort_specificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_sort_specification
}

func (*Sort_specificationContext) IsSort_specificationContext() {}

func NewSort_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sort_specificationContext {
	var p = new(Sort_specificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_sort_specification

	return p
}

func (s *Sort_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Sort_specificationContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Sort_specificationContext) ASC() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserASC, 0)
}

func (s *Sort_specificationContext) DESC() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDESC, 0)
}

func (s *Sort_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sort_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sort_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSort_specification(s)
	}
}

func (s *Sort_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSort_specification(s)
	}
}

func (p *SQLv1Antlr4Parser) Sort_specification() (localctx ISort_specificationContext) {
	localctx = NewSort_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, SQLv1Antlr4ParserRULE_sort_specification)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1965)
		p.Expr()
	}
	p.SetState(1967)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserASC || _la == SQLv1Antlr4ParserDESC {
		{
			p.SetState(1966)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLv1Antlr4ParserASC || _la == SQLv1Antlr4ParserDESC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISort_specification_listContext is an interface to support dynamic dispatch.
type ISort_specification_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSort_specification() []ISort_specificationContext
	Sort_specification(i int) ISort_specificationContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSort_specification_listContext differentiates from other interfaces.
	IsSort_specification_listContext()
}

type Sort_specification_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySort_specification_listContext() *Sort_specification_listContext {
	var p = new(Sort_specification_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_sort_specification_list
	return p
}

func InitEmptySort_specification_listContext(p *Sort_specification_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_sort_specification_list
}

func (*Sort_specification_listContext) IsSort_specification_listContext() {}

func NewSort_specification_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sort_specification_listContext {
	var p = new(Sort_specification_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_sort_specification_list

	return p
}

func (s *Sort_specification_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Sort_specification_listContext) AllSort_specification() []ISort_specificationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISort_specificationContext); ok {
			len++
		}
	}

	tst := make([]ISort_specificationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISort_specificationContext); ok {
			tst[i] = t.(ISort_specificationContext)
			i++
		}
	}

	return tst
}

func (s *Sort_specification_listContext) Sort_specification(i int) ISort_specificationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISort_specificationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISort_specificationContext)
}

func (s *Sort_specification_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Sort_specification_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Sort_specification_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sort_specification_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sort_specification_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSort_specification_list(s)
	}
}

func (s *Sort_specification_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSort_specification_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Sort_specification_list() (localctx ISort_specification_listContext) {
	localctx = NewSort_specification_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, SQLv1Antlr4ParserRULE_sort_specification_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1969)
		p.Sort_specification()
	}
	p.SetState(1974)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(1970)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1971)
			p.Sort_specification()
		}

		p.SetState(1976)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_stmtContext is an interface to support dynamic dispatch.
type ISelect_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSelect_kind_parenthesis() []ISelect_kind_parenthesisContext
	Select_kind_parenthesis(i int) ISelect_kind_parenthesisContext
	AllSelect_op() []ISelect_opContext
	Select_op(i int) ISelect_opContext

	// IsSelect_stmtContext differentiates from other interfaces.
	IsSelect_stmtContext()
}

type Select_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_stmtContext() *Select_stmtContext {
	var p = new(Select_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_select_stmt
	return p
}

func InitEmptySelect_stmtContext(p *Select_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_select_stmt
}

func (*Select_stmtContext) IsSelect_stmtContext() {}

func NewSelect_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_stmtContext {
	var p = new(Select_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_select_stmt

	return p
}

func (s *Select_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_stmtContext) AllSelect_kind_parenthesis() []ISelect_kind_parenthesisContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelect_kind_parenthesisContext); ok {
			len++
		}
	}

	tst := make([]ISelect_kind_parenthesisContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelect_kind_parenthesisContext); ok {
			tst[i] = t.(ISelect_kind_parenthesisContext)
			i++
		}
	}

	return tst
}

func (s *Select_stmtContext) Select_kind_parenthesis(i int) ISelect_kind_parenthesisContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_kind_parenthesisContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_kind_parenthesisContext)
}

func (s *Select_stmtContext) AllSelect_op() []ISelect_opContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelect_opContext); ok {
			len++
		}
	}

	tst := make([]ISelect_opContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelect_opContext); ok {
			tst[i] = t.(ISelect_opContext)
			i++
		}
	}

	return tst
}

func (s *Select_stmtContext) Select_op(i int) ISelect_opContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_opContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_opContext)
}

func (s *Select_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSelect_stmt(s)
	}
}

func (s *Select_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSelect_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Select_stmt() (localctx ISelect_stmtContext) {
	localctx = NewSelect_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, SQLv1Antlr4ParserRULE_select_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1977)
		p.Select_kind_parenthesis()
	}
	p.SetState(1983)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserEXCEPT || _la == SQLv1Antlr4ParserINTERSECT || _la == SQLv1Antlr4ParserUNION {
		{
			p.SetState(1978)
			p.Select_op()
		}
		{
			p.SetState(1979)
			p.Select_kind_parenthesis()
		}

		p.SetState(1985)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_unparenthesized_stmtContext is an interface to support dynamic dispatch.
type ISelect_unparenthesized_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_kind_partial() ISelect_kind_partialContext
	AllSelect_op() []ISelect_opContext
	Select_op(i int) ISelect_opContext
	AllSelect_kind_parenthesis() []ISelect_kind_parenthesisContext
	Select_kind_parenthesis(i int) ISelect_kind_parenthesisContext

	// IsSelect_unparenthesized_stmtContext differentiates from other interfaces.
	IsSelect_unparenthesized_stmtContext()
}

type Select_unparenthesized_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_unparenthesized_stmtContext() *Select_unparenthesized_stmtContext {
	var p = new(Select_unparenthesized_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_select_unparenthesized_stmt
	return p
}

func InitEmptySelect_unparenthesized_stmtContext(p *Select_unparenthesized_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_select_unparenthesized_stmt
}

func (*Select_unparenthesized_stmtContext) IsSelect_unparenthesized_stmtContext() {}

func NewSelect_unparenthesized_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_unparenthesized_stmtContext {
	var p = new(Select_unparenthesized_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_select_unparenthesized_stmt

	return p
}

func (s *Select_unparenthesized_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_unparenthesized_stmtContext) Select_kind_partial() ISelect_kind_partialContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_kind_partialContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_kind_partialContext)
}

func (s *Select_unparenthesized_stmtContext) AllSelect_op() []ISelect_opContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelect_opContext); ok {
			len++
		}
	}

	tst := make([]ISelect_opContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelect_opContext); ok {
			tst[i] = t.(ISelect_opContext)
			i++
		}
	}

	return tst
}

func (s *Select_unparenthesized_stmtContext) Select_op(i int) ISelect_opContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_opContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_opContext)
}

func (s *Select_unparenthesized_stmtContext) AllSelect_kind_parenthesis() []ISelect_kind_parenthesisContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelect_kind_parenthesisContext); ok {
			len++
		}
	}

	tst := make([]ISelect_kind_parenthesisContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelect_kind_parenthesisContext); ok {
			tst[i] = t.(ISelect_kind_parenthesisContext)
			i++
		}
	}

	return tst
}

func (s *Select_unparenthesized_stmtContext) Select_kind_parenthesis(i int) ISelect_kind_parenthesisContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_kind_parenthesisContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_kind_parenthesisContext)
}

func (s *Select_unparenthesized_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_unparenthesized_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_unparenthesized_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSelect_unparenthesized_stmt(s)
	}
}

func (s *Select_unparenthesized_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSelect_unparenthesized_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Select_unparenthesized_stmt() (localctx ISelect_unparenthesized_stmtContext) {
	localctx = NewSelect_unparenthesized_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, SQLv1Antlr4ParserRULE_select_unparenthesized_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1986)
		p.Select_kind_partial()
	}
	p.SetState(1992)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserEXCEPT || _la == SQLv1Antlr4ParserINTERSECT || _la == SQLv1Antlr4ParserUNION {
		{
			p.SetState(1987)
			p.Select_op()
		}
		{
			p.SetState(1988)
			p.Select_kind_parenthesis()
		}

		p.SetState(1994)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_kind_parenthesisContext is an interface to support dynamic dispatch.
type ISelect_kind_parenthesisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_kind_partial() ISelect_kind_partialContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode

	// IsSelect_kind_parenthesisContext differentiates from other interfaces.
	IsSelect_kind_parenthesisContext()
}

type Select_kind_parenthesisContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_kind_parenthesisContext() *Select_kind_parenthesisContext {
	var p = new(Select_kind_parenthesisContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_select_kind_parenthesis
	return p
}

func InitEmptySelect_kind_parenthesisContext(p *Select_kind_parenthesisContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_select_kind_parenthesis
}

func (*Select_kind_parenthesisContext) IsSelect_kind_parenthesisContext() {}

func NewSelect_kind_parenthesisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_kind_parenthesisContext {
	var p = new(Select_kind_parenthesisContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_select_kind_parenthesis

	return p
}

func (s *Select_kind_parenthesisContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_kind_parenthesisContext) Select_kind_partial() ISelect_kind_partialContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_kind_partialContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_kind_partialContext)
}

func (s *Select_kind_parenthesisContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Select_kind_parenthesisContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Select_kind_parenthesisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_kind_parenthesisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_kind_parenthesisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSelect_kind_parenthesis(s)
	}
}

func (s *Select_kind_parenthesisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSelect_kind_parenthesis(s)
	}
}

func (p *SQLv1Antlr4Parser) Select_kind_parenthesis() (localctx ISelect_kind_parenthesisContext) {
	localctx = NewSelect_kind_parenthesisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, SQLv1Antlr4ParserRULE_select_kind_parenthesis)
	p.SetState(2000)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserSELECT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1995)
			p.Select_kind_partial()
		}

	case SQLv1Antlr4ParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1996)
			p.Match(SQLv1Antlr4ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1997)
			p.Select_kind_partial()
		}
		{
			p.SetState(1998)
			p.Match(SQLv1Antlr4ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_opContext is an interface to support dynamic dispatch.
type ISelect_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNION() antlr.TerminalNode
	ALL() antlr.TerminalNode
	INTERSECT() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode

	// IsSelect_opContext differentiates from other interfaces.
	IsSelect_opContext()
}

type Select_opContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_opContext() *Select_opContext {
	var p = new(Select_opContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_select_op
	return p
}

func InitEmptySelect_opContext(p *Select_opContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_select_op
}

func (*Select_opContext) IsSelect_opContext() {}

func NewSelect_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_opContext {
	var p = new(Select_opContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_select_op

	return p
}

func (s *Select_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_opContext) UNION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUNION, 0)
}

func (s *Select_opContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserALL, 0)
}

func (s *Select_opContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINTERSECT, 0)
}

func (s *Select_opContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXCEPT, 0)
}

func (s *Select_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSelect_op(s)
	}
}

func (s *Select_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSelect_op(s)
	}
}

func (p *SQLv1Antlr4Parser) Select_op() (localctx ISelect_opContext) {
	localctx = NewSelect_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, SQLv1Antlr4ParserRULE_select_op)
	var _la int

	p.SetState(2008)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserUNION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2002)
			p.Match(SQLv1Antlr4ParserUNION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2004)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserALL {
			{
				p.SetState(2003)
				p.Match(SQLv1Antlr4ParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case SQLv1Antlr4ParserINTERSECT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2006)
			p.Match(SQLv1Antlr4ParserINTERSECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserEXCEPT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2007)
			p.Match(SQLv1Antlr4ParserEXCEPT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_kind_partialContext is an interface to support dynamic dispatch.
type ISelect_kind_partialContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_kind() ISelect_kindContext
	LIMIT() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	OFFSET() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsSelect_kind_partialContext differentiates from other interfaces.
	IsSelect_kind_partialContext()
}

type Select_kind_partialContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_kind_partialContext() *Select_kind_partialContext {
	var p = new(Select_kind_partialContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_select_kind_partial
	return p
}

func InitEmptySelect_kind_partialContext(p *Select_kind_partialContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_select_kind_partial
}

func (*Select_kind_partialContext) IsSelect_kind_partialContext() {}

func NewSelect_kind_partialContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_kind_partialContext {
	var p = new(Select_kind_partialContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_select_kind_partial

	return p
}

func (s *Select_kind_partialContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_kind_partialContext) Select_kind() ISelect_kindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_kindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_kindContext)
}

func (s *Select_kind_partialContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLIMIT, 0)
}

func (s *Select_kind_partialContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Select_kind_partialContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Select_kind_partialContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOFFSET, 0)
}

func (s *Select_kind_partialContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, 0)
}

func (s *Select_kind_partialContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_kind_partialContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_kind_partialContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSelect_kind_partial(s)
	}
}

func (s *Select_kind_partialContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSelect_kind_partial(s)
	}
}

func (p *SQLv1Antlr4Parser) Select_kind_partial() (localctx ISelect_kind_partialContext) {
	localctx = NewSelect_kind_partialContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, SQLv1Antlr4ParserRULE_select_kind_partial)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2010)
		p.Select_kind()
	}
	p.SetState(2017)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserLIMIT {
		{
			p.SetState(2011)
			p.Match(SQLv1Antlr4ParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2012)
			p.Expr()
		}
		p.SetState(2015)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserCOMMA || _la == SQLv1Antlr4ParserOFFSET {
			{
				p.SetState(2013)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SQLv1Antlr4ParserCOMMA || _la == SQLv1Antlr4ParserOFFSET) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2014)
				p.Expr()
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_kindContext is an interface to support dynamic dispatch.
type ISelect_kindContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Process_core() IProcess_coreContext
	Reduce_core() IReduce_coreContext
	Select_core() ISelect_coreContext
	DISCARD() antlr.TerminalNode
	INTO() antlr.TerminalNode
	RESULT() antlr.TerminalNode
	Pure_column_or_named() IPure_column_or_namedContext

	// IsSelect_kindContext differentiates from other interfaces.
	IsSelect_kindContext()
}

type Select_kindContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_kindContext() *Select_kindContext {
	var p = new(Select_kindContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_select_kind
	return p
}

func InitEmptySelect_kindContext(p *Select_kindContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_select_kind
}

func (*Select_kindContext) IsSelect_kindContext() {}

func NewSelect_kindContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_kindContext {
	var p = new(Select_kindContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_select_kind

	return p
}

func (s *Select_kindContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_kindContext) Process_core() IProcess_coreContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcess_coreContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcess_coreContext)
}

func (s *Select_kindContext) Reduce_core() IReduce_coreContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReduce_coreContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReduce_coreContext)
}

func (s *Select_kindContext) Select_core() ISelect_coreContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_coreContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_coreContext)
}

func (s *Select_kindContext) DISCARD() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDISCARD, 0)
}

func (s *Select_kindContext) INTO() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINTO, 0)
}

func (s *Select_kindContext) RESULT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRESULT, 0)
}

func (s *Select_kindContext) Pure_column_or_named() IPure_column_or_namedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPure_column_or_namedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPure_column_or_namedContext)
}

func (s *Select_kindContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_kindContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_kindContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSelect_kind(s)
	}
}

func (s *Select_kindContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSelect_kind(s)
	}
}

func (p *SQLv1Antlr4Parser) Select_kind() (localctx ISelect_kindContext) {
	localctx = NewSelect_kindContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, SQLv1Antlr4ParserRULE_select_kind)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2020)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserDISCARD {
		{
			p.SetState(2019)
			p.Match(SQLv1Antlr4ParserDISCARD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2025)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserPROCESS:
		{
			p.SetState(2022)
			p.Process_core()
		}

	case SQLv1Antlr4ParserREDUCE:
		{
			p.SetState(2023)
			p.Reduce_core()
		}

	case SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserSELECT:
		{
			p.SetState(2024)
			p.Select_core()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(2030)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserINTO {
		{
			p.SetState(2027)
			p.Match(SQLv1Antlr4ParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2028)
			p.Match(SQLv1Antlr4ParserRESULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2029)
			p.Pure_column_or_named()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcess_coreContext is an interface to support dynamic dispatch.
type IProcess_coreContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROCESS() antlr.TerminalNode
	AllNamed_single_source() []INamed_single_sourceContext
	Named_single_source(i int) INamed_single_sourceContext
	STREAM() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	USING() antlr.TerminalNode
	Using_call_expr() IUsing_call_exprContext
	AS() antlr.TerminalNode
	An_id() IAn_idContext
	WITH() antlr.TerminalNode
	External_call_settings() IExternal_call_settingsContext
	WHERE() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	HAVING() antlr.TerminalNode
	ASSUME() antlr.TerminalNode
	Order_by_clause() IOrder_by_clauseContext

	// IsProcess_coreContext differentiates from other interfaces.
	IsProcess_coreContext()
}

type Process_coreContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcess_coreContext() *Process_coreContext {
	var p = new(Process_coreContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_process_core
	return p
}

func InitEmptyProcess_coreContext(p *Process_coreContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_process_core
}

func (*Process_coreContext) IsProcess_coreContext() {}

func NewProcess_coreContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Process_coreContext {
	var p = new(Process_coreContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_process_core

	return p
}

func (s *Process_coreContext) GetParser() antlr.Parser { return s.parser }

func (s *Process_coreContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPROCESS, 0)
}

func (s *Process_coreContext) AllNamed_single_source() []INamed_single_sourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamed_single_sourceContext); ok {
			len++
		}
	}

	tst := make([]INamed_single_sourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamed_single_sourceContext); ok {
			tst[i] = t.(INamed_single_sourceContext)
			i++
		}
	}

	return tst
}

func (s *Process_coreContext) Named_single_source(i int) INamed_single_sourceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_single_sourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_single_sourceContext)
}

func (s *Process_coreContext) STREAM() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTREAM, 0)
}

func (s *Process_coreContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Process_coreContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Process_coreContext) USING() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUSING, 0)
}

func (s *Process_coreContext) Using_call_expr() IUsing_call_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsing_call_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsing_call_exprContext)
}

func (s *Process_coreContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAS, 0)
}

func (s *Process_coreContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Process_coreContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWITH, 0)
}

func (s *Process_coreContext) External_call_settings() IExternal_call_settingsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternal_call_settingsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternal_call_settingsContext)
}

func (s *Process_coreContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWHERE, 0)
}

func (s *Process_coreContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Process_coreContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Process_coreContext) HAVING() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserHAVING, 0)
}

func (s *Process_coreContext) ASSUME() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserASSUME, 0)
}

func (s *Process_coreContext) Order_by_clause() IOrder_by_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_by_clauseContext)
}

func (s *Process_coreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Process_coreContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Process_coreContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterProcess_core(s)
	}
}

func (s *Process_coreContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitProcess_core(s)
	}
}

func (p *SQLv1Antlr4Parser) Process_core() (localctx IProcess_coreContext) {
	localctx = NewProcess_coreContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, SQLv1Antlr4ParserRULE_process_core)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2032)
		p.Match(SQLv1Antlr4ParserPROCESS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2034)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 161, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2033)
			p.Match(SQLv1Antlr4ParserSTREAM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2036)
		p.Named_single_source()
	}
	p.SetState(2041)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(2037)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2038)
			p.Named_single_source()
		}

		p.SetState(2043)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2066)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserUSING {
		{
			p.SetState(2044)
			p.Match(SQLv1Antlr4ParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2045)
			p.Using_call_expr()
		}
		p.SetState(2048)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserAS {
			{
				p.SetState(2046)
				p.Match(SQLv1Antlr4ParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2047)
				p.An_id()
			}

		}
		p.SetState(2052)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserWITH {
			{
				p.SetState(2050)
				p.Match(SQLv1Antlr4ParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2051)
				p.External_call_settings()
			}

		}
		p.SetState(2056)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserWHERE {
			{
				p.SetState(2054)
				p.Match(SQLv1Antlr4ParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2055)
				p.Expr()
			}

		}
		p.SetState(2060)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserHAVING {
			{
				p.SetState(2058)
				p.Match(SQLv1Antlr4ParserHAVING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2059)
				p.Expr()
			}

		}
		p.SetState(2064)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserASSUME {
			{
				p.SetState(2062)
				p.Match(SQLv1Antlr4ParserASSUME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2063)
				p.Order_by_clause()
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExternal_call_paramContext is an interface to support dynamic dispatch.
type IExternal_call_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext
	EQUALS() antlr.TerminalNode
	Expr() IExprContext

	// IsExternal_call_paramContext differentiates from other interfaces.
	IsExternal_call_paramContext()
}

type External_call_paramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternal_call_paramContext() *External_call_paramContext {
	var p = new(External_call_paramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_external_call_param
	return p
}

func InitEmptyExternal_call_paramContext(p *External_call_paramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_external_call_param
}

func (*External_call_paramContext) IsExternal_call_paramContext() {}

func NewExternal_call_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *External_call_paramContext {
	var p = new(External_call_paramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_external_call_param

	return p
}

func (s *External_call_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *External_call_paramContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *External_call_paramContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEQUALS, 0)
}

func (s *External_call_paramContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *External_call_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *External_call_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *External_call_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterExternal_call_param(s)
	}
}

func (s *External_call_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitExternal_call_param(s)
	}
}

func (p *SQLv1Antlr4Parser) External_call_param() (localctx IExternal_call_paramContext) {
	localctx = NewExternal_call_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, SQLv1Antlr4ParserRULE_external_call_param)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2068)
		p.An_id()
	}
	{
		p.SetState(2069)
		p.Match(SQLv1Antlr4ParserEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2070)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExternal_call_settingsContext is an interface to support dynamic dispatch.
type IExternal_call_settingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExternal_call_param() []IExternal_call_paramContext
	External_call_param(i int) IExternal_call_paramContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExternal_call_settingsContext differentiates from other interfaces.
	IsExternal_call_settingsContext()
}

type External_call_settingsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternal_call_settingsContext() *External_call_settingsContext {
	var p = new(External_call_settingsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_external_call_settings
	return p
}

func InitEmptyExternal_call_settingsContext(p *External_call_settingsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_external_call_settings
}

func (*External_call_settingsContext) IsExternal_call_settingsContext() {}

func NewExternal_call_settingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *External_call_settingsContext {
	var p = new(External_call_settingsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_external_call_settings

	return p
}

func (s *External_call_settingsContext) GetParser() antlr.Parser { return s.parser }

func (s *External_call_settingsContext) AllExternal_call_param() []IExternal_call_paramContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExternal_call_paramContext); ok {
			len++
		}
	}

	tst := make([]IExternal_call_paramContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExternal_call_paramContext); ok {
			tst[i] = t.(IExternal_call_paramContext)
			i++
		}
	}

	return tst
}

func (s *External_call_settingsContext) External_call_param(i int) IExternal_call_paramContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternal_call_paramContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternal_call_paramContext)
}

func (s *External_call_settingsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *External_call_settingsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *External_call_settingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *External_call_settingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *External_call_settingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterExternal_call_settings(s)
	}
}

func (s *External_call_settingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitExternal_call_settings(s)
	}
}

func (p *SQLv1Antlr4Parser) External_call_settings() (localctx IExternal_call_settingsContext) {
	localctx = NewExternal_call_settingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, SQLv1Antlr4ParserRULE_external_call_settings)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2072)
		p.External_call_param()
	}
	p.SetState(2077)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(2073)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2074)
			p.External_call_param()
		}

		p.SetState(2079)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReduce_coreContext is an interface to support dynamic dispatch.
type IReduce_coreContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REDUCE() antlr.TerminalNode
	AllNamed_single_source() []INamed_single_sourceContext
	Named_single_source(i int) INamed_single_sourceContext
	ON() antlr.TerminalNode
	Column_list() IColumn_listContext
	USING() antlr.TerminalNode
	Using_call_expr() IUsing_call_exprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	PRESORT() antlr.TerminalNode
	Sort_specification_list() ISort_specification_listContext
	ALL() antlr.TerminalNode
	AS() antlr.TerminalNode
	An_id() IAn_idContext
	WHERE() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	HAVING() antlr.TerminalNode
	ASSUME() antlr.TerminalNode
	Order_by_clause() IOrder_by_clauseContext

	// IsReduce_coreContext differentiates from other interfaces.
	IsReduce_coreContext()
}

type Reduce_coreContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReduce_coreContext() *Reduce_coreContext {
	var p = new(Reduce_coreContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_reduce_core
	return p
}

func InitEmptyReduce_coreContext(p *Reduce_coreContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_reduce_core
}

func (*Reduce_coreContext) IsReduce_coreContext() {}

func NewReduce_coreContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Reduce_coreContext {
	var p = new(Reduce_coreContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_reduce_core

	return p
}

func (s *Reduce_coreContext) GetParser() antlr.Parser { return s.parser }

func (s *Reduce_coreContext) REDUCE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREDUCE, 0)
}

func (s *Reduce_coreContext) AllNamed_single_source() []INamed_single_sourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamed_single_sourceContext); ok {
			len++
		}
	}

	tst := make([]INamed_single_sourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamed_single_sourceContext); ok {
			tst[i] = t.(INamed_single_sourceContext)
			i++
		}
	}

	return tst
}

func (s *Reduce_coreContext) Named_single_source(i int) INamed_single_sourceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_single_sourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_single_sourceContext)
}

func (s *Reduce_coreContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserON, 0)
}

func (s *Reduce_coreContext) Column_list() IColumn_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_listContext)
}

func (s *Reduce_coreContext) USING() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUSING, 0)
}

func (s *Reduce_coreContext) Using_call_expr() IUsing_call_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsing_call_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsing_call_exprContext)
}

func (s *Reduce_coreContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Reduce_coreContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Reduce_coreContext) PRESORT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPRESORT, 0)
}

func (s *Reduce_coreContext) Sort_specification_list() ISort_specification_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISort_specification_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISort_specification_listContext)
}

func (s *Reduce_coreContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserALL, 0)
}

func (s *Reduce_coreContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAS, 0)
}

func (s *Reduce_coreContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Reduce_coreContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWHERE, 0)
}

func (s *Reduce_coreContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Reduce_coreContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Reduce_coreContext) HAVING() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserHAVING, 0)
}

func (s *Reduce_coreContext) ASSUME() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserASSUME, 0)
}

func (s *Reduce_coreContext) Order_by_clause() IOrder_by_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_by_clauseContext)
}

func (s *Reduce_coreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Reduce_coreContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Reduce_coreContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterReduce_core(s)
	}
}

func (s *Reduce_coreContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitReduce_core(s)
	}
}

func (p *SQLv1Antlr4Parser) Reduce_core() (localctx IReduce_coreContext) {
	localctx = NewReduce_coreContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, SQLv1Antlr4ParserRULE_reduce_core)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2080)
		p.Match(SQLv1Antlr4ParserREDUCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2081)
		p.Named_single_source()
	}
	p.SetState(2086)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(2082)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2083)
			p.Named_single_source()
		}

		p.SetState(2088)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2091)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserPRESORT {
		{
			p.SetState(2089)
			p.Match(SQLv1Antlr4ParserPRESORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2090)
			p.Sort_specification_list()
		}

	}
	{
		p.SetState(2093)
		p.Match(SQLv1Antlr4ParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2094)
		p.Column_list()
	}
	{
		p.SetState(2095)
		p.Match(SQLv1Antlr4ParserUSING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2097)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 172, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2096)
			p.Match(SQLv1Antlr4ParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2099)
		p.Using_call_expr()
	}
	p.SetState(2102)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserAS {
		{
			p.SetState(2100)
			p.Match(SQLv1Antlr4ParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2101)
			p.An_id()
		}

	}
	p.SetState(2106)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserWHERE {
		{
			p.SetState(2104)
			p.Match(SQLv1Antlr4ParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2105)
			p.Expr()
		}

	}
	p.SetState(2110)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserHAVING {
		{
			p.SetState(2108)
			p.Match(SQLv1Antlr4ParserHAVING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2109)
			p.Expr()
		}

	}
	p.SetState(2114)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserASSUME {
		{
			p.SetState(2112)
			p.Match(SQLv1Antlr4ParserASSUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2113)
			p.Order_by_clause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_set_quantifierContext is an interface to support dynamic dispatch.
type IOpt_set_quantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode

	// IsOpt_set_quantifierContext differentiates from other interfaces.
	IsOpt_set_quantifierContext()
}

type Opt_set_quantifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_set_quantifierContext() *Opt_set_quantifierContext {
	var p = new(Opt_set_quantifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_opt_set_quantifier
	return p
}

func InitEmptyOpt_set_quantifierContext(p *Opt_set_quantifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_opt_set_quantifier
}

func (*Opt_set_quantifierContext) IsOpt_set_quantifierContext() {}

func NewOpt_set_quantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_set_quantifierContext {
	var p = new(Opt_set_quantifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_opt_set_quantifier

	return p
}

func (s *Opt_set_quantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_set_quantifierContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserALL, 0)
}

func (s *Opt_set_quantifierContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDISTINCT, 0)
}

func (s *Opt_set_quantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_set_quantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_set_quantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterOpt_set_quantifier(s)
	}
}

func (s *Opt_set_quantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitOpt_set_quantifier(s)
	}
}

func (p *SQLv1Antlr4Parser) Opt_set_quantifier() (localctx IOpt_set_quantifierContext) {
	localctx = NewOpt_set_quantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, SQLv1Antlr4ParserRULE_opt_set_quantifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2117)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 177, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2116)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLv1Antlr4ParserALL || _la == SQLv1Antlr4ParserDISTINCT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_coreContext is an interface to support dynamic dispatch.
type ISelect_coreContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	Opt_set_quantifier() IOpt_set_quantifierContext
	AllResult_column() []IResult_columnContext
	Result_column(i int) IResult_columnContext
	AllFROM() []antlr.TerminalNode
	FROM(i int) antlr.TerminalNode
	AllJoin_source() []IJoin_sourceContext
	Join_source(i int) IJoin_sourceContext
	STREAM() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WITHOUT() antlr.TerminalNode
	Without_column_list() IWithout_column_listContext
	WHERE() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	Group_by_clause() IGroup_by_clauseContext
	HAVING() antlr.TerminalNode
	Window_clause() IWindow_clauseContext
	Ext_order_by_clause() IExt_order_by_clauseContext

	// IsSelect_coreContext differentiates from other interfaces.
	IsSelect_coreContext()
}

type Select_coreContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_coreContext() *Select_coreContext {
	var p = new(Select_coreContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_select_core
	return p
}

func InitEmptySelect_coreContext(p *Select_coreContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_select_core
}

func (*Select_coreContext) IsSelect_coreContext() {}

func NewSelect_coreContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_coreContext {
	var p = new(Select_coreContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_select_core

	return p
}

func (s *Select_coreContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_coreContext) SELECT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSELECT, 0)
}

func (s *Select_coreContext) Opt_set_quantifier() IOpt_set_quantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_set_quantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_set_quantifierContext)
}

func (s *Select_coreContext) AllResult_column() []IResult_columnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IResult_columnContext); ok {
			len++
		}
	}

	tst := make([]IResult_columnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IResult_columnContext); ok {
			tst[i] = t.(IResult_columnContext)
			i++
		}
	}

	return tst
}

func (s *Select_coreContext) Result_column(i int) IResult_columnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResult_columnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResult_columnContext)
}

func (s *Select_coreContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserFROM)
}

func (s *Select_coreContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFROM, i)
}

func (s *Select_coreContext) AllJoin_source() []IJoin_sourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoin_sourceContext); ok {
			len++
		}
	}

	tst := make([]IJoin_sourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoin_sourceContext); ok {
			tst[i] = t.(IJoin_sourceContext)
			i++
		}
	}

	return tst
}

func (s *Select_coreContext) Join_source(i int) IJoin_sourceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoin_sourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoin_sourceContext)
}

func (s *Select_coreContext) STREAM() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTREAM, 0)
}

func (s *Select_coreContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Select_coreContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Select_coreContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWITHOUT, 0)
}

func (s *Select_coreContext) Without_column_list() IWithout_column_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithout_column_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithout_column_listContext)
}

func (s *Select_coreContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWHERE, 0)
}

func (s *Select_coreContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Select_coreContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Select_coreContext) Group_by_clause() IGroup_by_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroup_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroup_by_clauseContext)
}

func (s *Select_coreContext) HAVING() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserHAVING, 0)
}

func (s *Select_coreContext) Window_clause() IWindow_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_clauseContext)
}

func (s *Select_coreContext) Ext_order_by_clause() IExt_order_by_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExt_order_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExt_order_by_clauseContext)
}

func (s *Select_coreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_coreContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_coreContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSelect_core(s)
	}
}

func (s *Select_coreContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSelect_core(s)
	}
}

func (p *SQLv1Antlr4Parser) Select_core() (localctx ISelect_coreContext) {
	localctx = NewSelect_coreContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, SQLv1Antlr4ParserRULE_select_core)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2121)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserFROM {
		{
			p.SetState(2119)
			p.Match(SQLv1Antlr4ParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2120)
			p.Join_source()
		}

	}
	{
		p.SetState(2123)
		p.Match(SQLv1Antlr4ParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2125)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2124)
			p.Match(SQLv1Antlr4ParserSTREAM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2127)
		p.Opt_set_quantifier()
	}
	{
		p.SetState(2128)
		p.Result_column()
	}
	p.SetState(2133)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 180, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2129)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2130)
				p.Result_column()
			}

		}
		p.SetState(2135)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 180, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2137)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(2136)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2141)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserWITHOUT {
		{
			p.SetState(2139)
			p.Match(SQLv1Antlr4ParserWITHOUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2140)
			p.Without_column_list()
		}

	}
	p.SetState(2145)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserFROM {
		{
			p.SetState(2143)
			p.Match(SQLv1Antlr4ParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2144)
			p.Join_source()
		}

	}
	p.SetState(2149)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserWHERE {
		{
			p.SetState(2147)
			p.Match(SQLv1Antlr4ParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2148)
			p.Expr()
		}

	}
	p.SetState(2152)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserGROUP {
		{
			p.SetState(2151)
			p.Group_by_clause()
		}

	}
	p.SetState(2156)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserHAVING {
		{
			p.SetState(2154)
			p.Match(SQLv1Antlr4ParserHAVING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2155)
			p.Expr()
		}

	}
	p.SetState(2159)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserWINDOW {
		{
			p.SetState(2158)
			p.Window_clause()
		}

	}
	p.SetState(2162)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserASSUME || _la == SQLv1Antlr4ParserORDER {
		{
			p.SetState(2161)
			p.Ext_order_by_clause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_pattern_recognition_clauseContext is an interface to support dynamic dispatch.
type IRow_pattern_recognition_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MATCH_RECOGNIZE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Row_pattern_common_syntax() IRow_pattern_common_syntaxContext
	RPAREN() antlr.TerminalNode
	Window_partition_clause() IWindow_partition_clauseContext
	Order_by_clause() IOrder_by_clauseContext
	Row_pattern_measures() IRow_pattern_measuresContext
	Row_pattern_rows_per_match() IRow_pattern_rows_per_matchContext

	// IsRow_pattern_recognition_clauseContext differentiates from other interfaces.
	IsRow_pattern_recognition_clauseContext()
}

type Row_pattern_recognition_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_recognition_clauseContext() *Row_pattern_recognition_clauseContext {
	var p = new(Row_pattern_recognition_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_recognition_clause
	return p
}

func InitEmptyRow_pattern_recognition_clauseContext(p *Row_pattern_recognition_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_recognition_clause
}

func (*Row_pattern_recognition_clauseContext) IsRow_pattern_recognition_clauseContext() {}

func NewRow_pattern_recognition_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_recognition_clauseContext {
	var p = new(Row_pattern_recognition_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_recognition_clause

	return p
}

func (s *Row_pattern_recognition_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_recognition_clauseContext) MATCH_RECOGNIZE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMATCH_RECOGNIZE, 0)
}

func (s *Row_pattern_recognition_clauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Row_pattern_recognition_clauseContext) Row_pattern_common_syntax() IRow_pattern_common_syntaxContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_common_syntaxContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_common_syntaxContext)
}

func (s *Row_pattern_recognition_clauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Row_pattern_recognition_clauseContext) Window_partition_clause() IWindow_partition_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_partition_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_partition_clauseContext)
}

func (s *Row_pattern_recognition_clauseContext) Order_by_clause() IOrder_by_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_by_clauseContext)
}

func (s *Row_pattern_recognition_clauseContext) Row_pattern_measures() IRow_pattern_measuresContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_measuresContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_measuresContext)
}

func (s *Row_pattern_recognition_clauseContext) Row_pattern_rows_per_match() IRow_pattern_rows_per_matchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_rows_per_matchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_rows_per_matchContext)
}

func (s *Row_pattern_recognition_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_recognition_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_pattern_recognition_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRow_pattern_recognition_clause(s)
	}
}

func (s *Row_pattern_recognition_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRow_pattern_recognition_clause(s)
	}
}

func (p *SQLv1Antlr4Parser) Row_pattern_recognition_clause() (localctx IRow_pattern_recognition_clauseContext) {
	localctx = NewRow_pattern_recognition_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, SQLv1Antlr4ParserRULE_row_pattern_recognition_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2164)
		p.Match(SQLv1Antlr4ParserMATCH_RECOGNIZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2165)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2167)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserPARTITION {
		{
			p.SetState(2166)
			p.Window_partition_clause()
		}

	}
	p.SetState(2170)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserORDER {
		{
			p.SetState(2169)
			p.Order_by_clause()
		}

	}
	p.SetState(2173)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserMEASURES {
		{
			p.SetState(2172)
			p.Row_pattern_measures()
		}

	}
	p.SetState(2176)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserALL || _la == SQLv1Antlr4ParserONE {
		{
			p.SetState(2175)
			p.Row_pattern_rows_per_match()
		}

	}
	{
		p.SetState(2178)
		p.Row_pattern_common_syntax()
	}
	{
		p.SetState(2179)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_pattern_rows_per_matchContext is an interface to support dynamic dispatch.
type IRow_pattern_rows_per_matchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ONE() antlr.TerminalNode
	ROW() antlr.TerminalNode
	PER() antlr.TerminalNode
	MATCH() antlr.TerminalNode
	ALL() antlr.TerminalNode
	ROWS() antlr.TerminalNode
	Row_pattern_empty_match_handling() IRow_pattern_empty_match_handlingContext

	// IsRow_pattern_rows_per_matchContext differentiates from other interfaces.
	IsRow_pattern_rows_per_matchContext()
}

type Row_pattern_rows_per_matchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_rows_per_matchContext() *Row_pattern_rows_per_matchContext {
	var p = new(Row_pattern_rows_per_matchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_rows_per_match
	return p
}

func InitEmptyRow_pattern_rows_per_matchContext(p *Row_pattern_rows_per_matchContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_rows_per_match
}

func (*Row_pattern_rows_per_matchContext) IsRow_pattern_rows_per_matchContext() {}

func NewRow_pattern_rows_per_matchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_rows_per_matchContext {
	var p = new(Row_pattern_rows_per_matchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_rows_per_match

	return p
}

func (s *Row_pattern_rows_per_matchContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_rows_per_matchContext) ONE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserONE, 0)
}

func (s *Row_pattern_rows_per_matchContext) ROW() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserROW, 0)
}

func (s *Row_pattern_rows_per_matchContext) PER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPER, 0)
}

func (s *Row_pattern_rows_per_matchContext) MATCH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMATCH, 0)
}

func (s *Row_pattern_rows_per_matchContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserALL, 0)
}

func (s *Row_pattern_rows_per_matchContext) ROWS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserROWS, 0)
}

func (s *Row_pattern_rows_per_matchContext) Row_pattern_empty_match_handling() IRow_pattern_empty_match_handlingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_empty_match_handlingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_empty_match_handlingContext)
}

func (s *Row_pattern_rows_per_matchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_rows_per_matchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_pattern_rows_per_matchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRow_pattern_rows_per_match(s)
	}
}

func (s *Row_pattern_rows_per_matchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRow_pattern_rows_per_match(s)
	}
}

func (p *SQLv1Antlr4Parser) Row_pattern_rows_per_match() (localctx IRow_pattern_rows_per_matchContext) {
	localctx = NewRow_pattern_rows_per_matchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, SQLv1Antlr4ParserRULE_row_pattern_rows_per_match)
	var _la int

	p.SetState(2192)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserONE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2181)
			p.Match(SQLv1Antlr4ParserONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2182)
			p.Match(SQLv1Antlr4ParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2183)
			p.Match(SQLv1Antlr4ParserPER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2184)
			p.Match(SQLv1Antlr4ParserMATCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserALL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2185)
			p.Match(SQLv1Antlr4ParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2186)
			p.Match(SQLv1Antlr4ParserROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2187)
			p.Match(SQLv1Antlr4ParserPER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2188)
			p.Match(SQLv1Antlr4ParserMATCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2190)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserOMIT || _la == SQLv1Antlr4ParserSHOW || _la == SQLv1Antlr4ParserWITH {
			{
				p.SetState(2189)
				p.Row_pattern_empty_match_handling()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_pattern_empty_match_handlingContext is an interface to support dynamic dispatch.
type IRow_pattern_empty_match_handlingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	EMPTY() antlr.TerminalNode
	MATCHES() antlr.TerminalNode
	OMIT() antlr.TerminalNode
	WITH() antlr.TerminalNode
	UNMATCHED() antlr.TerminalNode
	ROWS() antlr.TerminalNode

	// IsRow_pattern_empty_match_handlingContext differentiates from other interfaces.
	IsRow_pattern_empty_match_handlingContext()
}

type Row_pattern_empty_match_handlingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_empty_match_handlingContext() *Row_pattern_empty_match_handlingContext {
	var p = new(Row_pattern_empty_match_handlingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_empty_match_handling
	return p
}

func InitEmptyRow_pattern_empty_match_handlingContext(p *Row_pattern_empty_match_handlingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_empty_match_handling
}

func (*Row_pattern_empty_match_handlingContext) IsRow_pattern_empty_match_handlingContext() {}

func NewRow_pattern_empty_match_handlingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_empty_match_handlingContext {
	var p = new(Row_pattern_empty_match_handlingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_empty_match_handling

	return p
}

func (s *Row_pattern_empty_match_handlingContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_empty_match_handlingContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSHOW, 0)
}

func (s *Row_pattern_empty_match_handlingContext) EMPTY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEMPTY, 0)
}

func (s *Row_pattern_empty_match_handlingContext) MATCHES() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMATCHES, 0)
}

func (s *Row_pattern_empty_match_handlingContext) OMIT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOMIT, 0)
}

func (s *Row_pattern_empty_match_handlingContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWITH, 0)
}

func (s *Row_pattern_empty_match_handlingContext) UNMATCHED() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUNMATCHED, 0)
}

func (s *Row_pattern_empty_match_handlingContext) ROWS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserROWS, 0)
}

func (s *Row_pattern_empty_match_handlingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_empty_match_handlingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_pattern_empty_match_handlingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRow_pattern_empty_match_handling(s)
	}
}

func (s *Row_pattern_empty_match_handlingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRow_pattern_empty_match_handling(s)
	}
}

func (p *SQLv1Antlr4Parser) Row_pattern_empty_match_handling() (localctx IRow_pattern_empty_match_handlingContext) {
	localctx = NewRow_pattern_empty_match_handlingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, SQLv1Antlr4ParserRULE_row_pattern_empty_match_handling)
	p.SetState(2203)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserSHOW:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2194)
			p.Match(SQLv1Antlr4ParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2195)
			p.Match(SQLv1Antlr4ParserEMPTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2196)
			p.Match(SQLv1Antlr4ParserMATCHES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserOMIT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2197)
			p.Match(SQLv1Antlr4ParserOMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2198)
			p.Match(SQLv1Antlr4ParserEMPTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2199)
			p.Match(SQLv1Antlr4ParserMATCHES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserWITH:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2200)
			p.Match(SQLv1Antlr4ParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2201)
			p.Match(SQLv1Antlr4ParserUNMATCHED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2202)
			p.Match(SQLv1Antlr4ParserROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_pattern_measuresContext is an interface to support dynamic dispatch.
type IRow_pattern_measuresContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MEASURES() antlr.TerminalNode
	Row_pattern_measure_list() IRow_pattern_measure_listContext

	// IsRow_pattern_measuresContext differentiates from other interfaces.
	IsRow_pattern_measuresContext()
}

type Row_pattern_measuresContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_measuresContext() *Row_pattern_measuresContext {
	var p = new(Row_pattern_measuresContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_measures
	return p
}

func InitEmptyRow_pattern_measuresContext(p *Row_pattern_measuresContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_measures
}

func (*Row_pattern_measuresContext) IsRow_pattern_measuresContext() {}

func NewRow_pattern_measuresContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_measuresContext {
	var p = new(Row_pattern_measuresContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_measures

	return p
}

func (s *Row_pattern_measuresContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_measuresContext) MEASURES() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMEASURES, 0)
}

func (s *Row_pattern_measuresContext) Row_pattern_measure_list() IRow_pattern_measure_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_measure_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_measure_listContext)
}

func (s *Row_pattern_measuresContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_measuresContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_pattern_measuresContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRow_pattern_measures(s)
	}
}

func (s *Row_pattern_measuresContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRow_pattern_measures(s)
	}
}

func (p *SQLv1Antlr4Parser) Row_pattern_measures() (localctx IRow_pattern_measuresContext) {
	localctx = NewRow_pattern_measuresContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, SQLv1Antlr4ParserRULE_row_pattern_measures)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2205)
		p.Match(SQLv1Antlr4ParserMEASURES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2206)
		p.Row_pattern_measure_list()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_pattern_measure_listContext is an interface to support dynamic dispatch.
type IRow_pattern_measure_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRow_pattern_measure_definition() []IRow_pattern_measure_definitionContext
	Row_pattern_measure_definition(i int) IRow_pattern_measure_definitionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRow_pattern_measure_listContext differentiates from other interfaces.
	IsRow_pattern_measure_listContext()
}

type Row_pattern_measure_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_measure_listContext() *Row_pattern_measure_listContext {
	var p = new(Row_pattern_measure_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_measure_list
	return p
}

func InitEmptyRow_pattern_measure_listContext(p *Row_pattern_measure_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_measure_list
}

func (*Row_pattern_measure_listContext) IsRow_pattern_measure_listContext() {}

func NewRow_pattern_measure_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_measure_listContext {
	var p = new(Row_pattern_measure_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_measure_list

	return p
}

func (s *Row_pattern_measure_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_measure_listContext) AllRow_pattern_measure_definition() []IRow_pattern_measure_definitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRow_pattern_measure_definitionContext); ok {
			len++
		}
	}

	tst := make([]IRow_pattern_measure_definitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRow_pattern_measure_definitionContext); ok {
			tst[i] = t.(IRow_pattern_measure_definitionContext)
			i++
		}
	}

	return tst
}

func (s *Row_pattern_measure_listContext) Row_pattern_measure_definition(i int) IRow_pattern_measure_definitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_measure_definitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_measure_definitionContext)
}

func (s *Row_pattern_measure_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Row_pattern_measure_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Row_pattern_measure_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_measure_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_pattern_measure_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRow_pattern_measure_list(s)
	}
}

func (s *Row_pattern_measure_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRow_pattern_measure_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Row_pattern_measure_list() (localctx IRow_pattern_measure_listContext) {
	localctx = NewRow_pattern_measure_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, SQLv1Antlr4ParserRULE_row_pattern_measure_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2208)
		p.Row_pattern_measure_definition()
	}
	p.SetState(2213)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(2209)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2210)
			p.Row_pattern_measure_definition()
		}

		p.SetState(2215)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_pattern_measure_definitionContext is an interface to support dynamic dispatch.
type IRow_pattern_measure_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	AS() antlr.TerminalNode
	An_id() IAn_idContext

	// IsRow_pattern_measure_definitionContext differentiates from other interfaces.
	IsRow_pattern_measure_definitionContext()
}

type Row_pattern_measure_definitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_measure_definitionContext() *Row_pattern_measure_definitionContext {
	var p = new(Row_pattern_measure_definitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_measure_definition
	return p
}

func InitEmptyRow_pattern_measure_definitionContext(p *Row_pattern_measure_definitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_measure_definition
}

func (*Row_pattern_measure_definitionContext) IsRow_pattern_measure_definitionContext() {}

func NewRow_pattern_measure_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_measure_definitionContext {
	var p = new(Row_pattern_measure_definitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_measure_definition

	return p
}

func (s *Row_pattern_measure_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_measure_definitionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Row_pattern_measure_definitionContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAS, 0)
}

func (s *Row_pattern_measure_definitionContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Row_pattern_measure_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_measure_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_pattern_measure_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRow_pattern_measure_definition(s)
	}
}

func (s *Row_pattern_measure_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRow_pattern_measure_definition(s)
	}
}

func (p *SQLv1Antlr4Parser) Row_pattern_measure_definition() (localctx IRow_pattern_measure_definitionContext) {
	localctx = NewRow_pattern_measure_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, SQLv1Antlr4ParserRULE_row_pattern_measure_definition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2216)
		p.Expr()
	}
	{
		p.SetState(2217)
		p.Match(SQLv1Antlr4ParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2218)
		p.An_id()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_pattern_common_syntaxContext is an interface to support dynamic dispatch.
type IRow_pattern_common_syntaxContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PATTERN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Row_pattern() IRow_patternContext
	RPAREN() antlr.TerminalNode
	DEFINE() antlr.TerminalNode
	Row_pattern_definition_list() IRow_pattern_definition_listContext
	AFTER() antlr.TerminalNode
	MATCH() antlr.TerminalNode
	Row_pattern_skip_to() IRow_pattern_skip_toContext
	Row_pattern_initial_or_seek() IRow_pattern_initial_or_seekContext
	Row_pattern_subset_clause() IRow_pattern_subset_clauseContext

	// IsRow_pattern_common_syntaxContext differentiates from other interfaces.
	IsRow_pattern_common_syntaxContext()
}

type Row_pattern_common_syntaxContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_common_syntaxContext() *Row_pattern_common_syntaxContext {
	var p = new(Row_pattern_common_syntaxContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_common_syntax
	return p
}

func InitEmptyRow_pattern_common_syntaxContext(p *Row_pattern_common_syntaxContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_common_syntax
}

func (*Row_pattern_common_syntaxContext) IsRow_pattern_common_syntaxContext() {}

func NewRow_pattern_common_syntaxContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_common_syntaxContext {
	var p = new(Row_pattern_common_syntaxContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_common_syntax

	return p
}

func (s *Row_pattern_common_syntaxContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_common_syntaxContext) PATTERN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPATTERN, 0)
}

func (s *Row_pattern_common_syntaxContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Row_pattern_common_syntaxContext) Row_pattern() IRow_patternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_patternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_patternContext)
}

func (s *Row_pattern_common_syntaxContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Row_pattern_common_syntaxContext) DEFINE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDEFINE, 0)
}

func (s *Row_pattern_common_syntaxContext) Row_pattern_definition_list() IRow_pattern_definition_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_definition_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_definition_listContext)
}

func (s *Row_pattern_common_syntaxContext) AFTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAFTER, 0)
}

func (s *Row_pattern_common_syntaxContext) MATCH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMATCH, 0)
}

func (s *Row_pattern_common_syntaxContext) Row_pattern_skip_to() IRow_pattern_skip_toContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_skip_toContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_skip_toContext)
}

func (s *Row_pattern_common_syntaxContext) Row_pattern_initial_or_seek() IRow_pattern_initial_or_seekContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_initial_or_seekContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_initial_or_seekContext)
}

func (s *Row_pattern_common_syntaxContext) Row_pattern_subset_clause() IRow_pattern_subset_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_subset_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_subset_clauseContext)
}

func (s *Row_pattern_common_syntaxContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_common_syntaxContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_pattern_common_syntaxContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRow_pattern_common_syntax(s)
	}
}

func (s *Row_pattern_common_syntaxContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRow_pattern_common_syntax(s)
	}
}

func (p *SQLv1Antlr4Parser) Row_pattern_common_syntax() (localctx IRow_pattern_common_syntaxContext) {
	localctx = NewRow_pattern_common_syntaxContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, SQLv1Antlr4ParserRULE_row_pattern_common_syntax)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2223)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserAFTER {
		{
			p.SetState(2220)
			p.Match(SQLv1Antlr4ParserAFTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2221)
			p.Match(SQLv1Antlr4ParserMATCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2222)
			p.Row_pattern_skip_to()
		}

	}
	p.SetState(2226)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserINITIAL || _la == SQLv1Antlr4ParserSEEK {
		{
			p.SetState(2225)
			p.Row_pattern_initial_or_seek()
		}

	}
	{
		p.SetState(2228)
		p.Match(SQLv1Antlr4ParserPATTERN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2229)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2230)
		p.Row_pattern()
	}
	{
		p.SetState(2231)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2233)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserSUBSET {
		{
			p.SetState(2232)
			p.Row_pattern_subset_clause()
		}

	}
	{
		p.SetState(2235)
		p.Match(SQLv1Antlr4ParserDEFINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2236)
		p.Row_pattern_definition_list()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_pattern_skip_toContext is an interface to support dynamic dispatch.
type IRow_pattern_skip_toContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TSKIP() antlr.TerminalNode
	TO() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	ROW() antlr.TerminalNode
	PAST() antlr.TerminalNode
	LAST() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	Row_pattern_skip_to_variable_name() IRow_pattern_skip_to_variable_nameContext

	// IsRow_pattern_skip_toContext differentiates from other interfaces.
	IsRow_pattern_skip_toContext()
}

type Row_pattern_skip_toContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_skip_toContext() *Row_pattern_skip_toContext {
	var p = new(Row_pattern_skip_toContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_skip_to
	return p
}

func InitEmptyRow_pattern_skip_toContext(p *Row_pattern_skip_toContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_skip_to
}

func (*Row_pattern_skip_toContext) IsRow_pattern_skip_toContext() {}

func NewRow_pattern_skip_toContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_skip_toContext {
	var p = new(Row_pattern_skip_toContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_skip_to

	return p
}

func (s *Row_pattern_skip_toContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_skip_toContext) TSKIP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTSKIP, 0)
}

func (s *Row_pattern_skip_toContext) TO() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTO, 0)
}

func (s *Row_pattern_skip_toContext) NEXT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNEXT, 0)
}

func (s *Row_pattern_skip_toContext) ROW() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserROW, 0)
}

func (s *Row_pattern_skip_toContext) PAST() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPAST, 0)
}

func (s *Row_pattern_skip_toContext) LAST() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLAST, 0)
}

func (s *Row_pattern_skip_toContext) FIRST() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFIRST, 0)
}

func (s *Row_pattern_skip_toContext) Row_pattern_skip_to_variable_name() IRow_pattern_skip_to_variable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_skip_to_variable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_skip_to_variable_nameContext)
}

func (s *Row_pattern_skip_toContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_skip_toContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_pattern_skip_toContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRow_pattern_skip_to(s)
	}
}

func (s *Row_pattern_skip_toContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRow_pattern_skip_to(s)
	}
}

func (p *SQLv1Antlr4Parser) Row_pattern_skip_to() (localctx IRow_pattern_skip_toContext) {
	localctx = NewRow_pattern_skip_toContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, SQLv1Antlr4ParserRULE_row_pattern_skip_to)
	p.SetState(2257)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 200, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2238)
			p.Match(SQLv1Antlr4ParserTSKIP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2239)
			p.Match(SQLv1Antlr4ParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2240)
			p.Match(SQLv1Antlr4ParserNEXT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2241)
			p.Match(SQLv1Antlr4ParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2242)
			p.Match(SQLv1Antlr4ParserTSKIP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2243)
			p.Match(SQLv1Antlr4ParserPAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2244)
			p.Match(SQLv1Antlr4ParserLAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2245)
			p.Match(SQLv1Antlr4ParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2246)
			p.Match(SQLv1Antlr4ParserTSKIP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2247)
			p.Match(SQLv1Antlr4ParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2248)
			p.Match(SQLv1Antlr4ParserFIRST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2249)
			p.Row_pattern_skip_to_variable_name()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2250)
			p.Match(SQLv1Antlr4ParserTSKIP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2251)
			p.Match(SQLv1Antlr4ParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2252)
			p.Match(SQLv1Antlr4ParserLAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2253)
			p.Row_pattern_skip_to_variable_name()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2254)
			p.Match(SQLv1Antlr4ParserTSKIP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2255)
			p.Match(SQLv1Antlr4ParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2256)
			p.Row_pattern_skip_to_variable_name()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_pattern_skip_to_variable_nameContext is an interface to support dynamic dispatch.
type IRow_pattern_skip_to_variable_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Row_pattern_variable_name() IRow_pattern_variable_nameContext

	// IsRow_pattern_skip_to_variable_nameContext differentiates from other interfaces.
	IsRow_pattern_skip_to_variable_nameContext()
}

type Row_pattern_skip_to_variable_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_skip_to_variable_nameContext() *Row_pattern_skip_to_variable_nameContext {
	var p = new(Row_pattern_skip_to_variable_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_skip_to_variable_name
	return p
}

func InitEmptyRow_pattern_skip_to_variable_nameContext(p *Row_pattern_skip_to_variable_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_skip_to_variable_name
}

func (*Row_pattern_skip_to_variable_nameContext) IsRow_pattern_skip_to_variable_nameContext() {}

func NewRow_pattern_skip_to_variable_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_skip_to_variable_nameContext {
	var p = new(Row_pattern_skip_to_variable_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_skip_to_variable_name

	return p
}

func (s *Row_pattern_skip_to_variable_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_skip_to_variable_nameContext) Row_pattern_variable_name() IRow_pattern_variable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_variable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_variable_nameContext)
}

func (s *Row_pattern_skip_to_variable_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_skip_to_variable_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_pattern_skip_to_variable_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRow_pattern_skip_to_variable_name(s)
	}
}

func (s *Row_pattern_skip_to_variable_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRow_pattern_skip_to_variable_name(s)
	}
}

func (p *SQLv1Antlr4Parser) Row_pattern_skip_to_variable_name() (localctx IRow_pattern_skip_to_variable_nameContext) {
	localctx = NewRow_pattern_skip_to_variable_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, SQLv1Antlr4ParserRULE_row_pattern_skip_to_variable_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2259)
		p.Row_pattern_variable_name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_pattern_initial_or_seekContext is an interface to support dynamic dispatch.
type IRow_pattern_initial_or_seekContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INITIAL() antlr.TerminalNode
	SEEK() antlr.TerminalNode

	// IsRow_pattern_initial_or_seekContext differentiates from other interfaces.
	IsRow_pattern_initial_or_seekContext()
}

type Row_pattern_initial_or_seekContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_initial_or_seekContext() *Row_pattern_initial_or_seekContext {
	var p = new(Row_pattern_initial_or_seekContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_initial_or_seek
	return p
}

func InitEmptyRow_pattern_initial_or_seekContext(p *Row_pattern_initial_or_seekContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_initial_or_seek
}

func (*Row_pattern_initial_or_seekContext) IsRow_pattern_initial_or_seekContext() {}

func NewRow_pattern_initial_or_seekContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_initial_or_seekContext {
	var p = new(Row_pattern_initial_or_seekContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_initial_or_seek

	return p
}

func (s *Row_pattern_initial_or_seekContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_initial_or_seekContext) INITIAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINITIAL, 0)
}

func (s *Row_pattern_initial_or_seekContext) SEEK() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSEEK, 0)
}

func (s *Row_pattern_initial_or_seekContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_initial_or_seekContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_pattern_initial_or_seekContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRow_pattern_initial_or_seek(s)
	}
}

func (s *Row_pattern_initial_or_seekContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRow_pattern_initial_or_seek(s)
	}
}

func (p *SQLv1Antlr4Parser) Row_pattern_initial_or_seek() (localctx IRow_pattern_initial_or_seekContext) {
	localctx = NewRow_pattern_initial_or_seekContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, SQLv1Antlr4ParserRULE_row_pattern_initial_or_seek)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2261)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLv1Antlr4ParserINITIAL || _la == SQLv1Antlr4ParserSEEK) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_patternContext is an interface to support dynamic dispatch.
type IRow_patternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRow_pattern_term() []IRow_pattern_termContext
	Row_pattern_term(i int) IRow_pattern_termContext
	AllPIPE() []antlr.TerminalNode
	PIPE(i int) antlr.TerminalNode

	// IsRow_patternContext differentiates from other interfaces.
	IsRow_patternContext()
}

type Row_patternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_patternContext() *Row_patternContext {
	var p = new(Row_patternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern
	return p
}

func InitEmptyRow_patternContext(p *Row_patternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern
}

func (*Row_patternContext) IsRow_patternContext() {}

func NewRow_patternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_patternContext {
	var p = new(Row_patternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern

	return p
}

func (s *Row_patternContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_patternContext) AllRow_pattern_term() []IRow_pattern_termContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRow_pattern_termContext); ok {
			len++
		}
	}

	tst := make([]IRow_pattern_termContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRow_pattern_termContext); ok {
			tst[i] = t.(IRow_pattern_termContext)
			i++
		}
	}

	return tst
}

func (s *Row_patternContext) Row_pattern_term(i int) IRow_pattern_termContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_termContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_termContext)
}

func (s *Row_patternContext) AllPIPE() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserPIPE)
}

func (s *Row_patternContext) PIPE(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPIPE, i)
}

func (s *Row_patternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_patternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_patternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRow_pattern(s)
	}
}

func (s *Row_patternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRow_pattern(s)
	}
}

func (p *SQLv1Antlr4Parser) Row_pattern() (localctx IRow_patternContext) {
	localctx = NewRow_patternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, SQLv1Antlr4ParserRULE_row_pattern)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2263)
		p.Row_pattern_term()
	}
	p.SetState(2268)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserPIPE {
		{
			p.SetState(2264)
			p.Match(SQLv1Antlr4ParserPIPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2265)
			p.Row_pattern_term()
		}

		p.SetState(2270)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_pattern_termContext is an interface to support dynamic dispatch.
type IRow_pattern_termContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRow_pattern_factor() []IRow_pattern_factorContext
	Row_pattern_factor(i int) IRow_pattern_factorContext

	// IsRow_pattern_termContext differentiates from other interfaces.
	IsRow_pattern_termContext()
}

type Row_pattern_termContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_termContext() *Row_pattern_termContext {
	var p = new(Row_pattern_termContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_term
	return p
}

func InitEmptyRow_pattern_termContext(p *Row_pattern_termContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_term
}

func (*Row_pattern_termContext) IsRow_pattern_termContext() {}

func NewRow_pattern_termContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_termContext {
	var p = new(Row_pattern_termContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_term

	return p
}

func (s *Row_pattern_termContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_termContext) AllRow_pattern_factor() []IRow_pattern_factorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRow_pattern_factorContext); ok {
			len++
		}
	}

	tst := make([]IRow_pattern_factorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRow_pattern_factorContext); ok {
			tst[i] = t.(IRow_pattern_factorContext)
			i++
		}
	}

	return tst
}

func (s *Row_pattern_termContext) Row_pattern_factor(i int) IRow_pattern_factorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_factorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_factorContext)
}

func (s *Row_pattern_termContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_termContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_pattern_termContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRow_pattern_term(s)
	}
}

func (s *Row_pattern_termContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRow_pattern_term(s)
	}
}

func (p *SQLv1Antlr4Parser) Row_pattern_term() (localctx IRow_pattern_termContext) {
	localctx = NewRow_pattern_termContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, SQLv1Antlr4ParserRULE_row_pattern_term)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2272)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&347959459840) != 0) || _la == SQLv1Antlr4ParserPERMUTE || _la == SQLv1Antlr4ParserID_PLAIN || _la == SQLv1Antlr4ParserID_QUOTED {
		{
			p.SetState(2271)
			p.Row_pattern_factor()
		}

		p.SetState(2274)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_pattern_factorContext is an interface to support dynamic dispatch.
type IRow_pattern_factorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Row_pattern_primary() IRow_pattern_primaryContext
	Row_pattern_quantifier() IRow_pattern_quantifierContext

	// IsRow_pattern_factorContext differentiates from other interfaces.
	IsRow_pattern_factorContext()
}

type Row_pattern_factorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_factorContext() *Row_pattern_factorContext {
	var p = new(Row_pattern_factorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_factor
	return p
}

func InitEmptyRow_pattern_factorContext(p *Row_pattern_factorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_factor
}

func (*Row_pattern_factorContext) IsRow_pattern_factorContext() {}

func NewRow_pattern_factorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_factorContext {
	var p = new(Row_pattern_factorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_factor

	return p
}

func (s *Row_pattern_factorContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_factorContext) Row_pattern_primary() IRow_pattern_primaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_primaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_primaryContext)
}

func (s *Row_pattern_factorContext) Row_pattern_quantifier() IRow_pattern_quantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_quantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_quantifierContext)
}

func (s *Row_pattern_factorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_factorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_pattern_factorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRow_pattern_factor(s)
	}
}

func (s *Row_pattern_factorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRow_pattern_factor(s)
	}
}

func (p *SQLv1Antlr4Parser) Row_pattern_factor() (localctx IRow_pattern_factorContext) {
	localctx = NewRow_pattern_factorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, SQLv1Antlr4ParserRULE_row_pattern_factor)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2276)
		p.Row_pattern_primary()
	}
	p.SetState(2278)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 203, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2277)
			p.Row_pattern_quantifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_pattern_quantifierContext is an interface to support dynamic dispatch.
type IRow_pattern_quantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASTERISK() antlr.TerminalNode
	AllQUESTION() []antlr.TerminalNode
	QUESTION(i int) antlr.TerminalNode
	PLUS() antlr.TerminalNode
	LBRACE_CURLY() antlr.TerminalNode
	COMMA() antlr.TerminalNode
	RBRACE_CURLY() antlr.TerminalNode
	AllInteger() []IIntegerContext
	Integer(i int) IIntegerContext

	// IsRow_pattern_quantifierContext differentiates from other interfaces.
	IsRow_pattern_quantifierContext()
}

type Row_pattern_quantifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_quantifierContext() *Row_pattern_quantifierContext {
	var p = new(Row_pattern_quantifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_quantifier
	return p
}

func InitEmptyRow_pattern_quantifierContext(p *Row_pattern_quantifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_quantifier
}

func (*Row_pattern_quantifierContext) IsRow_pattern_quantifierContext() {}

func NewRow_pattern_quantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_quantifierContext {
	var p = new(Row_pattern_quantifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_quantifier

	return p
}

func (s *Row_pattern_quantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_quantifierContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserASTERISK, 0)
}

func (s *Row_pattern_quantifierContext) AllQUESTION() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserQUESTION)
}

func (s *Row_pattern_quantifierContext) QUESTION(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserQUESTION, i)
}

func (s *Row_pattern_quantifierContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPLUS, 0)
}

func (s *Row_pattern_quantifierContext) LBRACE_CURLY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLBRACE_CURLY, 0)
}

func (s *Row_pattern_quantifierContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, 0)
}

func (s *Row_pattern_quantifierContext) RBRACE_CURLY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRBRACE_CURLY, 0)
}

func (s *Row_pattern_quantifierContext) AllInteger() []IIntegerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIntegerContext); ok {
			len++
		}
	}

	tst := make([]IIntegerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIntegerContext); ok {
			tst[i] = t.(IIntegerContext)
			i++
		}
	}

	return tst
}

func (s *Row_pattern_quantifierContext) Integer(i int) IIntegerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerContext)
}

func (s *Row_pattern_quantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_quantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_pattern_quantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRow_pattern_quantifier(s)
	}
}

func (s *Row_pattern_quantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRow_pattern_quantifier(s)
	}
}

func (p *SQLv1Antlr4Parser) Row_pattern_quantifier() (localctx IRow_pattern_quantifierContext) {
	localctx = NewRow_pattern_quantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, SQLv1Antlr4ParserRULE_row_pattern_quantifier)
	var _la int

	p.SetState(2308)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 210, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2280)
			p.Match(SQLv1Antlr4ParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2282)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserQUESTION {
			{
				p.SetState(2281)
				p.Match(SQLv1Antlr4ParserQUESTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2284)
			p.Match(SQLv1Antlr4ParserPLUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2286)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserQUESTION {
			{
				p.SetState(2285)
				p.Match(SQLv1Antlr4ParserQUESTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2288)
			p.Match(SQLv1Antlr4ParserQUESTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2290)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserQUESTION {
			{
				p.SetState(2289)
				p.Match(SQLv1Antlr4ParserQUESTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2292)
			p.Match(SQLv1Antlr4ParserLBRACE_CURLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2294)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserDIGITS || _la == SQLv1Antlr4ParserINTEGER_VALUE {
			{
				p.SetState(2293)
				p.Integer()
			}

		}
		{
			p.SetState(2296)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2298)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserDIGITS || _la == SQLv1Antlr4ParserINTEGER_VALUE {
			{
				p.SetState(2297)
				p.Integer()
			}

		}
		{
			p.SetState(2300)
			p.Match(SQLv1Antlr4ParserRBRACE_CURLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2302)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserQUESTION {
			{
				p.SetState(2301)
				p.Match(SQLv1Antlr4ParserQUESTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2304)
			p.Match(SQLv1Antlr4ParserLBRACE_CURLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2305)
			p.Integer()
		}
		{
			p.SetState(2306)
			p.Match(SQLv1Antlr4ParserRBRACE_CURLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_pattern_primaryContext is an interface to support dynamic dispatch.
type IRow_pattern_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Row_pattern_primary_variable_name() IRow_pattern_primary_variable_nameContext
	DOLLAR() antlr.TerminalNode
	CARET() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Row_pattern() IRow_patternContext
	LBRACE_CURLY() antlr.TerminalNode
	AllMINUS() []antlr.TerminalNode
	MINUS(i int) antlr.TerminalNode
	RBRACE_CURLY() antlr.TerminalNode
	Row_pattern_permute() IRow_pattern_permuteContext

	// IsRow_pattern_primaryContext differentiates from other interfaces.
	IsRow_pattern_primaryContext()
}

type Row_pattern_primaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_primaryContext() *Row_pattern_primaryContext {
	var p = new(Row_pattern_primaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_primary
	return p
}

func InitEmptyRow_pattern_primaryContext(p *Row_pattern_primaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_primary
}

func (*Row_pattern_primaryContext) IsRow_pattern_primaryContext() {}

func NewRow_pattern_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_primaryContext {
	var p = new(Row_pattern_primaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_primary

	return p
}

func (s *Row_pattern_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_primaryContext) Row_pattern_primary_variable_name() IRow_pattern_primary_variable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_primary_variable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_primary_variable_nameContext)
}

func (s *Row_pattern_primaryContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDOLLAR, 0)
}

func (s *Row_pattern_primaryContext) CARET() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCARET, 0)
}

func (s *Row_pattern_primaryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Row_pattern_primaryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Row_pattern_primaryContext) Row_pattern() IRow_patternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_patternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_patternContext)
}

func (s *Row_pattern_primaryContext) LBRACE_CURLY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLBRACE_CURLY, 0)
}

func (s *Row_pattern_primaryContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserMINUS)
}

func (s *Row_pattern_primaryContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMINUS, i)
}

func (s *Row_pattern_primaryContext) RBRACE_CURLY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRBRACE_CURLY, 0)
}

func (s *Row_pattern_primaryContext) Row_pattern_permute() IRow_pattern_permuteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_permuteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_permuteContext)
}

func (s *Row_pattern_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_pattern_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRow_pattern_primary(s)
	}
}

func (s *Row_pattern_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRow_pattern_primary(s)
	}
}

func (p *SQLv1Antlr4Parser) Row_pattern_primary() (localctx IRow_pattern_primaryContext) {
	localctx = NewRow_pattern_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, SQLv1Antlr4ParserRULE_row_pattern_primary)
	var _la int

	p.SetState(2325)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2310)
			p.Row_pattern_primary_variable_name()
		}

	case SQLv1Antlr4ParserDOLLAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2311)
			p.Match(SQLv1Antlr4ParserDOLLAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserCARET:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2312)
			p.Match(SQLv1Antlr4ParserCARET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserLPAREN:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2313)
			p.Match(SQLv1Antlr4ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2315)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&347959459840) != 0) || _la == SQLv1Antlr4ParserPERMUTE || _la == SQLv1Antlr4ParserID_PLAIN || _la == SQLv1Antlr4ParserID_QUOTED {
			{
				p.SetState(2314)
				p.Row_pattern()
			}

		}
		{
			p.SetState(2317)
			p.Match(SQLv1Antlr4ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserLBRACE_CURLY:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2318)
			p.Match(SQLv1Antlr4ParserLBRACE_CURLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2319)
			p.Match(SQLv1Antlr4ParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2320)
			p.Row_pattern()
		}
		{
			p.SetState(2321)
			p.Match(SQLv1Antlr4ParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2322)
			p.Match(SQLv1Antlr4ParserRBRACE_CURLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserPERMUTE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2324)
			p.Row_pattern_permute()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_pattern_primary_variable_nameContext is an interface to support dynamic dispatch.
type IRow_pattern_primary_variable_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Row_pattern_variable_name() IRow_pattern_variable_nameContext

	// IsRow_pattern_primary_variable_nameContext differentiates from other interfaces.
	IsRow_pattern_primary_variable_nameContext()
}

type Row_pattern_primary_variable_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_primary_variable_nameContext() *Row_pattern_primary_variable_nameContext {
	var p = new(Row_pattern_primary_variable_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_primary_variable_name
	return p
}

func InitEmptyRow_pattern_primary_variable_nameContext(p *Row_pattern_primary_variable_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_primary_variable_name
}

func (*Row_pattern_primary_variable_nameContext) IsRow_pattern_primary_variable_nameContext() {}

func NewRow_pattern_primary_variable_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_primary_variable_nameContext {
	var p = new(Row_pattern_primary_variable_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_primary_variable_name

	return p
}

func (s *Row_pattern_primary_variable_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_primary_variable_nameContext) Row_pattern_variable_name() IRow_pattern_variable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_variable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_variable_nameContext)
}

func (s *Row_pattern_primary_variable_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_primary_variable_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_pattern_primary_variable_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRow_pattern_primary_variable_name(s)
	}
}

func (s *Row_pattern_primary_variable_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRow_pattern_primary_variable_name(s)
	}
}

func (p *SQLv1Antlr4Parser) Row_pattern_primary_variable_name() (localctx IRow_pattern_primary_variable_nameContext) {
	localctx = NewRow_pattern_primary_variable_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, SQLv1Antlr4ParserRULE_row_pattern_primary_variable_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2327)
		p.Row_pattern_variable_name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_pattern_permuteContext is an interface to support dynamic dispatch.
type IRow_pattern_permuteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PERMUTE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllRow_pattern() []IRow_patternContext
	Row_pattern(i int) IRow_patternContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRow_pattern_permuteContext differentiates from other interfaces.
	IsRow_pattern_permuteContext()
}

type Row_pattern_permuteContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_permuteContext() *Row_pattern_permuteContext {
	var p = new(Row_pattern_permuteContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_permute
	return p
}

func InitEmptyRow_pattern_permuteContext(p *Row_pattern_permuteContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_permute
}

func (*Row_pattern_permuteContext) IsRow_pattern_permuteContext() {}

func NewRow_pattern_permuteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_permuteContext {
	var p = new(Row_pattern_permuteContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_permute

	return p
}

func (s *Row_pattern_permuteContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_permuteContext) PERMUTE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPERMUTE, 0)
}

func (s *Row_pattern_permuteContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Row_pattern_permuteContext) AllRow_pattern() []IRow_patternContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRow_patternContext); ok {
			len++
		}
	}

	tst := make([]IRow_patternContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRow_patternContext); ok {
			tst[i] = t.(IRow_patternContext)
			i++
		}
	}

	return tst
}

func (s *Row_pattern_permuteContext) Row_pattern(i int) IRow_patternContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_patternContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_patternContext)
}

func (s *Row_pattern_permuteContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Row_pattern_permuteContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Row_pattern_permuteContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Row_pattern_permuteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_permuteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_pattern_permuteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRow_pattern_permute(s)
	}
}

func (s *Row_pattern_permuteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRow_pattern_permute(s)
	}
}

func (p *SQLv1Antlr4Parser) Row_pattern_permute() (localctx IRow_pattern_permuteContext) {
	localctx = NewRow_pattern_permuteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, SQLv1Antlr4ParserRULE_row_pattern_permute)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2329)
		p.Match(SQLv1Antlr4ParserPERMUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2330)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2331)
		p.Row_pattern()
	}
	p.SetState(2336)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(2332)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2333)
			p.Row_pattern()
		}

		p.SetState(2338)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2339)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_pattern_subset_clauseContext is an interface to support dynamic dispatch.
type IRow_pattern_subset_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUBSET() antlr.TerminalNode
	Row_pattern_subset_list() IRow_pattern_subset_listContext

	// IsRow_pattern_subset_clauseContext differentiates from other interfaces.
	IsRow_pattern_subset_clauseContext()
}

type Row_pattern_subset_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_subset_clauseContext() *Row_pattern_subset_clauseContext {
	var p = new(Row_pattern_subset_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_subset_clause
	return p
}

func InitEmptyRow_pattern_subset_clauseContext(p *Row_pattern_subset_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_subset_clause
}

func (*Row_pattern_subset_clauseContext) IsRow_pattern_subset_clauseContext() {}

func NewRow_pattern_subset_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_subset_clauseContext {
	var p = new(Row_pattern_subset_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_subset_clause

	return p
}

func (s *Row_pattern_subset_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_subset_clauseContext) SUBSET() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSUBSET, 0)
}

func (s *Row_pattern_subset_clauseContext) Row_pattern_subset_list() IRow_pattern_subset_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_subset_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_subset_listContext)
}

func (s *Row_pattern_subset_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_subset_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_pattern_subset_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRow_pattern_subset_clause(s)
	}
}

func (s *Row_pattern_subset_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRow_pattern_subset_clause(s)
	}
}

func (p *SQLv1Antlr4Parser) Row_pattern_subset_clause() (localctx IRow_pattern_subset_clauseContext) {
	localctx = NewRow_pattern_subset_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, SQLv1Antlr4ParserRULE_row_pattern_subset_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2341)
		p.Match(SQLv1Antlr4ParserSUBSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2342)
		p.Row_pattern_subset_list()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_pattern_subset_listContext is an interface to support dynamic dispatch.
type IRow_pattern_subset_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRow_pattern_subset_item() []IRow_pattern_subset_itemContext
	Row_pattern_subset_item(i int) IRow_pattern_subset_itemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRow_pattern_subset_listContext differentiates from other interfaces.
	IsRow_pattern_subset_listContext()
}

type Row_pattern_subset_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_subset_listContext() *Row_pattern_subset_listContext {
	var p = new(Row_pattern_subset_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_subset_list
	return p
}

func InitEmptyRow_pattern_subset_listContext(p *Row_pattern_subset_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_subset_list
}

func (*Row_pattern_subset_listContext) IsRow_pattern_subset_listContext() {}

func NewRow_pattern_subset_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_subset_listContext {
	var p = new(Row_pattern_subset_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_subset_list

	return p
}

func (s *Row_pattern_subset_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_subset_listContext) AllRow_pattern_subset_item() []IRow_pattern_subset_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRow_pattern_subset_itemContext); ok {
			len++
		}
	}

	tst := make([]IRow_pattern_subset_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRow_pattern_subset_itemContext); ok {
			tst[i] = t.(IRow_pattern_subset_itemContext)
			i++
		}
	}

	return tst
}

func (s *Row_pattern_subset_listContext) Row_pattern_subset_item(i int) IRow_pattern_subset_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_subset_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_subset_itemContext)
}

func (s *Row_pattern_subset_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Row_pattern_subset_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Row_pattern_subset_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_subset_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_pattern_subset_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRow_pattern_subset_list(s)
	}
}

func (s *Row_pattern_subset_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRow_pattern_subset_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Row_pattern_subset_list() (localctx IRow_pattern_subset_listContext) {
	localctx = NewRow_pattern_subset_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, SQLv1Antlr4ParserRULE_row_pattern_subset_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2344)
		p.Row_pattern_subset_item()
	}
	p.SetState(2349)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(2345)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2346)
			p.Row_pattern_subset_item()
		}

		p.SetState(2351)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_pattern_subset_itemContext is an interface to support dynamic dispatch.
type IRow_pattern_subset_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Row_pattern_subset_item_variable_name() IRow_pattern_subset_item_variable_nameContext
	EQUALS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Row_pattern_subset_rhs() IRow_pattern_subset_rhsContext
	RPAREN() antlr.TerminalNode

	// IsRow_pattern_subset_itemContext differentiates from other interfaces.
	IsRow_pattern_subset_itemContext()
}

type Row_pattern_subset_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_subset_itemContext() *Row_pattern_subset_itemContext {
	var p = new(Row_pattern_subset_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_subset_item
	return p
}

func InitEmptyRow_pattern_subset_itemContext(p *Row_pattern_subset_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_subset_item
}

func (*Row_pattern_subset_itemContext) IsRow_pattern_subset_itemContext() {}

func NewRow_pattern_subset_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_subset_itemContext {
	var p = new(Row_pattern_subset_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_subset_item

	return p
}

func (s *Row_pattern_subset_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_subset_itemContext) Row_pattern_subset_item_variable_name() IRow_pattern_subset_item_variable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_subset_item_variable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_subset_item_variable_nameContext)
}

func (s *Row_pattern_subset_itemContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEQUALS, 0)
}

func (s *Row_pattern_subset_itemContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Row_pattern_subset_itemContext) Row_pattern_subset_rhs() IRow_pattern_subset_rhsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_subset_rhsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_subset_rhsContext)
}

func (s *Row_pattern_subset_itemContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Row_pattern_subset_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_subset_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_pattern_subset_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRow_pattern_subset_item(s)
	}
}

func (s *Row_pattern_subset_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRow_pattern_subset_item(s)
	}
}

func (p *SQLv1Antlr4Parser) Row_pattern_subset_item() (localctx IRow_pattern_subset_itemContext) {
	localctx = NewRow_pattern_subset_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, SQLv1Antlr4ParserRULE_row_pattern_subset_item)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2352)
		p.Row_pattern_subset_item_variable_name()
	}
	{
		p.SetState(2353)
		p.Match(SQLv1Antlr4ParserEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2354)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2355)
		p.Row_pattern_subset_rhs()
	}
	{
		p.SetState(2356)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_pattern_subset_item_variable_nameContext is an interface to support dynamic dispatch.
type IRow_pattern_subset_item_variable_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Row_pattern_variable_name() IRow_pattern_variable_nameContext

	// IsRow_pattern_subset_item_variable_nameContext differentiates from other interfaces.
	IsRow_pattern_subset_item_variable_nameContext()
}

type Row_pattern_subset_item_variable_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_subset_item_variable_nameContext() *Row_pattern_subset_item_variable_nameContext {
	var p = new(Row_pattern_subset_item_variable_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_subset_item_variable_name
	return p
}

func InitEmptyRow_pattern_subset_item_variable_nameContext(p *Row_pattern_subset_item_variable_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_subset_item_variable_name
}

func (*Row_pattern_subset_item_variable_nameContext) IsRow_pattern_subset_item_variable_nameContext() {
}

func NewRow_pattern_subset_item_variable_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_subset_item_variable_nameContext {
	var p = new(Row_pattern_subset_item_variable_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_subset_item_variable_name

	return p
}

func (s *Row_pattern_subset_item_variable_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_subset_item_variable_nameContext) Row_pattern_variable_name() IRow_pattern_variable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_variable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_variable_nameContext)
}

func (s *Row_pattern_subset_item_variable_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_subset_item_variable_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_pattern_subset_item_variable_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRow_pattern_subset_item_variable_name(s)
	}
}

func (s *Row_pattern_subset_item_variable_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRow_pattern_subset_item_variable_name(s)
	}
}

func (p *SQLv1Antlr4Parser) Row_pattern_subset_item_variable_name() (localctx IRow_pattern_subset_item_variable_nameContext) {
	localctx = NewRow_pattern_subset_item_variable_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, SQLv1Antlr4ParserRULE_row_pattern_subset_item_variable_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2358)
		p.Row_pattern_variable_name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_pattern_subset_rhsContext is an interface to support dynamic dispatch.
type IRow_pattern_subset_rhsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRow_pattern_subset_rhs_variable_name() []IRow_pattern_subset_rhs_variable_nameContext
	Row_pattern_subset_rhs_variable_name(i int) IRow_pattern_subset_rhs_variable_nameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRow_pattern_subset_rhsContext differentiates from other interfaces.
	IsRow_pattern_subset_rhsContext()
}

type Row_pattern_subset_rhsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_subset_rhsContext() *Row_pattern_subset_rhsContext {
	var p = new(Row_pattern_subset_rhsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_subset_rhs
	return p
}

func InitEmptyRow_pattern_subset_rhsContext(p *Row_pattern_subset_rhsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_subset_rhs
}

func (*Row_pattern_subset_rhsContext) IsRow_pattern_subset_rhsContext() {}

func NewRow_pattern_subset_rhsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_subset_rhsContext {
	var p = new(Row_pattern_subset_rhsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_subset_rhs

	return p
}

func (s *Row_pattern_subset_rhsContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_subset_rhsContext) AllRow_pattern_subset_rhs_variable_name() []IRow_pattern_subset_rhs_variable_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRow_pattern_subset_rhs_variable_nameContext); ok {
			len++
		}
	}

	tst := make([]IRow_pattern_subset_rhs_variable_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRow_pattern_subset_rhs_variable_nameContext); ok {
			tst[i] = t.(IRow_pattern_subset_rhs_variable_nameContext)
			i++
		}
	}

	return tst
}

func (s *Row_pattern_subset_rhsContext) Row_pattern_subset_rhs_variable_name(i int) IRow_pattern_subset_rhs_variable_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_subset_rhs_variable_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_subset_rhs_variable_nameContext)
}

func (s *Row_pattern_subset_rhsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Row_pattern_subset_rhsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Row_pattern_subset_rhsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_subset_rhsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_pattern_subset_rhsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRow_pattern_subset_rhs(s)
	}
}

func (s *Row_pattern_subset_rhsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRow_pattern_subset_rhs(s)
	}
}

func (p *SQLv1Antlr4Parser) Row_pattern_subset_rhs() (localctx IRow_pattern_subset_rhsContext) {
	localctx = NewRow_pattern_subset_rhsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, SQLv1Antlr4ParserRULE_row_pattern_subset_rhs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2360)
		p.Row_pattern_subset_rhs_variable_name()
	}
	p.SetState(2365)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(2361)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2362)
			p.Row_pattern_subset_rhs_variable_name()
		}

		p.SetState(2367)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_pattern_subset_rhs_variable_nameContext is an interface to support dynamic dispatch.
type IRow_pattern_subset_rhs_variable_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Row_pattern_variable_name() IRow_pattern_variable_nameContext

	// IsRow_pattern_subset_rhs_variable_nameContext differentiates from other interfaces.
	IsRow_pattern_subset_rhs_variable_nameContext()
}

type Row_pattern_subset_rhs_variable_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_subset_rhs_variable_nameContext() *Row_pattern_subset_rhs_variable_nameContext {
	var p = new(Row_pattern_subset_rhs_variable_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_subset_rhs_variable_name
	return p
}

func InitEmptyRow_pattern_subset_rhs_variable_nameContext(p *Row_pattern_subset_rhs_variable_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_subset_rhs_variable_name
}

func (*Row_pattern_subset_rhs_variable_nameContext) IsRow_pattern_subset_rhs_variable_nameContext() {}

func NewRow_pattern_subset_rhs_variable_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_subset_rhs_variable_nameContext {
	var p = new(Row_pattern_subset_rhs_variable_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_subset_rhs_variable_name

	return p
}

func (s *Row_pattern_subset_rhs_variable_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_subset_rhs_variable_nameContext) Row_pattern_variable_name() IRow_pattern_variable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_variable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_variable_nameContext)
}

func (s *Row_pattern_subset_rhs_variable_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_subset_rhs_variable_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_pattern_subset_rhs_variable_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRow_pattern_subset_rhs_variable_name(s)
	}
}

func (s *Row_pattern_subset_rhs_variable_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRow_pattern_subset_rhs_variable_name(s)
	}
}

func (p *SQLv1Antlr4Parser) Row_pattern_subset_rhs_variable_name() (localctx IRow_pattern_subset_rhs_variable_nameContext) {
	localctx = NewRow_pattern_subset_rhs_variable_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, SQLv1Antlr4ParserRULE_row_pattern_subset_rhs_variable_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2368)
		p.Row_pattern_variable_name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_pattern_definition_listContext is an interface to support dynamic dispatch.
type IRow_pattern_definition_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRow_pattern_definition() []IRow_pattern_definitionContext
	Row_pattern_definition(i int) IRow_pattern_definitionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRow_pattern_definition_listContext differentiates from other interfaces.
	IsRow_pattern_definition_listContext()
}

type Row_pattern_definition_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_definition_listContext() *Row_pattern_definition_listContext {
	var p = new(Row_pattern_definition_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_definition_list
	return p
}

func InitEmptyRow_pattern_definition_listContext(p *Row_pattern_definition_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_definition_list
}

func (*Row_pattern_definition_listContext) IsRow_pattern_definition_listContext() {}

func NewRow_pattern_definition_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_definition_listContext {
	var p = new(Row_pattern_definition_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_definition_list

	return p
}

func (s *Row_pattern_definition_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_definition_listContext) AllRow_pattern_definition() []IRow_pattern_definitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRow_pattern_definitionContext); ok {
			len++
		}
	}

	tst := make([]IRow_pattern_definitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRow_pattern_definitionContext); ok {
			tst[i] = t.(IRow_pattern_definitionContext)
			i++
		}
	}

	return tst
}

func (s *Row_pattern_definition_listContext) Row_pattern_definition(i int) IRow_pattern_definitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_definitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_definitionContext)
}

func (s *Row_pattern_definition_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Row_pattern_definition_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Row_pattern_definition_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_definition_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_pattern_definition_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRow_pattern_definition_list(s)
	}
}

func (s *Row_pattern_definition_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRow_pattern_definition_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Row_pattern_definition_list() (localctx IRow_pattern_definition_listContext) {
	localctx = NewRow_pattern_definition_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, SQLv1Antlr4ParserRULE_row_pattern_definition_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2370)
		p.Row_pattern_definition()
	}
	p.SetState(2375)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(2371)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2372)
			p.Row_pattern_definition()
		}

		p.SetState(2377)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_pattern_definitionContext is an interface to support dynamic dispatch.
type IRow_pattern_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Row_pattern_definition_variable_name() IRow_pattern_definition_variable_nameContext
	AS() antlr.TerminalNode
	Row_pattern_definition_search_condition() IRow_pattern_definition_search_conditionContext

	// IsRow_pattern_definitionContext differentiates from other interfaces.
	IsRow_pattern_definitionContext()
}

type Row_pattern_definitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_definitionContext() *Row_pattern_definitionContext {
	var p = new(Row_pattern_definitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_definition
	return p
}

func InitEmptyRow_pattern_definitionContext(p *Row_pattern_definitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_definition
}

func (*Row_pattern_definitionContext) IsRow_pattern_definitionContext() {}

func NewRow_pattern_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_definitionContext {
	var p = new(Row_pattern_definitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_definition

	return p
}

func (s *Row_pattern_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_definitionContext) Row_pattern_definition_variable_name() IRow_pattern_definition_variable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_definition_variable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_definition_variable_nameContext)
}

func (s *Row_pattern_definitionContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAS, 0)
}

func (s *Row_pattern_definitionContext) Row_pattern_definition_search_condition() IRow_pattern_definition_search_conditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_definition_search_conditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_definition_search_conditionContext)
}

func (s *Row_pattern_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_pattern_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRow_pattern_definition(s)
	}
}

func (s *Row_pattern_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRow_pattern_definition(s)
	}
}

func (p *SQLv1Antlr4Parser) Row_pattern_definition() (localctx IRow_pattern_definitionContext) {
	localctx = NewRow_pattern_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, SQLv1Antlr4ParserRULE_row_pattern_definition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2378)
		p.Row_pattern_definition_variable_name()
	}
	{
		p.SetState(2379)
		p.Match(SQLv1Antlr4ParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2380)
		p.Row_pattern_definition_search_condition()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_pattern_definition_variable_nameContext is an interface to support dynamic dispatch.
type IRow_pattern_definition_variable_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Row_pattern_variable_name() IRow_pattern_variable_nameContext

	// IsRow_pattern_definition_variable_nameContext differentiates from other interfaces.
	IsRow_pattern_definition_variable_nameContext()
}

type Row_pattern_definition_variable_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_definition_variable_nameContext() *Row_pattern_definition_variable_nameContext {
	var p = new(Row_pattern_definition_variable_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_definition_variable_name
	return p
}

func InitEmptyRow_pattern_definition_variable_nameContext(p *Row_pattern_definition_variable_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_definition_variable_name
}

func (*Row_pattern_definition_variable_nameContext) IsRow_pattern_definition_variable_nameContext() {}

func NewRow_pattern_definition_variable_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_definition_variable_nameContext {
	var p = new(Row_pattern_definition_variable_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_definition_variable_name

	return p
}

func (s *Row_pattern_definition_variable_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_definition_variable_nameContext) Row_pattern_variable_name() IRow_pattern_variable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_variable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_variable_nameContext)
}

func (s *Row_pattern_definition_variable_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_definition_variable_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_pattern_definition_variable_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRow_pattern_definition_variable_name(s)
	}
}

func (s *Row_pattern_definition_variable_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRow_pattern_definition_variable_name(s)
	}
}

func (p *SQLv1Antlr4Parser) Row_pattern_definition_variable_name() (localctx IRow_pattern_definition_variable_nameContext) {
	localctx = NewRow_pattern_definition_variable_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, SQLv1Antlr4ParserRULE_row_pattern_definition_variable_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2382)
		p.Row_pattern_variable_name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_pattern_definition_search_conditionContext is an interface to support dynamic dispatch.
type IRow_pattern_definition_search_conditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Search_condition() ISearch_conditionContext

	// IsRow_pattern_definition_search_conditionContext differentiates from other interfaces.
	IsRow_pattern_definition_search_conditionContext()
}

type Row_pattern_definition_search_conditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_definition_search_conditionContext() *Row_pattern_definition_search_conditionContext {
	var p = new(Row_pattern_definition_search_conditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_definition_search_condition
	return p
}

func InitEmptyRow_pattern_definition_search_conditionContext(p *Row_pattern_definition_search_conditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_definition_search_condition
}

func (*Row_pattern_definition_search_conditionContext) IsRow_pattern_definition_search_conditionContext() {
}

func NewRow_pattern_definition_search_conditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_definition_search_conditionContext {
	var p = new(Row_pattern_definition_search_conditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_definition_search_condition

	return p
}

func (s *Row_pattern_definition_search_conditionContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_definition_search_conditionContext) Search_condition() ISearch_conditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearch_conditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearch_conditionContext)
}

func (s *Row_pattern_definition_search_conditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_definition_search_conditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_pattern_definition_search_conditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRow_pattern_definition_search_condition(s)
	}
}

func (s *Row_pattern_definition_search_conditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRow_pattern_definition_search_condition(s)
	}
}

func (p *SQLv1Antlr4Parser) Row_pattern_definition_search_condition() (localctx IRow_pattern_definition_search_conditionContext) {
	localctx = NewRow_pattern_definition_search_conditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, SQLv1Antlr4ParserRULE_row_pattern_definition_search_condition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2384)
		p.Search_condition()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISearch_conditionContext is an interface to support dynamic dispatch.
type ISearch_conditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext

	// IsSearch_conditionContext differentiates from other interfaces.
	IsSearch_conditionContext()
}

type Search_conditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearch_conditionContext() *Search_conditionContext {
	var p = new(Search_conditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_search_condition
	return p
}

func InitEmptySearch_conditionContext(p *Search_conditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_search_condition
}

func (*Search_conditionContext) IsSearch_conditionContext() {}

func NewSearch_conditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Search_conditionContext {
	var p = new(Search_conditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_search_condition

	return p
}

func (s *Search_conditionContext) GetParser() antlr.Parser { return s.parser }

func (s *Search_conditionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Search_conditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Search_conditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Search_conditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSearch_condition(s)
	}
}

func (s *Search_conditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSearch_condition(s)
	}
}

func (p *SQLv1Antlr4Parser) Search_condition() (localctx ISearch_conditionContext) {
	localctx = NewSearch_conditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, SQLv1Antlr4ParserRULE_search_condition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2386)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_pattern_variable_nameContext is an interface to support dynamic dispatch.
type IRow_pattern_variable_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsRow_pattern_variable_nameContext differentiates from other interfaces.
	IsRow_pattern_variable_nameContext()
}

type Row_pattern_variable_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_pattern_variable_nameContext() *Row_pattern_variable_nameContext {
	var p = new(Row_pattern_variable_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_variable_name
	return p
}

func InitEmptyRow_pattern_variable_nameContext(p *Row_pattern_variable_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_variable_name
}

func (*Row_pattern_variable_nameContext) IsRow_pattern_variable_nameContext() {}

func NewRow_pattern_variable_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_pattern_variable_nameContext {
	var p = new(Row_pattern_variable_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_row_pattern_variable_name

	return p
}

func (s *Row_pattern_variable_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_pattern_variable_nameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Row_pattern_variable_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_pattern_variable_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_pattern_variable_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRow_pattern_variable_name(s)
	}
}

func (s *Row_pattern_variable_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRow_pattern_variable_name(s)
	}
}

func (p *SQLv1Antlr4Parser) Row_pattern_variable_name() (localctx IRow_pattern_variable_nameContext) {
	localctx = NewRow_pattern_variable_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, SQLv1Antlr4ParserRULE_row_pattern_variable_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2388)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrder_by_clauseContext is an interface to support dynamic dispatch.
type IOrder_by_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	Sort_specification_list() ISort_specification_listContext

	// IsOrder_by_clauseContext differentiates from other interfaces.
	IsOrder_by_clauseContext()
}

type Order_by_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrder_by_clauseContext() *Order_by_clauseContext {
	var p = new(Order_by_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_order_by_clause
	return p
}

func InitEmptyOrder_by_clauseContext(p *Order_by_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_order_by_clause
}

func (*Order_by_clauseContext) IsOrder_by_clauseContext() {}

func NewOrder_by_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Order_by_clauseContext {
	var p = new(Order_by_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_order_by_clause

	return p
}

func (s *Order_by_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Order_by_clauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserORDER, 0)
}

func (s *Order_by_clauseContext) BY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserBY, 0)
}

func (s *Order_by_clauseContext) Sort_specification_list() ISort_specification_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISort_specification_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISort_specification_listContext)
}

func (s *Order_by_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Order_by_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Order_by_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterOrder_by_clause(s)
	}
}

func (s *Order_by_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitOrder_by_clause(s)
	}
}

func (p *SQLv1Antlr4Parser) Order_by_clause() (localctx IOrder_by_clauseContext) {
	localctx = NewOrder_by_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, SQLv1Antlr4ParserRULE_order_by_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2390)
		p.Match(SQLv1Antlr4ParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2391)
		p.Match(SQLv1Antlr4ParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2392)
		p.Sort_specification_list()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExt_order_by_clauseContext is an interface to support dynamic dispatch.
type IExt_order_by_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Order_by_clause() IOrder_by_clauseContext
	ASSUME() antlr.TerminalNode

	// IsExt_order_by_clauseContext differentiates from other interfaces.
	IsExt_order_by_clauseContext()
}

type Ext_order_by_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExt_order_by_clauseContext() *Ext_order_by_clauseContext {
	var p = new(Ext_order_by_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_ext_order_by_clause
	return p
}

func InitEmptyExt_order_by_clauseContext(p *Ext_order_by_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_ext_order_by_clause
}

func (*Ext_order_by_clauseContext) IsExt_order_by_clauseContext() {}

func NewExt_order_by_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ext_order_by_clauseContext {
	var p = new(Ext_order_by_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_ext_order_by_clause

	return p
}

func (s *Ext_order_by_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Ext_order_by_clauseContext) Order_by_clause() IOrder_by_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_by_clauseContext)
}

func (s *Ext_order_by_clauseContext) ASSUME() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserASSUME, 0)
}

func (s *Ext_order_by_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ext_order_by_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ext_order_by_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterExt_order_by_clause(s)
	}
}

func (s *Ext_order_by_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitExt_order_by_clause(s)
	}
}

func (p *SQLv1Antlr4Parser) Ext_order_by_clause() (localctx IExt_order_by_clauseContext) {
	localctx = NewExt_order_by_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, SQLv1Antlr4ParserRULE_ext_order_by_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2395)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserASSUME {
		{
			p.SetState(2394)
			p.Match(SQLv1Antlr4ParserASSUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2397)
		p.Order_by_clause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroup_by_clauseContext is an interface to support dynamic dispatch.
type IGroup_by_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUP() antlr.TerminalNode
	BY() antlr.TerminalNode
	Opt_set_quantifier() IOpt_set_quantifierContext
	Grouping_element_list() IGrouping_element_listContext
	COMPACT() antlr.TerminalNode
	WITH() antlr.TerminalNode
	An_id() IAn_idContext

	// IsGroup_by_clauseContext differentiates from other interfaces.
	IsGroup_by_clauseContext()
}

type Group_by_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroup_by_clauseContext() *Group_by_clauseContext {
	var p = new(Group_by_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_group_by_clause
	return p
}

func InitEmptyGroup_by_clauseContext(p *Group_by_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_group_by_clause
}

func (*Group_by_clauseContext) IsGroup_by_clauseContext() {}

func NewGroup_by_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Group_by_clauseContext {
	var p = new(Group_by_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_group_by_clause

	return p
}

func (s *Group_by_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Group_by_clauseContext) GROUP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGROUP, 0)
}

func (s *Group_by_clauseContext) BY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserBY, 0)
}

func (s *Group_by_clauseContext) Opt_set_quantifier() IOpt_set_quantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_set_quantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_set_quantifierContext)
}

func (s *Group_by_clauseContext) Grouping_element_list() IGrouping_element_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrouping_element_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrouping_element_listContext)
}

func (s *Group_by_clauseContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMPACT, 0)
}

func (s *Group_by_clauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWITH, 0)
}

func (s *Group_by_clauseContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Group_by_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Group_by_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Group_by_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterGroup_by_clause(s)
	}
}

func (s *Group_by_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitGroup_by_clause(s)
	}
}

func (p *SQLv1Antlr4Parser) Group_by_clause() (localctx IGroup_by_clauseContext) {
	localctx = NewGroup_by_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, SQLv1Antlr4ParserRULE_group_by_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2399)
		p.Match(SQLv1Antlr4ParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2401)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserCOMPACT {
		{
			p.SetState(2400)
			p.Match(SQLv1Antlr4ParserCOMPACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2403)
		p.Match(SQLv1Antlr4ParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2404)
		p.Opt_set_quantifier()
	}
	{
		p.SetState(2405)
		p.Grouping_element_list()
	}
	p.SetState(2408)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserWITH {
		{
			p.SetState(2406)
			p.Match(SQLv1Antlr4ParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2407)
			p.An_id()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrouping_element_listContext is an interface to support dynamic dispatch.
type IGrouping_element_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGrouping_element() []IGrouping_elementContext
	Grouping_element(i int) IGrouping_elementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsGrouping_element_listContext differentiates from other interfaces.
	IsGrouping_element_listContext()
}

type Grouping_element_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrouping_element_listContext() *Grouping_element_listContext {
	var p = new(Grouping_element_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_grouping_element_list
	return p
}

func InitEmptyGrouping_element_listContext(p *Grouping_element_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_grouping_element_list
}

func (*Grouping_element_listContext) IsGrouping_element_listContext() {}

func NewGrouping_element_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Grouping_element_listContext {
	var p = new(Grouping_element_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_grouping_element_list

	return p
}

func (s *Grouping_element_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Grouping_element_listContext) AllGrouping_element() []IGrouping_elementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGrouping_elementContext); ok {
			len++
		}
	}

	tst := make([]IGrouping_elementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGrouping_elementContext); ok {
			tst[i] = t.(IGrouping_elementContext)
			i++
		}
	}

	return tst
}

func (s *Grouping_element_listContext) Grouping_element(i int) IGrouping_elementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrouping_elementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrouping_elementContext)
}

func (s *Grouping_element_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Grouping_element_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Grouping_element_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Grouping_element_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Grouping_element_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterGrouping_element_list(s)
	}
}

func (s *Grouping_element_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitGrouping_element_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Grouping_element_list() (localctx IGrouping_element_listContext) {
	localctx = NewGrouping_element_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, SQLv1Antlr4ParserRULE_grouping_element_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2410)
		p.Grouping_element()
	}
	p.SetState(2415)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(2411)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2412)
			p.Grouping_element()
		}

		p.SetState(2417)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrouping_elementContext is an interface to support dynamic dispatch.
type IGrouping_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ordinary_grouping_set() IOrdinary_grouping_setContext
	Rollup_list() IRollup_listContext
	Cube_list() ICube_listContext
	Grouping_sets_specification() IGrouping_sets_specificationContext
	Hopping_window_specification() IHopping_window_specificationContext

	// IsGrouping_elementContext differentiates from other interfaces.
	IsGrouping_elementContext()
}

type Grouping_elementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrouping_elementContext() *Grouping_elementContext {
	var p = new(Grouping_elementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_grouping_element
	return p
}

func InitEmptyGrouping_elementContext(p *Grouping_elementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_grouping_element
}

func (*Grouping_elementContext) IsGrouping_elementContext() {}

func NewGrouping_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Grouping_elementContext {
	var p = new(Grouping_elementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_grouping_element

	return p
}

func (s *Grouping_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Grouping_elementContext) Ordinary_grouping_set() IOrdinary_grouping_setContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrdinary_grouping_setContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrdinary_grouping_setContext)
}

func (s *Grouping_elementContext) Rollup_list() IRollup_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollup_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollup_listContext)
}

func (s *Grouping_elementContext) Cube_list() ICube_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICube_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICube_listContext)
}

func (s *Grouping_elementContext) Grouping_sets_specification() IGrouping_sets_specificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrouping_sets_specificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrouping_sets_specificationContext)
}

func (s *Grouping_elementContext) Hopping_window_specification() IHopping_window_specificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHopping_window_specificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHopping_window_specificationContext)
}

func (s *Grouping_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Grouping_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Grouping_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterGrouping_element(s)
	}
}

func (s *Grouping_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitGrouping_element(s)
	}
}

func (p *SQLv1Antlr4Parser) Grouping_element() (localctx IGrouping_elementContext) {
	localctx = NewGrouping_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, SQLv1Antlr4ParserRULE_grouping_element)
	p.SetState(2423)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 221, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2418)
			p.Ordinary_grouping_set()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2419)
			p.Rollup_list()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2420)
			p.Cube_list()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2421)
			p.Grouping_sets_specification()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2422)
			p.Hopping_window_specification()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrdinary_grouping_setContext is an interface to support dynamic dispatch.
type IOrdinary_grouping_setContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Named_expr() INamed_exprContext

	// IsOrdinary_grouping_setContext differentiates from other interfaces.
	IsOrdinary_grouping_setContext()
}

type Ordinary_grouping_setContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrdinary_grouping_setContext() *Ordinary_grouping_setContext {
	var p = new(Ordinary_grouping_setContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_ordinary_grouping_set
	return p
}

func InitEmptyOrdinary_grouping_setContext(p *Ordinary_grouping_setContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_ordinary_grouping_set
}

func (*Ordinary_grouping_setContext) IsOrdinary_grouping_setContext() {}

func NewOrdinary_grouping_setContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ordinary_grouping_setContext {
	var p = new(Ordinary_grouping_setContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_ordinary_grouping_set

	return p
}

func (s *Ordinary_grouping_setContext) GetParser() antlr.Parser { return s.parser }

func (s *Ordinary_grouping_setContext) Named_expr() INamed_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_exprContext)
}

func (s *Ordinary_grouping_setContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ordinary_grouping_setContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ordinary_grouping_setContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterOrdinary_grouping_set(s)
	}
}

func (s *Ordinary_grouping_setContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitOrdinary_grouping_set(s)
	}
}

func (p *SQLv1Antlr4Parser) Ordinary_grouping_set() (localctx IOrdinary_grouping_setContext) {
	localctx = NewOrdinary_grouping_setContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, SQLv1Antlr4ParserRULE_ordinary_grouping_set)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2425)
		p.Named_expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrdinary_grouping_set_listContext is an interface to support dynamic dispatch.
type IOrdinary_grouping_set_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllOrdinary_grouping_set() []IOrdinary_grouping_setContext
	Ordinary_grouping_set(i int) IOrdinary_grouping_setContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsOrdinary_grouping_set_listContext differentiates from other interfaces.
	IsOrdinary_grouping_set_listContext()
}

type Ordinary_grouping_set_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrdinary_grouping_set_listContext() *Ordinary_grouping_set_listContext {
	var p = new(Ordinary_grouping_set_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_ordinary_grouping_set_list
	return p
}

func InitEmptyOrdinary_grouping_set_listContext(p *Ordinary_grouping_set_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_ordinary_grouping_set_list
}

func (*Ordinary_grouping_set_listContext) IsOrdinary_grouping_set_listContext() {}

func NewOrdinary_grouping_set_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ordinary_grouping_set_listContext {
	var p = new(Ordinary_grouping_set_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_ordinary_grouping_set_list

	return p
}

func (s *Ordinary_grouping_set_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Ordinary_grouping_set_listContext) AllOrdinary_grouping_set() []IOrdinary_grouping_setContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOrdinary_grouping_setContext); ok {
			len++
		}
	}

	tst := make([]IOrdinary_grouping_setContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOrdinary_grouping_setContext); ok {
			tst[i] = t.(IOrdinary_grouping_setContext)
			i++
		}
	}

	return tst
}

func (s *Ordinary_grouping_set_listContext) Ordinary_grouping_set(i int) IOrdinary_grouping_setContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrdinary_grouping_setContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrdinary_grouping_setContext)
}

func (s *Ordinary_grouping_set_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Ordinary_grouping_set_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Ordinary_grouping_set_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ordinary_grouping_set_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ordinary_grouping_set_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterOrdinary_grouping_set_list(s)
	}
}

func (s *Ordinary_grouping_set_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitOrdinary_grouping_set_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Ordinary_grouping_set_list() (localctx IOrdinary_grouping_set_listContext) {
	localctx = NewOrdinary_grouping_set_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, SQLv1Antlr4ParserRULE_ordinary_grouping_set_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2427)
		p.Ordinary_grouping_set()
	}
	p.SetState(2432)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(2428)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2429)
			p.Ordinary_grouping_set()
		}

		p.SetState(2434)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollup_listContext is an interface to support dynamic dispatch.
type IRollup_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROLLUP() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Ordinary_grouping_set_list() IOrdinary_grouping_set_listContext
	RPAREN() antlr.TerminalNode

	// IsRollup_listContext differentiates from other interfaces.
	IsRollup_listContext()
}

type Rollup_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollup_listContext() *Rollup_listContext {
	var p = new(Rollup_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_rollup_list
	return p
}

func InitEmptyRollup_listContext(p *Rollup_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_rollup_list
}

func (*Rollup_listContext) IsRollup_listContext() {}

func NewRollup_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rollup_listContext {
	var p = new(Rollup_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_rollup_list

	return p
}

func (s *Rollup_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Rollup_listContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserROLLUP, 0)
}

func (s *Rollup_listContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Rollup_listContext) Ordinary_grouping_set_list() IOrdinary_grouping_set_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrdinary_grouping_set_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrdinary_grouping_set_listContext)
}

func (s *Rollup_listContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Rollup_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rollup_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rollup_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRollup_list(s)
	}
}

func (s *Rollup_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRollup_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Rollup_list() (localctx IRollup_listContext) {
	localctx = NewRollup_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, SQLv1Antlr4ParserRULE_rollup_list)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2435)
		p.Match(SQLv1Antlr4ParserROLLUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2436)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2437)
		p.Ordinary_grouping_set_list()
	}
	{
		p.SetState(2438)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICube_listContext is an interface to support dynamic dispatch.
type ICube_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CUBE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Ordinary_grouping_set_list() IOrdinary_grouping_set_listContext
	RPAREN() antlr.TerminalNode

	// IsCube_listContext differentiates from other interfaces.
	IsCube_listContext()
}

type Cube_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCube_listContext() *Cube_listContext {
	var p = new(Cube_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_cube_list
	return p
}

func InitEmptyCube_listContext(p *Cube_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_cube_list
}

func (*Cube_listContext) IsCube_listContext() {}

func NewCube_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cube_listContext {
	var p = new(Cube_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_cube_list

	return p
}

func (s *Cube_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Cube_listContext) CUBE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCUBE, 0)
}

func (s *Cube_listContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Cube_listContext) Ordinary_grouping_set_list() IOrdinary_grouping_set_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrdinary_grouping_set_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrdinary_grouping_set_listContext)
}

func (s *Cube_listContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Cube_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cube_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cube_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterCube_list(s)
	}
}

func (s *Cube_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitCube_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Cube_list() (localctx ICube_listContext) {
	localctx = NewCube_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, SQLv1Antlr4ParserRULE_cube_list)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2440)
		p.Match(SQLv1Antlr4ParserCUBE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2441)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2442)
		p.Ordinary_grouping_set_list()
	}
	{
		p.SetState(2443)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrouping_sets_specificationContext is an interface to support dynamic dispatch.
type IGrouping_sets_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUPING() antlr.TerminalNode
	SETS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Grouping_element_list() IGrouping_element_listContext
	RPAREN() antlr.TerminalNode

	// IsGrouping_sets_specificationContext differentiates from other interfaces.
	IsGrouping_sets_specificationContext()
}

type Grouping_sets_specificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrouping_sets_specificationContext() *Grouping_sets_specificationContext {
	var p = new(Grouping_sets_specificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_grouping_sets_specification
	return p
}

func InitEmptyGrouping_sets_specificationContext(p *Grouping_sets_specificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_grouping_sets_specification
}

func (*Grouping_sets_specificationContext) IsGrouping_sets_specificationContext() {}

func NewGrouping_sets_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Grouping_sets_specificationContext {
	var p = new(Grouping_sets_specificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_grouping_sets_specification

	return p
}

func (s *Grouping_sets_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Grouping_sets_specificationContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGROUPING, 0)
}

func (s *Grouping_sets_specificationContext) SETS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSETS, 0)
}

func (s *Grouping_sets_specificationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Grouping_sets_specificationContext) Grouping_element_list() IGrouping_element_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrouping_element_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrouping_element_listContext)
}

func (s *Grouping_sets_specificationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Grouping_sets_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Grouping_sets_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Grouping_sets_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterGrouping_sets_specification(s)
	}
}

func (s *Grouping_sets_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitGrouping_sets_specification(s)
	}
}

func (p *SQLv1Antlr4Parser) Grouping_sets_specification() (localctx IGrouping_sets_specificationContext) {
	localctx = NewGrouping_sets_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, SQLv1Antlr4ParserRULE_grouping_sets_specification)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2445)
		p.Match(SQLv1Antlr4ParserGROUPING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2446)
		p.Match(SQLv1Antlr4ParserSETS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2447)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2448)
		p.Grouping_element_list()
	}
	{
		p.SetState(2449)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHopping_window_specificationContext is an interface to support dynamic dispatch.
type IHopping_window_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HOP() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	RPAREN() antlr.TerminalNode

	// IsHopping_window_specificationContext differentiates from other interfaces.
	IsHopping_window_specificationContext()
}

type Hopping_window_specificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHopping_window_specificationContext() *Hopping_window_specificationContext {
	var p = new(Hopping_window_specificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_hopping_window_specification
	return p
}

func InitEmptyHopping_window_specificationContext(p *Hopping_window_specificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_hopping_window_specification
}

func (*Hopping_window_specificationContext) IsHopping_window_specificationContext() {}

func NewHopping_window_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hopping_window_specificationContext {
	var p = new(Hopping_window_specificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_hopping_window_specification

	return p
}

func (s *Hopping_window_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Hopping_window_specificationContext) HOP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserHOP, 0)
}

func (s *Hopping_window_specificationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Hopping_window_specificationContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Hopping_window_specificationContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Hopping_window_specificationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Hopping_window_specificationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Hopping_window_specificationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Hopping_window_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hopping_window_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hopping_window_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterHopping_window_specification(s)
	}
}

func (s *Hopping_window_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitHopping_window_specification(s)
	}
}

func (p *SQLv1Antlr4Parser) Hopping_window_specification() (localctx IHopping_window_specificationContext) {
	localctx = NewHopping_window_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, SQLv1Antlr4ParserRULE_hopping_window_specification)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2451)
		p.Match(SQLv1Antlr4ParserHOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2452)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2453)
		p.Expr()
	}
	{
		p.SetState(2454)
		p.Match(SQLv1Antlr4ParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2455)
		p.Expr()
	}
	{
		p.SetState(2456)
		p.Match(SQLv1Antlr4ParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2457)
		p.Expr()
	}
	{
		p.SetState(2458)
		p.Match(SQLv1Antlr4ParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2459)
		p.Expr()
	}
	{
		p.SetState(2460)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResult_columnContext is an interface to support dynamic dispatch.
type IResult_columnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Opt_id_prefix() IOpt_id_prefixContext
	ASTERISK() antlr.TerminalNode
	Expr() IExprContext
	AS() antlr.TerminalNode
	An_id_or_type() IAn_id_or_typeContext
	An_id_as_compat() IAn_id_as_compatContext

	// IsResult_columnContext differentiates from other interfaces.
	IsResult_columnContext()
}

type Result_columnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResult_columnContext() *Result_columnContext {
	var p = new(Result_columnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_result_column
	return p
}

func InitEmptyResult_columnContext(p *Result_columnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_result_column
}

func (*Result_columnContext) IsResult_columnContext() {}

func NewResult_columnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Result_columnContext {
	var p = new(Result_columnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_result_column

	return p
}

func (s *Result_columnContext) GetParser() antlr.Parser { return s.parser }

func (s *Result_columnContext) Opt_id_prefix() IOpt_id_prefixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_id_prefixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_id_prefixContext)
}

func (s *Result_columnContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserASTERISK, 0)
}

func (s *Result_columnContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Result_columnContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAS, 0)
}

func (s *Result_columnContext) An_id_or_type() IAn_id_or_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_or_typeContext)
}

func (s *Result_columnContext) An_id_as_compat() IAn_id_as_compatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_as_compatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_as_compatContext)
}

func (s *Result_columnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Result_columnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Result_columnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterResult_column(s)
	}
}

func (s *Result_columnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitResult_column(s)
	}
}

func (p *SQLv1Antlr4Parser) Result_column() (localctx IResult_columnContext) {
	localctx = NewResult_columnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, SQLv1Antlr4ParserRULE_result_column)
	p.SetState(2471)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 224, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2462)
			p.Opt_id_prefix()
		}
		{
			p.SetState(2463)
			p.Match(SQLv1Antlr4ParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2465)
			p.Expr()
		}
		p.SetState(2469)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 223, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2466)
				p.Match(SQLv1Antlr4ParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2467)
				p.An_id_or_type()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 223, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(2468)
				p.An_id_as_compat()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoin_sourceContext is an interface to support dynamic dispatch.
type IJoin_sourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFlatten_source() []IFlatten_sourceContext
	Flatten_source(i int) IFlatten_sourceContext
	AllANY() []antlr.TerminalNode
	ANY(i int) antlr.TerminalNode
	AllJoin_op() []IJoin_opContext
	Join_op(i int) IJoin_opContext
	AllJoin_constraint() []IJoin_constraintContext
	Join_constraint(i int) IJoin_constraintContext

	// IsJoin_sourceContext differentiates from other interfaces.
	IsJoin_sourceContext()
}

type Join_sourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoin_sourceContext() *Join_sourceContext {
	var p = new(Join_sourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_join_source
	return p
}

func InitEmptyJoin_sourceContext(p *Join_sourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_join_source
}

func (*Join_sourceContext) IsJoin_sourceContext() {}

func NewJoin_sourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Join_sourceContext {
	var p = new(Join_sourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_join_source

	return p
}

func (s *Join_sourceContext) GetParser() antlr.Parser { return s.parser }

func (s *Join_sourceContext) AllFlatten_source() []IFlatten_sourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFlatten_sourceContext); ok {
			len++
		}
	}

	tst := make([]IFlatten_sourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFlatten_sourceContext); ok {
			tst[i] = t.(IFlatten_sourceContext)
			i++
		}
	}

	return tst
}

func (s *Join_sourceContext) Flatten_source(i int) IFlatten_sourceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlatten_sourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlatten_sourceContext)
}

func (s *Join_sourceContext) AllANY() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserANY)
}

func (s *Join_sourceContext) ANY(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserANY, i)
}

func (s *Join_sourceContext) AllJoin_op() []IJoin_opContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoin_opContext); ok {
			len++
		}
	}

	tst := make([]IJoin_opContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoin_opContext); ok {
			tst[i] = t.(IJoin_opContext)
			i++
		}
	}

	return tst
}

func (s *Join_sourceContext) Join_op(i int) IJoin_opContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoin_opContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoin_opContext)
}

func (s *Join_sourceContext) AllJoin_constraint() []IJoin_constraintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoin_constraintContext); ok {
			len++
		}
	}

	tst := make([]IJoin_constraintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoin_constraintContext); ok {
			tst[i] = t.(IJoin_constraintContext)
			i++
		}
	}

	return tst
}

func (s *Join_sourceContext) Join_constraint(i int) IJoin_constraintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoin_constraintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoin_constraintContext)
}

func (s *Join_sourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Join_sourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Join_sourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterJoin_source(s)
	}
}

func (s *Join_sourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitJoin_source(s)
	}
}

func (p *SQLv1Antlr4Parser) Join_source() (localctx IJoin_sourceContext) {
	localctx = NewJoin_sourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, SQLv1Antlr4ParserRULE_join_source)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2474)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 225, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2473)
			p.Match(SQLv1Antlr4ParserANY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2476)
		p.Flatten_source()
	}
	p.SetState(2487)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA || ((int64((_la-91)) & ^0x3f) == 0 && ((int64(1)<<(_la-91))&36029071896870913) != 0) || ((int64((_la-169)) & ^0x3f) == 0 && ((int64(1)<<(_la-169))&140737756799105) != 0) || _la == SQLv1Antlr4ParserRIGHT {
		{
			p.SetState(2477)
			p.Join_op()
		}
		p.SetState(2479)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 226, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2478)
				p.Match(SQLv1Antlr4ParserANY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2481)
			p.Flatten_source()
		}
		p.SetState(2483)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserON || _la == SQLv1Antlr4ParserUSING {
			{
				p.SetState(2482)
				p.Join_constraint()
			}

		}

		p.SetState(2489)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamed_columnContext is an interface to support dynamic dispatch.
type INamed_columnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column_name() IColumn_nameContext
	AS() antlr.TerminalNode
	An_id() IAn_idContext

	// IsNamed_columnContext differentiates from other interfaces.
	IsNamed_columnContext()
}

type Named_columnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_columnContext() *Named_columnContext {
	var p = new(Named_columnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_named_column
	return p
}

func InitEmptyNamed_columnContext(p *Named_columnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_named_column
}

func (*Named_columnContext) IsNamed_columnContext() {}

func NewNamed_columnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_columnContext {
	var p = new(Named_columnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_named_column

	return p
}

func (s *Named_columnContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_columnContext) Column_name() IColumn_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Named_columnContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAS, 0)
}

func (s *Named_columnContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Named_columnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_columnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Named_columnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterNamed_column(s)
	}
}

func (s *Named_columnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitNamed_column(s)
	}
}

func (p *SQLv1Antlr4Parser) Named_column() (localctx INamed_columnContext) {
	localctx = NewNamed_columnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, SQLv1Antlr4ParserRULE_named_column)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2490)
		p.Column_name()
	}
	p.SetState(2493)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserAS {
		{
			p.SetState(2491)
			p.Match(SQLv1Antlr4ParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2492)
			p.An_id()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFlatten_by_argContext is an interface to support dynamic dispatch.
type IFlatten_by_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Named_column() INamed_columnContext
	LPAREN() antlr.TerminalNode
	Named_expr_list() INamed_expr_listContext
	RPAREN() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsFlatten_by_argContext differentiates from other interfaces.
	IsFlatten_by_argContext()
}

type Flatten_by_argContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlatten_by_argContext() *Flatten_by_argContext {
	var p = new(Flatten_by_argContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_flatten_by_arg
	return p
}

func InitEmptyFlatten_by_argContext(p *Flatten_by_argContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_flatten_by_arg
}

func (*Flatten_by_argContext) IsFlatten_by_argContext() {}

func NewFlatten_by_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flatten_by_argContext {
	var p = new(Flatten_by_argContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_flatten_by_arg

	return p
}

func (s *Flatten_by_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Flatten_by_argContext) Named_column() INamed_columnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_columnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_columnContext)
}

func (s *Flatten_by_argContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Flatten_by_argContext) Named_expr_list() INamed_expr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_expr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_expr_listContext)
}

func (s *Flatten_by_argContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Flatten_by_argContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, 0)
}

func (s *Flatten_by_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flatten_by_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Flatten_by_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterFlatten_by_arg(s)
	}
}

func (s *Flatten_by_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitFlatten_by_arg(s)
	}
}

func (p *SQLv1Antlr4Parser) Flatten_by_arg() (localctx IFlatten_by_argContext) {
	localctx = NewFlatten_by_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, SQLv1Antlr4ParserRULE_flatten_by_arg)
	var _la int

	p.SetState(2503)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALL, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserANY, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSTREAM, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWITHOUT, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserSTRING_VALUE, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2495)
			p.Named_column()
		}

	case SQLv1Antlr4ParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2496)
			p.Match(SQLv1Antlr4ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2497)
			p.Named_expr_list()
		}
		p.SetState(2499)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserCOMMA {
			{
				p.SetState(2498)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2501)
			p.Match(SQLv1Antlr4ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFlatten_sourceContext is an interface to support dynamic dispatch.
type IFlatten_sourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Named_single_source() INamed_single_sourceContext
	FLATTEN() antlr.TerminalNode
	BY() antlr.TerminalNode
	Flatten_by_arg() IFlatten_by_argContext
	COLUMNS() antlr.TerminalNode
	OPTIONAL() antlr.TerminalNode
	LIST() antlr.TerminalNode
	DICT() antlr.TerminalNode

	// IsFlatten_sourceContext differentiates from other interfaces.
	IsFlatten_sourceContext()
}

type Flatten_sourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlatten_sourceContext() *Flatten_sourceContext {
	var p = new(Flatten_sourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_flatten_source
	return p
}

func InitEmptyFlatten_sourceContext(p *Flatten_sourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_flatten_source
}

func (*Flatten_sourceContext) IsFlatten_sourceContext() {}

func NewFlatten_sourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flatten_sourceContext {
	var p = new(Flatten_sourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_flatten_source

	return p
}

func (s *Flatten_sourceContext) GetParser() antlr.Parser { return s.parser }

func (s *Flatten_sourceContext) Named_single_source() INamed_single_sourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_single_sourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_single_sourceContext)
}

func (s *Flatten_sourceContext) FLATTEN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFLATTEN, 0)
}

func (s *Flatten_sourceContext) BY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserBY, 0)
}

func (s *Flatten_sourceContext) Flatten_by_arg() IFlatten_by_argContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlatten_by_argContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlatten_by_argContext)
}

func (s *Flatten_sourceContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOLUMNS, 0)
}

func (s *Flatten_sourceContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOPTIONAL, 0)
}

func (s *Flatten_sourceContext) LIST() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLIST, 0)
}

func (s *Flatten_sourceContext) DICT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDICT, 0)
}

func (s *Flatten_sourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flatten_sourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Flatten_sourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterFlatten_source(s)
	}
}

func (s *Flatten_sourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitFlatten_source(s)
	}
}

func (p *SQLv1Antlr4Parser) Flatten_source() (localctx IFlatten_sourceContext) {
	localctx = NewFlatten_sourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, SQLv1Antlr4ParserRULE_flatten_source)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2505)
		p.Named_single_source()
	}
	p.SetState(2515)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserFLATTEN {
		{
			p.SetState(2506)
			p.Match(SQLv1Antlr4ParserFLATTEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2513)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case SQLv1Antlr4ParserBY, SQLv1Antlr4ParserDICT, SQLv1Antlr4ParserLIST, SQLv1Antlr4ParserOPTIONAL:
			p.SetState(2508)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SQLv1Antlr4ParserDICT || _la == SQLv1Antlr4ParserLIST || _la == SQLv1Antlr4ParserOPTIONAL {
				{
					p.SetState(2507)
					_la = p.GetTokenStream().LA(1)

					if !(_la == SQLv1Antlr4ParserDICT || _la == SQLv1Antlr4ParserLIST || _la == SQLv1Antlr4ParserOPTIONAL) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(2510)
				p.Match(SQLv1Antlr4ParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2511)
				p.Flatten_by_arg()
			}

		case SQLv1Antlr4ParserCOLUMNS:
			{
				p.SetState(2512)
				p.Match(SQLv1Antlr4ParserCOLUMNS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamed_single_sourceContext is an interface to support dynamic dispatch.
type INamed_single_sourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Single_source() ISingle_sourceContext
	Row_pattern_recognition_clause() IRow_pattern_recognition_clauseContext
	Sample_clause() ISample_clauseContext
	Tablesample_clause() ITablesample_clauseContext
	AS() antlr.TerminalNode
	An_id() IAn_idContext
	An_id_as_compat() IAn_id_as_compatContext
	Pure_column_list() IPure_column_listContext

	// IsNamed_single_sourceContext differentiates from other interfaces.
	IsNamed_single_sourceContext()
}

type Named_single_sourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_single_sourceContext() *Named_single_sourceContext {
	var p = new(Named_single_sourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_named_single_source
	return p
}

func InitEmptyNamed_single_sourceContext(p *Named_single_sourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_named_single_source
}

func (*Named_single_sourceContext) IsNamed_single_sourceContext() {}

func NewNamed_single_sourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_single_sourceContext {
	var p = new(Named_single_sourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_named_single_source

	return p
}

func (s *Named_single_sourceContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_single_sourceContext) Single_source() ISingle_sourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingle_sourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingle_sourceContext)
}

func (s *Named_single_sourceContext) Row_pattern_recognition_clause() IRow_pattern_recognition_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_pattern_recognition_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_pattern_recognition_clauseContext)
}

func (s *Named_single_sourceContext) Sample_clause() ISample_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISample_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISample_clauseContext)
}

func (s *Named_single_sourceContext) Tablesample_clause() ITablesample_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesample_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesample_clauseContext)
}

func (s *Named_single_sourceContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAS, 0)
}

func (s *Named_single_sourceContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Named_single_sourceContext) An_id_as_compat() IAn_id_as_compatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_as_compatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_as_compatContext)
}

func (s *Named_single_sourceContext) Pure_column_list() IPure_column_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPure_column_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPure_column_listContext)
}

func (s *Named_single_sourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_single_sourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Named_single_sourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterNamed_single_source(s)
	}
}

func (s *Named_single_sourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitNamed_single_source(s)
	}
}

func (p *SQLv1Antlr4Parser) Named_single_source() (localctx INamed_single_sourceContext) {
	localctx = NewNamed_single_sourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, SQLv1Antlr4ParserRULE_named_single_source)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2517)
		p.Single_source()
	}
	p.SetState(2519)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 235, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2518)
			p.Row_pattern_recognition_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2529)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 238, p.GetParserRuleContext()) == 1 {
		p.SetState(2524)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case SQLv1Antlr4ParserAS:
			{
				p.SetState(2521)
				p.Match(SQLv1Antlr4ParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2522)
				p.An_id()
			}

		case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserSTRING_VALUE, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
			{
				p.SetState(2523)
				p.An_id_as_compat()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(2527)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserLPAREN {
			{
				p.SetState(2526)
				p.Pure_column_list()
			}

		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2533)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserSAMPLE:
		{
			p.SetState(2531)
			p.Sample_clause()
		}

	case SQLv1Antlr4ParserTABLESAMPLE:
		{
			p.SetState(2532)
			p.Tablesample_clause()
		}

	case SQLv1Antlr4ParserEOF, SQLv1Antlr4ParserSEMICOLON, SQLv1Antlr4ParserCOMMA, SQLv1Antlr4ParserRPAREN, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserON, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingle_sourceContext is an interface to support dynamic dispatch.
type ISingle_sourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_ref() ITable_refContext
	LPAREN() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	RPAREN() antlr.TerminalNode
	Values_stmt() IValues_stmtContext

	// IsSingle_sourceContext differentiates from other interfaces.
	IsSingle_sourceContext()
}

type Single_sourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingle_sourceContext() *Single_sourceContext {
	var p = new(Single_sourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_single_source
	return p
}

func InitEmptySingle_sourceContext(p *Single_sourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_single_source
}

func (*Single_sourceContext) IsSingle_sourceContext() {}

func NewSingle_sourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Single_sourceContext {
	var p = new(Single_sourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_single_source

	return p
}

func (s *Single_sourceContext) GetParser() antlr.Parser { return s.parser }

func (s *Single_sourceContext) Table_ref() ITable_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_refContext)
}

func (s *Single_sourceContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Single_sourceContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Single_sourceContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Single_sourceContext) Values_stmt() IValues_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValues_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValues_stmtContext)
}

func (s *Single_sourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Single_sourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Single_sourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSingle_source(s)
	}
}

func (s *Single_sourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSingle_source(s)
	}
}

func (p *SQLv1Antlr4Parser) Single_source() (localctx ISingle_sourceContext) {
	localctx = NewSingle_sourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, SQLv1Antlr4ParserRULE_single_source)
	p.SetState(2544)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 240, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2535)
			p.Table_ref()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2536)
			p.Match(SQLv1Antlr4ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2537)
			p.Select_stmt()
		}
		{
			p.SetState(2538)
			p.Match(SQLv1Antlr4ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2540)
			p.Match(SQLv1Antlr4ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2541)
			p.Values_stmt()
		}
		{
			p.SetState(2542)
			p.Match(SQLv1Antlr4ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISample_clauseContext is an interface to support dynamic dispatch.
type ISample_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SAMPLE() antlr.TerminalNode
	Expr() IExprContext

	// IsSample_clauseContext differentiates from other interfaces.
	IsSample_clauseContext()
}

type Sample_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySample_clauseContext() *Sample_clauseContext {
	var p = new(Sample_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_sample_clause
	return p
}

func InitEmptySample_clauseContext(p *Sample_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_sample_clause
}

func (*Sample_clauseContext) IsSample_clauseContext() {}

func NewSample_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sample_clauseContext {
	var p = new(Sample_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_sample_clause

	return p
}

func (s *Sample_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Sample_clauseContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSAMPLE, 0)
}

func (s *Sample_clauseContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Sample_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sample_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sample_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSample_clause(s)
	}
}

func (s *Sample_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSample_clause(s)
	}
}

func (p *SQLv1Antlr4Parser) Sample_clause() (localctx ISample_clauseContext) {
	localctx = NewSample_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, SQLv1Antlr4ParserRULE_sample_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2546)
		p.Match(SQLv1Antlr4ParserSAMPLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2547)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablesample_clauseContext is an interface to support dynamic dispatch.
type ITablesample_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLESAMPLE() antlr.TerminalNode
	Sampling_mode() ISampling_modeContext
	LPAREN() antlr.TerminalNode
	Expr() IExprContext
	RPAREN() antlr.TerminalNode
	Repeatable_clause() IRepeatable_clauseContext

	// IsTablesample_clauseContext differentiates from other interfaces.
	IsTablesample_clauseContext()
}

type Tablesample_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablesample_clauseContext() *Tablesample_clauseContext {
	var p = new(Tablesample_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_tablesample_clause
	return p
}

func InitEmptyTablesample_clauseContext(p *Tablesample_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_tablesample_clause
}

func (*Tablesample_clauseContext) IsTablesample_clauseContext() {}

func NewTablesample_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tablesample_clauseContext {
	var p = new(Tablesample_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_tablesample_clause

	return p
}

func (s *Tablesample_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Tablesample_clauseContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTABLESAMPLE, 0)
}

func (s *Tablesample_clauseContext) Sampling_mode() ISampling_modeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampling_modeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampling_modeContext)
}

func (s *Tablesample_clauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Tablesample_clauseContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Tablesample_clauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Tablesample_clauseContext) Repeatable_clause() IRepeatable_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRepeatable_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRepeatable_clauseContext)
}

func (s *Tablesample_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tablesample_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tablesample_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterTablesample_clause(s)
	}
}

func (s *Tablesample_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitTablesample_clause(s)
	}
}

func (p *SQLv1Antlr4Parser) Tablesample_clause() (localctx ITablesample_clauseContext) {
	localctx = NewTablesample_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, SQLv1Antlr4ParserRULE_tablesample_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2549)
		p.Match(SQLv1Antlr4ParserTABLESAMPLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2550)
		p.Sampling_mode()
	}
	{
		p.SetState(2551)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2552)
		p.Expr()
	}
	{
		p.SetState(2553)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2555)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserREPEATABLE {
		{
			p.SetState(2554)
			p.Repeatable_clause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISampling_modeContext is an interface to support dynamic dispatch.
type ISampling_modeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BERNOULLI() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode

	// IsSampling_modeContext differentiates from other interfaces.
	IsSampling_modeContext()
}

type Sampling_modeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySampling_modeContext() *Sampling_modeContext {
	var p = new(Sampling_modeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_sampling_mode
	return p
}

func InitEmptySampling_modeContext(p *Sampling_modeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_sampling_mode
}

func (*Sampling_modeContext) IsSampling_modeContext() {}

func NewSampling_modeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sampling_modeContext {
	var p = new(Sampling_modeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_sampling_mode

	return p
}

func (s *Sampling_modeContext) GetParser() antlr.Parser { return s.parser }

func (s *Sampling_modeContext) BERNOULLI() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserBERNOULLI, 0)
}

func (s *Sampling_modeContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSYSTEM, 0)
}

func (s *Sampling_modeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sampling_modeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sampling_modeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSampling_mode(s)
	}
}

func (s *Sampling_modeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSampling_mode(s)
	}
}

func (p *SQLv1Antlr4Parser) Sampling_mode() (localctx ISampling_modeContext) {
	localctx = NewSampling_modeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, SQLv1Antlr4ParserRULE_sampling_mode)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2557)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLv1Antlr4ParserBERNOULLI || _la == SQLv1Antlr4ParserSYSTEM) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRepeatable_clauseContext is an interface to support dynamic dispatch.
type IRepeatable_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPEATABLE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expr() IExprContext
	RPAREN() antlr.TerminalNode

	// IsRepeatable_clauseContext differentiates from other interfaces.
	IsRepeatable_clauseContext()
}

type Repeatable_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepeatable_clauseContext() *Repeatable_clauseContext {
	var p = new(Repeatable_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_repeatable_clause
	return p
}

func InitEmptyRepeatable_clauseContext(p *Repeatable_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_repeatable_clause
}

func (*Repeatable_clauseContext) IsRepeatable_clauseContext() {}

func NewRepeatable_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Repeatable_clauseContext {
	var p = new(Repeatable_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_repeatable_clause

	return p
}

func (s *Repeatable_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Repeatable_clauseContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREPEATABLE, 0)
}

func (s *Repeatable_clauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Repeatable_clauseContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Repeatable_clauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Repeatable_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Repeatable_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Repeatable_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRepeatable_clause(s)
	}
}

func (s *Repeatable_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRepeatable_clause(s)
	}
}

func (p *SQLv1Antlr4Parser) Repeatable_clause() (localctx IRepeatable_clauseContext) {
	localctx = NewRepeatable_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, SQLv1Antlr4ParserRULE_repeatable_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2559)
		p.Match(SQLv1Antlr4ParserREPEATABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2560)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2561)
		p.Expr()
	}
	{
		p.SetState(2562)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoin_opContext is an interface to support dynamic dispatch.
type IJoin_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMA() antlr.TerminalNode
	JOIN() antlr.TerminalNode
	INNER() antlr.TerminalNode
	CROSS() antlr.TerminalNode
	NATURAL() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	EXCLUSION() antlr.TerminalNode
	FULL() antlr.TerminalNode
	OUTER() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	SEMI() antlr.TerminalNode

	// IsJoin_opContext differentiates from other interfaces.
	IsJoin_opContext()
}

type Join_opContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoin_opContext() *Join_opContext {
	var p = new(Join_opContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_join_op
	return p
}

func InitEmptyJoin_opContext(p *Join_opContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_join_op
}

func (*Join_opContext) IsJoin_opContext() {}

func NewJoin_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Join_opContext {
	var p = new(Join_opContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_join_op

	return p
}

func (s *Join_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Join_opContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, 0)
}

func (s *Join_opContext) JOIN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserJOIN, 0)
}

func (s *Join_opContext) INNER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINNER, 0)
}

func (s *Join_opContext) CROSS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCROSS, 0)
}

func (s *Join_opContext) NATURAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNATURAL, 0)
}

func (s *Join_opContext) LEFT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLEFT, 0)
}

func (s *Join_opContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRIGHT, 0)
}

func (s *Join_opContext) EXCLUSION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXCLUSION, 0)
}

func (s *Join_opContext) FULL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFULL, 0)
}

func (s *Join_opContext) OUTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOUTER, 0)
}

func (s *Join_opContext) ONLY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserONLY, 0)
}

func (s *Join_opContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSEMI, 0)
}

func (s *Join_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Join_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Join_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterJoin_op(s)
	}
}

func (s *Join_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitJoin_op(s)
	}
}

func (p *SQLv1Antlr4Parser) Join_op() (localctx IJoin_opContext) {
	localctx = NewJoin_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, SQLv1Antlr4ParserRULE_join_op)
	var _la int

	p.SetState(2588)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserCOMMA:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2564)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserRIGHT:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2566)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserNATURAL {
			{
				p.SetState(2565)
				p.Match(SQLv1Antlr4ParserNATURAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2585)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserRIGHT:
			p.SetState(2578)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			switch p.GetTokenStream().LA(1) {
			case SQLv1Antlr4ParserLEFT:
				{
					p.SetState(2568)
					p.Match(SQLv1Antlr4ParserLEFT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(2570)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == SQLv1Antlr4ParserONLY || _la == SQLv1Antlr4ParserSEMI {
					{
						p.SetState(2569)
						_la = p.GetTokenStream().LA(1)

						if !(_la == SQLv1Antlr4ParserONLY || _la == SQLv1Antlr4ParserSEMI) {
							p.GetErrorHandler().RecoverInline(p)
						} else {
							p.GetErrorHandler().ReportMatch(p)
							p.Consume()
						}
					}

				}

			case SQLv1Antlr4ParserRIGHT:
				{
					p.SetState(2572)
					p.Match(SQLv1Antlr4ParserRIGHT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(2574)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == SQLv1Antlr4ParserONLY || _la == SQLv1Antlr4ParserSEMI {
					{
						p.SetState(2573)
						_la = p.GetTokenStream().LA(1)

						if !(_la == SQLv1Antlr4ParserONLY || _la == SQLv1Antlr4ParserSEMI) {
							p.GetErrorHandler().RecoverInline(p)
						} else {
							p.GetErrorHandler().ReportMatch(p)
							p.Consume()
						}
					}

				}

			case SQLv1Antlr4ParserEXCLUSION:
				{
					p.SetState(2576)
					p.Match(SQLv1Antlr4ParserEXCLUSION)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case SQLv1Antlr4ParserFULL:
				{
					p.SetState(2577)
					p.Match(SQLv1Antlr4ParserFULL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserOUTER:

			default:
			}
			p.SetState(2581)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SQLv1Antlr4ParserOUTER {
				{
					p.SetState(2580)
					p.Match(SQLv1Antlr4ParserOUTER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		case SQLv1Antlr4ParserINNER:
			{
				p.SetState(2583)
				p.Match(SQLv1Antlr4ParserINNER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case SQLv1Antlr4ParserCROSS:
			{
				p.SetState(2584)
				p.Match(SQLv1Antlr4ParserCROSS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(2587)
			p.Match(SQLv1Antlr4ParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoin_constraintContext is an interface to support dynamic dispatch.
type IJoin_constraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	Expr() IExprContext
	USING() antlr.TerminalNode
	Pure_column_or_named_list() IPure_column_or_named_listContext

	// IsJoin_constraintContext differentiates from other interfaces.
	IsJoin_constraintContext()
}

type Join_constraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoin_constraintContext() *Join_constraintContext {
	var p = new(Join_constraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_join_constraint
	return p
}

func InitEmptyJoin_constraintContext(p *Join_constraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_join_constraint
}

func (*Join_constraintContext) IsJoin_constraintContext() {}

func NewJoin_constraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Join_constraintContext {
	var p = new(Join_constraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_join_constraint

	return p
}

func (s *Join_constraintContext) GetParser() antlr.Parser { return s.parser }

func (s *Join_constraintContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserON, 0)
}

func (s *Join_constraintContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Join_constraintContext) USING() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUSING, 0)
}

func (s *Join_constraintContext) Pure_column_or_named_list() IPure_column_or_named_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPure_column_or_named_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPure_column_or_named_listContext)
}

func (s *Join_constraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Join_constraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Join_constraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterJoin_constraint(s)
	}
}

func (s *Join_constraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitJoin_constraint(s)
	}
}

func (p *SQLv1Antlr4Parser) Join_constraint() (localctx IJoin_constraintContext) {
	localctx = NewJoin_constraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, SQLv1Antlr4ParserRULE_join_constraint)
	p.SetState(2594)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2590)
			p.Match(SQLv1Antlr4ParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2591)
			p.Expr()
		}

	case SQLv1Antlr4ParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2592)
			p.Match(SQLv1Antlr4ParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2593)
			p.Pure_column_or_named_list()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturning_columns_listContext is an interface to support dynamic dispatch.
type IReturning_columns_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURNING() antlr.TerminalNode
	ASTERISK() antlr.TerminalNode
	AllAn_id() []IAn_idContext
	An_id(i int) IAn_idContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsReturning_columns_listContext differentiates from other interfaces.
	IsReturning_columns_listContext()
}

type Returning_columns_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturning_columns_listContext() *Returning_columns_listContext {
	var p = new(Returning_columns_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_returning_columns_list
	return p
}

func InitEmptyReturning_columns_listContext(p *Returning_columns_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_returning_columns_list
}

func (*Returning_columns_listContext) IsReturning_columns_listContext() {}

func NewReturning_columns_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Returning_columns_listContext {
	var p = new(Returning_columns_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_returning_columns_list

	return p
}

func (s *Returning_columns_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Returning_columns_listContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRETURNING, 0)
}

func (s *Returning_columns_listContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserASTERISK, 0)
}

func (s *Returning_columns_listContext) AllAn_id() []IAn_idContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_idContext); ok {
			len++
		}
	}

	tst := make([]IAn_idContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_idContext); ok {
			tst[i] = t.(IAn_idContext)
			i++
		}
	}

	return tst
}

func (s *Returning_columns_listContext) An_id(i int) IAn_idContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Returning_columns_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Returning_columns_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Returning_columns_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Returning_columns_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Returning_columns_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterReturning_columns_list(s)
	}
}

func (s *Returning_columns_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitReturning_columns_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Returning_columns_list() (localctx IReturning_columns_listContext) {
	localctx = NewReturning_columns_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, SQLv1Antlr4ParserRULE_returning_columns_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2596)
		p.Match(SQLv1Antlr4ParserRETURNING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2606)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserASTERISK:
		{
			p.SetState(2597)
			p.Match(SQLv1Antlr4ParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALL, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserANY, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSTREAM, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWITHOUT, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserSTRING_VALUE, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		{
			p.SetState(2598)
			p.An_id()
		}
		p.SetState(2603)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SQLv1Antlr4ParserCOMMA {
			{
				p.SetState(2599)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2600)
				p.An_id()
			}

			p.SetState(2605)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInto_table_stmtContext is an interface to support dynamic dispatch.
type IInto_table_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTO() antlr.TerminalNode
	Into_simple_table_ref() IInto_simple_table_refContext
	Into_values_source() IInto_values_sourceContext
	INSERT() antlr.TerminalNode
	OR() antlr.TerminalNode
	ABORT() antlr.TerminalNode
	REVERT() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	UPSERT() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	Returning_columns_list() IReturning_columns_listContext

	// IsInto_table_stmtContext differentiates from other interfaces.
	IsInto_table_stmtContext()
}

type Into_table_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInto_table_stmtContext() *Into_table_stmtContext {
	var p = new(Into_table_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_into_table_stmt
	return p
}

func InitEmptyInto_table_stmtContext(p *Into_table_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_into_table_stmt
}

func (*Into_table_stmtContext) IsInto_table_stmtContext() {}

func NewInto_table_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Into_table_stmtContext {
	var p = new(Into_table_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_into_table_stmt

	return p
}

func (s *Into_table_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Into_table_stmtContext) INTO() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINTO, 0)
}

func (s *Into_table_stmtContext) Into_simple_table_ref() IInto_simple_table_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInto_simple_table_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInto_simple_table_refContext)
}

func (s *Into_table_stmtContext) Into_values_source() IInto_values_sourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInto_values_sourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInto_values_sourceContext)
}

func (s *Into_table_stmtContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINSERT, 0)
}

func (s *Into_table_stmtContext) OR() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOR, 0)
}

func (s *Into_table_stmtContext) ABORT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserABORT, 0)
}

func (s *Into_table_stmtContext) REVERT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREVERT, 0)
}

func (s *Into_table_stmtContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIGNORE, 0)
}

func (s *Into_table_stmtContext) UPSERT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUPSERT, 0)
}

func (s *Into_table_stmtContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREPLACE, 0)
}

func (s *Into_table_stmtContext) Returning_columns_list() IReturning_columns_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturning_columns_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturning_columns_listContext)
}

func (s *Into_table_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Into_table_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Into_table_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterInto_table_stmt(s)
	}
}

func (s *Into_table_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitInto_table_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Into_table_stmt() (localctx IInto_table_stmtContext) {
	localctx = NewInto_table_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, SQLv1Antlr4ParserRULE_into_table_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2620)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 252, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2608)
			p.Match(SQLv1Antlr4ParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(2609)
			p.Match(SQLv1Antlr4ParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2610)
			p.Match(SQLv1Antlr4ParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2611)
			p.Match(SQLv1Antlr4ParserABORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(2612)
			p.Match(SQLv1Antlr4ParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2613)
			p.Match(SQLv1Antlr4ParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2614)
			p.Match(SQLv1Antlr4ParserREVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(2615)
			p.Match(SQLv1Antlr4ParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2616)
			p.Match(SQLv1Antlr4ParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2617)
			p.Match(SQLv1Antlr4ParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		{
			p.SetState(2618)
			p.Match(SQLv1Antlr4ParserUPSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		{
			p.SetState(2619)
			p.Match(SQLv1Antlr4ParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(2622)
		p.Match(SQLv1Antlr4ParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2623)
		p.Into_simple_table_ref()
	}
	{
		p.SetState(2624)
		p.Into_values_source()
	}
	p.SetState(2626)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserRETURNING {
		{
			p.SetState(2625)
			p.Returning_columns_list()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInto_values_sourceContext is an interface to support dynamic dispatch.
type IInto_values_sourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Values_source() IValues_sourceContext
	Pure_column_list() IPure_column_listContext
	DEFAULT() antlr.TerminalNode
	VALUES() antlr.TerminalNode

	// IsInto_values_sourceContext differentiates from other interfaces.
	IsInto_values_sourceContext()
}

type Into_values_sourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInto_values_sourceContext() *Into_values_sourceContext {
	var p = new(Into_values_sourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_into_values_source
	return p
}

func InitEmptyInto_values_sourceContext(p *Into_values_sourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_into_values_source
}

func (*Into_values_sourceContext) IsInto_values_sourceContext() {}

func NewInto_values_sourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Into_values_sourceContext {
	var p = new(Into_values_sourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_into_values_source

	return p
}

func (s *Into_values_sourceContext) GetParser() antlr.Parser { return s.parser }

func (s *Into_values_sourceContext) Values_source() IValues_sourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValues_sourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValues_sourceContext)
}

func (s *Into_values_sourceContext) Pure_column_list() IPure_column_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPure_column_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPure_column_listContext)
}

func (s *Into_values_sourceContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDEFAULT, 0)
}

func (s *Into_values_sourceContext) VALUES() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserVALUES, 0)
}

func (s *Into_values_sourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Into_values_sourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Into_values_sourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterInto_values_source(s)
	}
}

func (s *Into_values_sourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitInto_values_source(s)
	}
}

func (p *SQLv1Antlr4Parser) Into_values_source() (localctx IInto_values_sourceContext) {
	localctx = NewInto_values_sourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, SQLv1Antlr4ParserRULE_into_values_source)
	p.SetState(2634)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserLPAREN, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserVALUES:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2629)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 254, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2628)
				p.Pure_column_list()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2631)
			p.Values_source()
		}

	case SQLv1Antlr4ParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2632)
			p.Match(SQLv1Antlr4ParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2633)
			p.Match(SQLv1Antlr4ParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValues_stmtContext is an interface to support dynamic dispatch.
type IValues_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VALUES() antlr.TerminalNode
	Values_source_row_list() IValues_source_row_listContext

	// IsValues_stmtContext differentiates from other interfaces.
	IsValues_stmtContext()
}

type Values_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValues_stmtContext() *Values_stmtContext {
	var p = new(Values_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_values_stmt
	return p
}

func InitEmptyValues_stmtContext(p *Values_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_values_stmt
}

func (*Values_stmtContext) IsValues_stmtContext() {}

func NewValues_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Values_stmtContext {
	var p = new(Values_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_values_stmt

	return p
}

func (s *Values_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Values_stmtContext) VALUES() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserVALUES, 0)
}

func (s *Values_stmtContext) Values_source_row_list() IValues_source_row_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValues_source_row_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValues_source_row_listContext)
}

func (s *Values_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Values_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Values_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterValues_stmt(s)
	}
}

func (s *Values_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitValues_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Values_stmt() (localctx IValues_stmtContext) {
	localctx = NewValues_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, SQLv1Antlr4ParserRULE_values_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2636)
		p.Match(SQLv1Antlr4ParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2637)
		p.Values_source_row_list()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValues_sourceContext is an interface to support dynamic dispatch.
type IValues_sourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Values_stmt() IValues_stmtContext
	Select_stmt() ISelect_stmtContext

	// IsValues_sourceContext differentiates from other interfaces.
	IsValues_sourceContext()
}

type Values_sourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValues_sourceContext() *Values_sourceContext {
	var p = new(Values_sourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_values_source
	return p
}

func InitEmptyValues_sourceContext(p *Values_sourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_values_source
}

func (*Values_sourceContext) IsValues_sourceContext() {}

func NewValues_sourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Values_sourceContext {
	var p = new(Values_sourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_values_source

	return p
}

func (s *Values_sourceContext) GetParser() antlr.Parser { return s.parser }

func (s *Values_sourceContext) Values_stmt() IValues_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValues_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValues_stmtContext)
}

func (s *Values_sourceContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Values_sourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Values_sourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Values_sourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterValues_source(s)
	}
}

func (s *Values_sourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitValues_source(s)
	}
}

func (p *SQLv1Antlr4Parser) Values_source() (localctx IValues_sourceContext) {
	localctx = NewValues_sourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, SQLv1Antlr4ParserRULE_values_source)
	p.SetState(2641)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserVALUES:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2639)
			p.Values_stmt()
		}

	case SQLv1Antlr4ParserLPAREN, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserSELECT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2640)
			p.Select_stmt()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValues_source_row_listContext is an interface to support dynamic dispatch.
type IValues_source_row_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllValues_source_row() []IValues_source_rowContext
	Values_source_row(i int) IValues_source_rowContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsValues_source_row_listContext differentiates from other interfaces.
	IsValues_source_row_listContext()
}

type Values_source_row_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValues_source_row_listContext() *Values_source_row_listContext {
	var p = new(Values_source_row_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_values_source_row_list
	return p
}

func InitEmptyValues_source_row_listContext(p *Values_source_row_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_values_source_row_list
}

func (*Values_source_row_listContext) IsValues_source_row_listContext() {}

func NewValues_source_row_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Values_source_row_listContext {
	var p = new(Values_source_row_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_values_source_row_list

	return p
}

func (s *Values_source_row_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Values_source_row_listContext) AllValues_source_row() []IValues_source_rowContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValues_source_rowContext); ok {
			len++
		}
	}

	tst := make([]IValues_source_rowContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValues_source_rowContext); ok {
			tst[i] = t.(IValues_source_rowContext)
			i++
		}
	}

	return tst
}

func (s *Values_source_row_listContext) Values_source_row(i int) IValues_source_rowContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValues_source_rowContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValues_source_rowContext)
}

func (s *Values_source_row_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Values_source_row_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Values_source_row_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Values_source_row_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Values_source_row_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterValues_source_row_list(s)
	}
}

func (s *Values_source_row_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitValues_source_row_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Values_source_row_list() (localctx IValues_source_row_listContext) {
	localctx = NewValues_source_row_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, SQLv1Antlr4ParserRULE_values_source_row_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2643)
		p.Values_source_row()
	}
	p.SetState(2648)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(2644)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2645)
			p.Values_source_row()
		}

		p.SetState(2650)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValues_source_rowContext is an interface to support dynamic dispatch.
type IValues_source_rowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Expr_list() IExpr_listContext
	RPAREN() antlr.TerminalNode

	// IsValues_source_rowContext differentiates from other interfaces.
	IsValues_source_rowContext()
}

type Values_source_rowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValues_source_rowContext() *Values_source_rowContext {
	var p = new(Values_source_rowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_values_source_row
	return p
}

func InitEmptyValues_source_rowContext(p *Values_source_rowContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_values_source_row
}

func (*Values_source_rowContext) IsValues_source_rowContext() {}

func NewValues_source_rowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Values_source_rowContext {
	var p = new(Values_source_rowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_values_source_row

	return p
}

func (s *Values_source_rowContext) GetParser() antlr.Parser { return s.parser }

func (s *Values_source_rowContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Values_source_rowContext) Expr_list() IExpr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_listContext)
}

func (s *Values_source_rowContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Values_source_rowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Values_source_rowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Values_source_rowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterValues_source_row(s)
	}
}

func (s *Values_source_rowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitValues_source_row(s)
	}
}

func (p *SQLv1Antlr4Parser) Values_source_row() (localctx IValues_source_rowContext) {
	localctx = NewValues_source_rowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, SQLv1Antlr4ParserRULE_values_source_row)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2651)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2652)
		p.Expr_list()
	}
	{
		p.SetState(2653)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimple_values_sourceContext is an interface to support dynamic dispatch.
type ISimple_values_sourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr_list() IExpr_listContext
	Select_stmt() ISelect_stmtContext

	// IsSimple_values_sourceContext differentiates from other interfaces.
	IsSimple_values_sourceContext()
}

type Simple_values_sourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_values_sourceContext() *Simple_values_sourceContext {
	var p = new(Simple_values_sourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_simple_values_source
	return p
}

func InitEmptySimple_values_sourceContext(p *Simple_values_sourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_simple_values_source
}

func (*Simple_values_sourceContext) IsSimple_values_sourceContext() {}

func NewSimple_values_sourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_values_sourceContext {
	var p = new(Simple_values_sourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_simple_values_source

	return p
}

func (s *Simple_values_sourceContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_values_sourceContext) Expr_list() IExpr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_listContext)
}

func (s *Simple_values_sourceContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Simple_values_sourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_values_sourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_values_sourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSimple_values_source(s)
	}
}

func (s *Simple_values_sourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSimple_values_source(s)
	}
}

func (p *SQLv1Antlr4Parser) Simple_values_source() (localctx ISimple_values_sourceContext) {
	localctx = NewSimple_values_sourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, SQLv1Antlr4ParserRULE_simple_values_source)
	p.SetState(2657)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 258, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2655)
			p.Expr_list()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2656)
			p.Select_stmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_external_data_source_stmtContext is an interface to support dynamic dispatch.
type ICreate_external_data_source_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	DATA() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	Object_ref() IObject_refContext
	With_table_settings() IWith_table_settingsContext
	OR() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsCreate_external_data_source_stmtContext differentiates from other interfaces.
	IsCreate_external_data_source_stmtContext()
}

type Create_external_data_source_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_external_data_source_stmtContext() *Create_external_data_source_stmtContext {
	var p = new(Create_external_data_source_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_external_data_source_stmt
	return p
}

func InitEmptyCreate_external_data_source_stmtContext(p *Create_external_data_source_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_external_data_source_stmt
}

func (*Create_external_data_source_stmtContext) IsCreate_external_data_source_stmtContext() {}

func NewCreate_external_data_source_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_external_data_source_stmtContext {
	var p = new(Create_external_data_source_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_external_data_source_stmt

	return p
}

func (s *Create_external_data_source_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_external_data_source_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCREATE, 0)
}

func (s *Create_external_data_source_stmtContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXTERNAL, 0)
}

func (s *Create_external_data_source_stmtContext) DATA() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDATA, 0)
}

func (s *Create_external_data_source_stmtContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSOURCE, 0)
}

func (s *Create_external_data_source_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Create_external_data_source_stmtContext) With_table_settings() IWith_table_settingsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_table_settingsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_table_settingsContext)
}

func (s *Create_external_data_source_stmtContext) OR() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOR, 0)
}

func (s *Create_external_data_source_stmtContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREPLACE, 0)
}

func (s *Create_external_data_source_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIF, 0)
}

func (s *Create_external_data_source_stmtContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNOT, 0)
}

func (s *Create_external_data_source_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXISTS, 0)
}

func (s *Create_external_data_source_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_external_data_source_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_external_data_source_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterCreate_external_data_source_stmt(s)
	}
}

func (s *Create_external_data_source_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitCreate_external_data_source_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Create_external_data_source_stmt() (localctx ICreate_external_data_source_stmtContext) {
	localctx = NewCreate_external_data_source_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, SQLv1Antlr4ParserRULE_create_external_data_source_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2659)
		p.Match(SQLv1Antlr4ParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2662)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserOR {
		{
			p.SetState(2660)
			p.Match(SQLv1Antlr4ParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2661)
			p.Match(SQLv1Antlr4ParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2664)
		p.Match(SQLv1Antlr4ParserEXTERNAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2665)
		p.Match(SQLv1Antlr4ParserDATA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2666)
		p.Match(SQLv1Antlr4ParserSOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2670)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 260, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2667)
			p.Match(SQLv1Antlr4ParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2668)
			p.Match(SQLv1Antlr4ParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2669)
			p.Match(SQLv1Antlr4ParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2672)
		p.Object_ref()
	}
	{
		p.SetState(2673)
		p.With_table_settings()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_external_data_source_stmtContext is an interface to support dynamic dispatch.
type IAlter_external_data_source_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	DATA() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	Object_ref() IObject_refContext
	AllAlter_external_data_source_action() []IAlter_external_data_source_actionContext
	Alter_external_data_source_action(i int) IAlter_external_data_source_actionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlter_external_data_source_stmtContext differentiates from other interfaces.
	IsAlter_external_data_source_stmtContext()
}

type Alter_external_data_source_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_external_data_source_stmtContext() *Alter_external_data_source_stmtContext {
	var p = new(Alter_external_data_source_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_external_data_source_stmt
	return p
}

func InitEmptyAlter_external_data_source_stmtContext(p *Alter_external_data_source_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_external_data_source_stmt
}

func (*Alter_external_data_source_stmtContext) IsAlter_external_data_source_stmtContext() {}

func NewAlter_external_data_source_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_external_data_source_stmtContext {
	var p = new(Alter_external_data_source_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_external_data_source_stmt

	return p
}

func (s *Alter_external_data_source_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_external_data_source_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserALTER, 0)
}

func (s *Alter_external_data_source_stmtContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXTERNAL, 0)
}

func (s *Alter_external_data_source_stmtContext) DATA() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDATA, 0)
}

func (s *Alter_external_data_source_stmtContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSOURCE, 0)
}

func (s *Alter_external_data_source_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Alter_external_data_source_stmtContext) AllAlter_external_data_source_action() []IAlter_external_data_source_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlter_external_data_source_actionContext); ok {
			len++
		}
	}

	tst := make([]IAlter_external_data_source_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlter_external_data_source_actionContext); ok {
			tst[i] = t.(IAlter_external_data_source_actionContext)
			i++
		}
	}

	return tst
}

func (s *Alter_external_data_source_stmtContext) Alter_external_data_source_action(i int) IAlter_external_data_source_actionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_external_data_source_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_external_data_source_actionContext)
}

func (s *Alter_external_data_source_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Alter_external_data_source_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Alter_external_data_source_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_external_data_source_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_external_data_source_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_external_data_source_stmt(s)
	}
}

func (s *Alter_external_data_source_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_external_data_source_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_external_data_source_stmt() (localctx IAlter_external_data_source_stmtContext) {
	localctx = NewAlter_external_data_source_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, SQLv1Antlr4ParserRULE_alter_external_data_source_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2675)
		p.Match(SQLv1Antlr4ParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2676)
		p.Match(SQLv1Antlr4ParserEXTERNAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2677)
		p.Match(SQLv1Antlr4ParserDATA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2678)
		p.Match(SQLv1Antlr4ParserSOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2679)
		p.Object_ref()
	}
	{
		p.SetState(2680)
		p.Alter_external_data_source_action()
	}
	p.SetState(2685)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(2681)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2682)
			p.Alter_external_data_source_action()
		}

		p.SetState(2687)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_external_data_source_actionContext is an interface to support dynamic dispatch.
type IAlter_external_data_source_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Alter_table_set_table_setting_uncompat() IAlter_table_set_table_setting_uncompatContext
	Alter_table_set_table_setting_compat() IAlter_table_set_table_setting_compatContext
	Alter_table_reset_table_setting() IAlter_table_reset_table_settingContext

	// IsAlter_external_data_source_actionContext differentiates from other interfaces.
	IsAlter_external_data_source_actionContext()
}

type Alter_external_data_source_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_external_data_source_actionContext() *Alter_external_data_source_actionContext {
	var p = new(Alter_external_data_source_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_external_data_source_action
	return p
}

func InitEmptyAlter_external_data_source_actionContext(p *Alter_external_data_source_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_external_data_source_action
}

func (*Alter_external_data_source_actionContext) IsAlter_external_data_source_actionContext() {}

func NewAlter_external_data_source_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_external_data_source_actionContext {
	var p = new(Alter_external_data_source_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_external_data_source_action

	return p
}

func (s *Alter_external_data_source_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_external_data_source_actionContext) Alter_table_set_table_setting_uncompat() IAlter_table_set_table_setting_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_set_table_setting_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_set_table_setting_uncompatContext)
}

func (s *Alter_external_data_source_actionContext) Alter_table_set_table_setting_compat() IAlter_table_set_table_setting_compatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_set_table_setting_compatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_set_table_setting_compatContext)
}

func (s *Alter_external_data_source_actionContext) Alter_table_reset_table_setting() IAlter_table_reset_table_settingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_reset_table_settingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_reset_table_settingContext)
}

func (s *Alter_external_data_source_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_external_data_source_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_external_data_source_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_external_data_source_action(s)
	}
}

func (s *Alter_external_data_source_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_external_data_source_action(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_external_data_source_action() (localctx IAlter_external_data_source_actionContext) {
	localctx = NewAlter_external_data_source_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, SQLv1Antlr4ParserRULE_alter_external_data_source_action)
	p.SetState(2691)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 262, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2688)
			p.Alter_table_set_table_setting_uncompat()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2689)
			p.Alter_table_set_table_setting_compat()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2690)
			p.Alter_table_reset_table_setting()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_external_data_source_stmtContext is an interface to support dynamic dispatch.
type IDrop_external_data_source_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	DATA() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	Object_ref() IObject_refContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDrop_external_data_source_stmtContext differentiates from other interfaces.
	IsDrop_external_data_source_stmtContext()
}

type Drop_external_data_source_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_external_data_source_stmtContext() *Drop_external_data_source_stmtContext {
	var p = new(Drop_external_data_source_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_external_data_source_stmt
	return p
}

func InitEmptyDrop_external_data_source_stmtContext(p *Drop_external_data_source_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_external_data_source_stmt
}

func (*Drop_external_data_source_stmtContext) IsDrop_external_data_source_stmtContext() {}

func NewDrop_external_data_source_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_external_data_source_stmtContext {
	var p = new(Drop_external_data_source_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_external_data_source_stmt

	return p
}

func (s *Drop_external_data_source_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_external_data_source_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDROP, 0)
}

func (s *Drop_external_data_source_stmtContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXTERNAL, 0)
}

func (s *Drop_external_data_source_stmtContext) DATA() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDATA, 0)
}

func (s *Drop_external_data_source_stmtContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSOURCE, 0)
}

func (s *Drop_external_data_source_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Drop_external_data_source_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIF, 0)
}

func (s *Drop_external_data_source_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXISTS, 0)
}

func (s *Drop_external_data_source_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_external_data_source_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_external_data_source_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterDrop_external_data_source_stmt(s)
	}
}

func (s *Drop_external_data_source_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitDrop_external_data_source_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Drop_external_data_source_stmt() (localctx IDrop_external_data_source_stmtContext) {
	localctx = NewDrop_external_data_source_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, SQLv1Antlr4ParserRULE_drop_external_data_source_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2693)
		p.Match(SQLv1Antlr4ParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2694)
		p.Match(SQLv1Antlr4ParserEXTERNAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2695)
		p.Match(SQLv1Antlr4ParserDATA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2696)
		p.Match(SQLv1Antlr4ParserSOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2699)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 263, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2697)
			p.Match(SQLv1Antlr4ParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2698)
			p.Match(SQLv1Antlr4ParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2701)
		p.Object_ref()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_view_stmtContext is an interface to support dynamic dispatch.
type ICreate_view_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	Object_ref() IObject_refContext
	AS() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	Create_object_features() ICreate_object_featuresContext

	// IsCreate_view_stmtContext differentiates from other interfaces.
	IsCreate_view_stmtContext()
}

type Create_view_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_view_stmtContext() *Create_view_stmtContext {
	var p = new(Create_view_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_view_stmt
	return p
}

func InitEmptyCreate_view_stmtContext(p *Create_view_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_view_stmt
}

func (*Create_view_stmtContext) IsCreate_view_stmtContext() {}

func NewCreate_view_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_view_stmtContext {
	var p = new(Create_view_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_view_stmt

	return p
}

func (s *Create_view_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_view_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCREATE, 0)
}

func (s *Create_view_stmtContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserVIEW, 0)
}

func (s *Create_view_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Create_view_stmtContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAS, 0)
}

func (s *Create_view_stmtContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Create_view_stmtContext) Create_object_features() ICreate_object_featuresContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_object_featuresContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_object_featuresContext)
}

func (s *Create_view_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_view_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_view_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterCreate_view_stmt(s)
	}
}

func (s *Create_view_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitCreate_view_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Create_view_stmt() (localctx ICreate_view_stmtContext) {
	localctx = NewCreate_view_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, SQLv1Antlr4ParserRULE_create_view_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2703)
		p.Match(SQLv1Antlr4ParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2704)
		p.Match(SQLv1Antlr4ParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2705)
		p.Object_ref()
	}
	p.SetState(2707)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserWITH {
		{
			p.SetState(2706)
			p.Create_object_features()
		}

	}
	{
		p.SetState(2709)
		p.Match(SQLv1Antlr4ParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2710)
		p.Select_stmt()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_view_stmtContext is an interface to support dynamic dispatch.
type IDrop_view_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	Object_ref() IObject_refContext

	// IsDrop_view_stmtContext differentiates from other interfaces.
	IsDrop_view_stmtContext()
}

type Drop_view_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_view_stmtContext() *Drop_view_stmtContext {
	var p = new(Drop_view_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_view_stmt
	return p
}

func InitEmptyDrop_view_stmtContext(p *Drop_view_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_view_stmt
}

func (*Drop_view_stmtContext) IsDrop_view_stmtContext() {}

func NewDrop_view_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_view_stmtContext {
	var p = new(Drop_view_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_view_stmt

	return p
}

func (s *Drop_view_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_view_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDROP, 0)
}

func (s *Drop_view_stmtContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserVIEW, 0)
}

func (s *Drop_view_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Drop_view_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_view_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_view_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterDrop_view_stmt(s)
	}
}

func (s *Drop_view_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitDrop_view_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Drop_view_stmt() (localctx IDrop_view_stmtContext) {
	localctx = NewDrop_view_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, SQLv1Antlr4ParserRULE_drop_view_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2712)
		p.Match(SQLv1Antlr4ParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2713)
		p.Match(SQLv1Antlr4ParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2714)
		p.Object_ref()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpsert_object_stmtContext is an interface to support dynamic dispatch.
type IUpsert_object_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UPSERT() antlr.TerminalNode
	OBJECT() antlr.TerminalNode
	Object_ref() IObject_refContext
	LPAREN() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	Object_type_ref() IObject_type_refContext
	RPAREN() antlr.TerminalNode
	Create_object_features() ICreate_object_featuresContext

	// IsUpsert_object_stmtContext differentiates from other interfaces.
	IsUpsert_object_stmtContext()
}

type Upsert_object_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpsert_object_stmtContext() *Upsert_object_stmtContext {
	var p = new(Upsert_object_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_upsert_object_stmt
	return p
}

func InitEmptyUpsert_object_stmtContext(p *Upsert_object_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_upsert_object_stmt
}

func (*Upsert_object_stmtContext) IsUpsert_object_stmtContext() {}

func NewUpsert_object_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Upsert_object_stmtContext {
	var p = new(Upsert_object_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_upsert_object_stmt

	return p
}

func (s *Upsert_object_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Upsert_object_stmtContext) UPSERT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUPSERT, 0)
}

func (s *Upsert_object_stmtContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOBJECT, 0)
}

func (s *Upsert_object_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Upsert_object_stmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Upsert_object_stmtContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTYPE, 0)
}

func (s *Upsert_object_stmtContext) Object_type_ref() IObject_type_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_type_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_type_refContext)
}

func (s *Upsert_object_stmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Upsert_object_stmtContext) Create_object_features() ICreate_object_featuresContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_object_featuresContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_object_featuresContext)
}

func (s *Upsert_object_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Upsert_object_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Upsert_object_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterUpsert_object_stmt(s)
	}
}

func (s *Upsert_object_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitUpsert_object_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Upsert_object_stmt() (localctx IUpsert_object_stmtContext) {
	localctx = NewUpsert_object_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, SQLv1Antlr4ParserRULE_upsert_object_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2716)
		p.Match(SQLv1Antlr4ParserUPSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2717)
		p.Match(SQLv1Antlr4ParserOBJECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2718)
		p.Object_ref()
	}
	{
		p.SetState(2719)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2720)
		p.Match(SQLv1Antlr4ParserTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2721)
		p.Object_type_ref()
	}
	{
		p.SetState(2722)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2724)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserWITH {
		{
			p.SetState(2723)
			p.Create_object_features()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_object_stmtContext is an interface to support dynamic dispatch.
type ICreate_object_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	OBJECT() antlr.TerminalNode
	Object_ref() IObject_refContext
	LPAREN() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	Object_type_ref() IObject_type_refContext
	RPAREN() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	Create_object_features() ICreate_object_featuresContext

	// IsCreate_object_stmtContext differentiates from other interfaces.
	IsCreate_object_stmtContext()
}

type Create_object_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_object_stmtContext() *Create_object_stmtContext {
	var p = new(Create_object_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_object_stmt
	return p
}

func InitEmptyCreate_object_stmtContext(p *Create_object_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_object_stmt
}

func (*Create_object_stmtContext) IsCreate_object_stmtContext() {}

func NewCreate_object_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_object_stmtContext {
	var p = new(Create_object_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_object_stmt

	return p
}

func (s *Create_object_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_object_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCREATE, 0)
}

func (s *Create_object_stmtContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOBJECT, 0)
}

func (s *Create_object_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Create_object_stmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Create_object_stmtContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTYPE, 0)
}

func (s *Create_object_stmtContext) Object_type_ref() IObject_type_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_type_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_type_refContext)
}

func (s *Create_object_stmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Create_object_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIF, 0)
}

func (s *Create_object_stmtContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNOT, 0)
}

func (s *Create_object_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXISTS, 0)
}

func (s *Create_object_stmtContext) Create_object_features() ICreate_object_featuresContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_object_featuresContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_object_featuresContext)
}

func (s *Create_object_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_object_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_object_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterCreate_object_stmt(s)
	}
}

func (s *Create_object_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitCreate_object_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Create_object_stmt() (localctx ICreate_object_stmtContext) {
	localctx = NewCreate_object_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, SQLv1Antlr4ParserRULE_create_object_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2726)
		p.Match(SQLv1Antlr4ParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2727)
		p.Match(SQLv1Antlr4ParserOBJECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2731)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 266, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2728)
			p.Match(SQLv1Antlr4ParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2729)
			p.Match(SQLv1Antlr4ParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2730)
			p.Match(SQLv1Antlr4ParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2733)
		p.Object_ref()
	}
	{
		p.SetState(2734)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2735)
		p.Match(SQLv1Antlr4ParserTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2736)
		p.Object_type_ref()
	}
	{
		p.SetState(2737)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2739)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserWITH {
		{
			p.SetState(2738)
			p.Create_object_features()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_object_featuresContext is an interface to support dynamic dispatch.
type ICreate_object_featuresContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	Object_features() IObject_featuresContext

	// IsCreate_object_featuresContext differentiates from other interfaces.
	IsCreate_object_featuresContext()
}

type Create_object_featuresContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_object_featuresContext() *Create_object_featuresContext {
	var p = new(Create_object_featuresContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_object_features
	return p
}

func InitEmptyCreate_object_featuresContext(p *Create_object_featuresContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_object_features
}

func (*Create_object_featuresContext) IsCreate_object_featuresContext() {}

func NewCreate_object_featuresContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_object_featuresContext {
	var p = new(Create_object_featuresContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_object_features

	return p
}

func (s *Create_object_featuresContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_object_featuresContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWITH, 0)
}

func (s *Create_object_featuresContext) Object_features() IObject_featuresContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_featuresContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_featuresContext)
}

func (s *Create_object_featuresContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_object_featuresContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_object_featuresContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterCreate_object_features(s)
	}
}

func (s *Create_object_featuresContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitCreate_object_features(s)
	}
}

func (p *SQLv1Antlr4Parser) Create_object_features() (localctx ICreate_object_featuresContext) {
	localctx = NewCreate_object_featuresContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, SQLv1Antlr4ParserRULE_create_object_features)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2741)
		p.Match(SQLv1Antlr4ParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2742)
		p.Object_features()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_object_stmtContext is an interface to support dynamic dispatch.
type IAlter_object_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	OBJECT() antlr.TerminalNode
	Object_ref() IObject_refContext
	LPAREN() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	Object_type_ref() IObject_type_refContext
	RPAREN() antlr.TerminalNode
	Alter_object_features() IAlter_object_featuresContext

	// IsAlter_object_stmtContext differentiates from other interfaces.
	IsAlter_object_stmtContext()
}

type Alter_object_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_object_stmtContext() *Alter_object_stmtContext {
	var p = new(Alter_object_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_object_stmt
	return p
}

func InitEmptyAlter_object_stmtContext(p *Alter_object_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_object_stmt
}

func (*Alter_object_stmtContext) IsAlter_object_stmtContext() {}

func NewAlter_object_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_object_stmtContext {
	var p = new(Alter_object_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_object_stmt

	return p
}

func (s *Alter_object_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_object_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserALTER, 0)
}

func (s *Alter_object_stmtContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOBJECT, 0)
}

func (s *Alter_object_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Alter_object_stmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Alter_object_stmtContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTYPE, 0)
}

func (s *Alter_object_stmtContext) Object_type_ref() IObject_type_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_type_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_type_refContext)
}

func (s *Alter_object_stmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Alter_object_stmtContext) Alter_object_features() IAlter_object_featuresContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_object_featuresContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_object_featuresContext)
}

func (s *Alter_object_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_object_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_object_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_object_stmt(s)
	}
}

func (s *Alter_object_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_object_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_object_stmt() (localctx IAlter_object_stmtContext) {
	localctx = NewAlter_object_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, SQLv1Antlr4ParserRULE_alter_object_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2744)
		p.Match(SQLv1Antlr4ParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2745)
		p.Match(SQLv1Antlr4ParserOBJECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2746)
		p.Object_ref()
	}
	{
		p.SetState(2747)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2748)
		p.Match(SQLv1Antlr4ParserTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2749)
		p.Object_type_ref()
	}
	{
		p.SetState(2750)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2751)
		p.Alter_object_features()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_object_featuresContext is an interface to support dynamic dispatch.
type IAlter_object_featuresContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	Object_features() IObject_featuresContext

	// IsAlter_object_featuresContext differentiates from other interfaces.
	IsAlter_object_featuresContext()
}

type Alter_object_featuresContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_object_featuresContext() *Alter_object_featuresContext {
	var p = new(Alter_object_featuresContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_object_features
	return p
}

func InitEmptyAlter_object_featuresContext(p *Alter_object_featuresContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_object_features
}

func (*Alter_object_featuresContext) IsAlter_object_featuresContext() {}

func NewAlter_object_featuresContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_object_featuresContext {
	var p = new(Alter_object_featuresContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_object_features

	return p
}

func (s *Alter_object_featuresContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_object_featuresContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSET, 0)
}

func (s *Alter_object_featuresContext) Object_features() IObject_featuresContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_featuresContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_featuresContext)
}

func (s *Alter_object_featuresContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_object_featuresContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_object_featuresContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_object_features(s)
	}
}

func (s *Alter_object_featuresContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_object_features(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_object_features() (localctx IAlter_object_featuresContext) {
	localctx = NewAlter_object_featuresContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, SQLv1Antlr4ParserRULE_alter_object_features)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2753)
		p.Match(SQLv1Antlr4ParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2754)
		p.Object_features()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_object_stmtContext is an interface to support dynamic dispatch.
type IDrop_object_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	OBJECT() antlr.TerminalNode
	Object_ref() IObject_refContext
	LPAREN() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	Object_type_ref() IObject_type_refContext
	RPAREN() antlr.TerminalNode
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	Drop_object_features() IDrop_object_featuresContext

	// IsDrop_object_stmtContext differentiates from other interfaces.
	IsDrop_object_stmtContext()
}

type Drop_object_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_object_stmtContext() *Drop_object_stmtContext {
	var p = new(Drop_object_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_object_stmt
	return p
}

func InitEmptyDrop_object_stmtContext(p *Drop_object_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_object_stmt
}

func (*Drop_object_stmtContext) IsDrop_object_stmtContext() {}

func NewDrop_object_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_object_stmtContext {
	var p = new(Drop_object_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_object_stmt

	return p
}

func (s *Drop_object_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_object_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDROP, 0)
}

func (s *Drop_object_stmtContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOBJECT, 0)
}

func (s *Drop_object_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Drop_object_stmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Drop_object_stmtContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTYPE, 0)
}

func (s *Drop_object_stmtContext) Object_type_ref() IObject_type_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_type_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_type_refContext)
}

func (s *Drop_object_stmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Drop_object_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIF, 0)
}

func (s *Drop_object_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXISTS, 0)
}

func (s *Drop_object_stmtContext) Drop_object_features() IDrop_object_featuresContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_object_featuresContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_object_featuresContext)
}

func (s *Drop_object_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_object_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_object_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterDrop_object_stmt(s)
	}
}

func (s *Drop_object_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitDrop_object_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Drop_object_stmt() (localctx IDrop_object_stmtContext) {
	localctx = NewDrop_object_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, SQLv1Antlr4ParserRULE_drop_object_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2756)
		p.Match(SQLv1Antlr4ParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2757)
		p.Match(SQLv1Antlr4ParserOBJECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2760)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 268, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2758)
			p.Match(SQLv1Antlr4ParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2759)
			p.Match(SQLv1Antlr4ParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2762)
		p.Object_ref()
	}
	{
		p.SetState(2763)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2764)
		p.Match(SQLv1Antlr4ParserTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2765)
		p.Object_type_ref()
	}
	{
		p.SetState(2766)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2768)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserWITH {
		{
			p.SetState(2767)
			p.Drop_object_features()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_object_featuresContext is an interface to support dynamic dispatch.
type IDrop_object_featuresContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	Object_features() IObject_featuresContext

	// IsDrop_object_featuresContext differentiates from other interfaces.
	IsDrop_object_featuresContext()
}

type Drop_object_featuresContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_object_featuresContext() *Drop_object_featuresContext {
	var p = new(Drop_object_featuresContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_object_features
	return p
}

func InitEmptyDrop_object_featuresContext(p *Drop_object_featuresContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_object_features
}

func (*Drop_object_featuresContext) IsDrop_object_featuresContext() {}

func NewDrop_object_featuresContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_object_featuresContext {
	var p = new(Drop_object_featuresContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_object_features

	return p
}

func (s *Drop_object_featuresContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_object_featuresContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWITH, 0)
}

func (s *Drop_object_featuresContext) Object_features() IObject_featuresContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_featuresContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_featuresContext)
}

func (s *Drop_object_featuresContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_object_featuresContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_object_featuresContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterDrop_object_features(s)
	}
}

func (s *Drop_object_featuresContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitDrop_object_features(s)
	}
}

func (p *SQLv1Antlr4Parser) Drop_object_features() (localctx IDrop_object_featuresContext) {
	localctx = NewDrop_object_featuresContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, SQLv1Antlr4ParserRULE_drop_object_features)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2770)
		p.Match(SQLv1Antlr4ParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2771)
		p.Object_features()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObject_feature_valueContext is an interface to support dynamic dispatch.
type IObject_feature_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_or_type() IId_or_typeContext
	Bind_parameter() IBind_parameterContext
	STRING_VALUE() antlr.TerminalNode
	Bool_value() IBool_valueContext

	// IsObject_feature_valueContext differentiates from other interfaces.
	IsObject_feature_valueContext()
}

type Object_feature_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObject_feature_valueContext() *Object_feature_valueContext {
	var p = new(Object_feature_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_object_feature_value
	return p
}

func InitEmptyObject_feature_valueContext(p *Object_feature_valueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_object_feature_value
}

func (*Object_feature_valueContext) IsObject_feature_valueContext() {}

func NewObject_feature_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Object_feature_valueContext {
	var p = new(Object_feature_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_object_feature_value

	return p
}

func (s *Object_feature_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Object_feature_valueContext) Id_or_type() IId_or_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_or_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_or_typeContext)
}

func (s *Object_feature_valueContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Object_feature_valueContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRING_VALUE, 0)
}

func (s *Object_feature_valueContext) Bool_value() IBool_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_valueContext)
}

func (s *Object_feature_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_feature_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Object_feature_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterObject_feature_value(s)
	}
}

func (s *Object_feature_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitObject_feature_value(s)
	}
}

func (p *SQLv1Antlr4Parser) Object_feature_value() (localctx IObject_feature_valueContext) {
	localctx = NewObject_feature_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, SQLv1Antlr4ParserRULE_object_feature_value)
	p.SetState(2777)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALL, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserANY, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCALLABLE, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDICT, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserENUM, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFLOW, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserLIST, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOPTIONAL, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESOURCE, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSET, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSTREAM, SQLv1Antlr4ParserSTRUCT, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTAGGED, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTUPLE, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVARIANT, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWITHOUT, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2773)
			p.Id_or_type()
		}

	case SQLv1Antlr4ParserDOLLAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2774)
			p.Bind_parameter()
		}

	case SQLv1Antlr4ParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2775)
			p.Match(SQLv1Antlr4ParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserFALSE, SQLv1Antlr4ParserTRUE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2776)
			p.Bool_value()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObject_feature_kvContext is an interface to support dynamic dispatch.
type IObject_feature_kvContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id_or_type() IAn_id_or_typeContext
	EQUALS() antlr.TerminalNode
	Object_feature_value() IObject_feature_valueContext

	// IsObject_feature_kvContext differentiates from other interfaces.
	IsObject_feature_kvContext()
}

type Object_feature_kvContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObject_feature_kvContext() *Object_feature_kvContext {
	var p = new(Object_feature_kvContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_object_feature_kv
	return p
}

func InitEmptyObject_feature_kvContext(p *Object_feature_kvContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_object_feature_kv
}

func (*Object_feature_kvContext) IsObject_feature_kvContext() {}

func NewObject_feature_kvContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Object_feature_kvContext {
	var p = new(Object_feature_kvContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_object_feature_kv

	return p
}

func (s *Object_feature_kvContext) GetParser() antlr.Parser { return s.parser }

func (s *Object_feature_kvContext) An_id_or_type() IAn_id_or_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_or_typeContext)
}

func (s *Object_feature_kvContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEQUALS, 0)
}

func (s *Object_feature_kvContext) Object_feature_value() IObject_feature_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_feature_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_feature_valueContext)
}

func (s *Object_feature_kvContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_feature_kvContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Object_feature_kvContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterObject_feature_kv(s)
	}
}

func (s *Object_feature_kvContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitObject_feature_kv(s)
	}
}

func (p *SQLv1Antlr4Parser) Object_feature_kv() (localctx IObject_feature_kvContext) {
	localctx = NewObject_feature_kvContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, SQLv1Antlr4ParserRULE_object_feature_kv)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2779)
		p.An_id_or_type()
	}
	{
		p.SetState(2780)
		p.Match(SQLv1Antlr4ParserEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2781)
		p.Object_feature_value()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObject_feature_flagContext is an interface to support dynamic dispatch.
type IObject_feature_flagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id_or_type() IAn_id_or_typeContext

	// IsObject_feature_flagContext differentiates from other interfaces.
	IsObject_feature_flagContext()
}

type Object_feature_flagContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObject_feature_flagContext() *Object_feature_flagContext {
	var p = new(Object_feature_flagContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_object_feature_flag
	return p
}

func InitEmptyObject_feature_flagContext(p *Object_feature_flagContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_object_feature_flag
}

func (*Object_feature_flagContext) IsObject_feature_flagContext() {}

func NewObject_feature_flagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Object_feature_flagContext {
	var p = new(Object_feature_flagContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_object_feature_flag

	return p
}

func (s *Object_feature_flagContext) GetParser() antlr.Parser { return s.parser }

func (s *Object_feature_flagContext) An_id_or_type() IAn_id_or_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_or_typeContext)
}

func (s *Object_feature_flagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_feature_flagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Object_feature_flagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterObject_feature_flag(s)
	}
}

func (s *Object_feature_flagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitObject_feature_flag(s)
	}
}

func (p *SQLv1Antlr4Parser) Object_feature_flag() (localctx IObject_feature_flagContext) {
	localctx = NewObject_feature_flagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, SQLv1Antlr4ParserRULE_object_feature_flag)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2783)
		p.An_id_or_type()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObject_featureContext is an interface to support dynamic dispatch.
type IObject_featureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Object_feature_kv() IObject_feature_kvContext
	Object_feature_flag() IObject_feature_flagContext

	// IsObject_featureContext differentiates from other interfaces.
	IsObject_featureContext()
}

type Object_featureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObject_featureContext() *Object_featureContext {
	var p = new(Object_featureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_object_feature
	return p
}

func InitEmptyObject_featureContext(p *Object_featureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_object_feature
}

func (*Object_featureContext) IsObject_featureContext() {}

func NewObject_featureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Object_featureContext {
	var p = new(Object_featureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_object_feature

	return p
}

func (s *Object_featureContext) GetParser() antlr.Parser { return s.parser }

func (s *Object_featureContext) Object_feature_kv() IObject_feature_kvContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_feature_kvContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_feature_kvContext)
}

func (s *Object_featureContext) Object_feature_flag() IObject_feature_flagContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_feature_flagContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_feature_flagContext)
}

func (s *Object_featureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_featureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Object_featureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterObject_feature(s)
	}
}

func (s *Object_featureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitObject_feature(s)
	}
}

func (p *SQLv1Antlr4Parser) Object_feature() (localctx IObject_featureContext) {
	localctx = NewObject_featureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, SQLv1Antlr4ParserRULE_object_feature)
	p.SetState(2787)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 271, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2785)
			p.Object_feature_kv()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2786)
			p.Object_feature_flag()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObject_featuresContext is an interface to support dynamic dispatch.
type IObject_featuresContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllObject_feature() []IObject_featureContext
	Object_feature(i int) IObject_featureContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsObject_featuresContext differentiates from other interfaces.
	IsObject_featuresContext()
}

type Object_featuresContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObject_featuresContext() *Object_featuresContext {
	var p = new(Object_featuresContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_object_features
	return p
}

func InitEmptyObject_featuresContext(p *Object_featuresContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_object_features
}

func (*Object_featuresContext) IsObject_featuresContext() {}

func NewObject_featuresContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Object_featuresContext {
	var p = new(Object_featuresContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_object_features

	return p
}

func (s *Object_featuresContext) GetParser() antlr.Parser { return s.parser }

func (s *Object_featuresContext) AllObject_feature() []IObject_featureContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IObject_featureContext); ok {
			len++
		}
	}

	tst := make([]IObject_featureContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IObject_featureContext); ok {
			tst[i] = t.(IObject_featureContext)
			i++
		}
	}

	return tst
}

func (s *Object_featuresContext) Object_feature(i int) IObject_featureContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_featureContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_featureContext)
}

func (s *Object_featuresContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Object_featuresContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Object_featuresContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Object_featuresContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Object_featuresContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_featuresContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Object_featuresContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterObject_features(s)
	}
}

func (s *Object_featuresContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitObject_features(s)
	}
}

func (p *SQLv1Antlr4Parser) Object_features() (localctx IObject_featuresContext) {
	localctx = NewObject_featuresContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, SQLv1Antlr4ParserRULE_object_features)
	var _la int

	p.SetState(2801)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALL, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserANY, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCALLABLE, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDICT, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserENUM, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFLOW, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserLIST, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOPTIONAL, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESOURCE, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSET, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSTREAM, SQLv1Antlr4ParserSTRUCT, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTAGGED, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTUPLE, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVARIANT, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWITHOUT, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserSTRING_VALUE, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2789)
			p.Object_feature()
		}

	case SQLv1Antlr4ParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2790)
			p.Match(SQLv1Antlr4ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2791)
			p.Object_feature()
		}
		p.SetState(2796)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SQLv1Antlr4ParserCOMMA {
			{
				p.SetState(2792)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2793)
				p.Object_feature()
			}

			p.SetState(2798)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2799)
			p.Match(SQLv1Antlr4ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObject_type_refContext is an interface to support dynamic dispatch.
type IObject_type_refContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id_or_type() IAn_id_or_typeContext

	// IsObject_type_refContext differentiates from other interfaces.
	IsObject_type_refContext()
}

type Object_type_refContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObject_type_refContext() *Object_type_refContext {
	var p = new(Object_type_refContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_object_type_ref
	return p
}

func InitEmptyObject_type_refContext(p *Object_type_refContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_object_type_ref
}

func (*Object_type_refContext) IsObject_type_refContext() {}

func NewObject_type_refContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Object_type_refContext {
	var p = new(Object_type_refContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_object_type_ref

	return p
}

func (s *Object_type_refContext) GetParser() antlr.Parser { return s.parser }

func (s *Object_type_refContext) An_id_or_type() IAn_id_or_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_or_typeContext)
}

func (s *Object_type_refContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_type_refContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Object_type_refContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterObject_type_ref(s)
	}
}

func (s *Object_type_refContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitObject_type_ref(s)
	}
}

func (p *SQLv1Antlr4Parser) Object_type_ref() (localctx IObject_type_refContext) {
	localctx = NewObject_type_refContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, SQLv1Antlr4ParserRULE_object_type_ref)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2803)
		p.An_id_or_type()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_stmtContext is an interface to support dynamic dispatch.
type ICreate_table_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	Simple_table_ref() ISimple_table_refContext
	LPAREN() antlr.TerminalNode
	AllCreate_table_entry() []ICreate_table_entryContext
	Create_table_entry(i int) ICreate_table_entryContext
	RPAREN() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TABLESTORE() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	TEMP() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	OR() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	Table_inherits() ITable_inheritsContext
	Table_partition_by() ITable_partition_byContext
	With_table_settings() IWith_table_settingsContext
	Table_tablestore() ITable_tablestoreContext
	Table_as_source() ITable_as_sourceContext

	// IsCreate_table_stmtContext differentiates from other interfaces.
	IsCreate_table_stmtContext()
}

type Create_table_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_stmtContext() *Create_table_stmtContext {
	var p = new(Create_table_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_table_stmt
	return p
}

func InitEmptyCreate_table_stmtContext(p *Create_table_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_table_stmt
}

func (*Create_table_stmtContext) IsCreate_table_stmtContext() {}

func NewCreate_table_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_stmtContext {
	var p = new(Create_table_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_table_stmt

	return p
}

func (s *Create_table_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCREATE, 0)
}

func (s *Create_table_stmtContext) Simple_table_ref() ISimple_table_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_table_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_table_refContext)
}

func (s *Create_table_stmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Create_table_stmtContext) AllCreate_table_entry() []ICreate_table_entryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_entryContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_entryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_entryContext); ok {
			tst[i] = t.(ICreate_table_entryContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_stmtContext) Create_table_entry(i int) ICreate_table_entryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_entryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_entryContext)
}

func (s *Create_table_stmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Create_table_stmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTABLE, 0)
}

func (s *Create_table_stmtContext) TABLESTORE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTABLESTORE, 0)
}

func (s *Create_table_stmtContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXTERNAL, 0)
}

func (s *Create_table_stmtContext) TEMP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTEMP, 0)
}

func (s *Create_table_stmtContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTEMPORARY, 0)
}

func (s *Create_table_stmtContext) OR() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOR, 0)
}

func (s *Create_table_stmtContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREPLACE, 0)
}

func (s *Create_table_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIF, 0)
}

func (s *Create_table_stmtContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNOT, 0)
}

func (s *Create_table_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXISTS, 0)
}

func (s *Create_table_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Create_table_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Create_table_stmtContext) Table_inherits() ITable_inheritsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_inheritsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_inheritsContext)
}

func (s *Create_table_stmtContext) Table_partition_by() ITable_partition_byContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_partition_byContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_partition_byContext)
}

func (s *Create_table_stmtContext) With_table_settings() IWith_table_settingsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_table_settingsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_table_settingsContext)
}

func (s *Create_table_stmtContext) Table_tablestore() ITable_tablestoreContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_tablestoreContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_tablestoreContext)
}

func (s *Create_table_stmtContext) Table_as_source() ITable_as_sourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_as_sourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_as_sourceContext)
}

func (s *Create_table_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterCreate_table_stmt(s)
	}
}

func (s *Create_table_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitCreate_table_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Create_table_stmt() (localctx ICreate_table_stmtContext) {
	localctx = NewCreate_table_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, SQLv1Antlr4ParserRULE_create_table_stmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2805)
		p.Match(SQLv1Antlr4ParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2808)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserOR {
		{
			p.SetState(2806)
			p.Match(SQLv1Antlr4ParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2807)
			p.Match(SQLv1Antlr4ParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2818)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserTABLE:
		{
			p.SetState(2810)
			p.Match(SQLv1Antlr4ParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserTABLESTORE:
		{
			p.SetState(2811)
			p.Match(SQLv1Antlr4ParserTABLESTORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserEXTERNAL:
		{
			p.SetState(2812)
			p.Match(SQLv1Antlr4ParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2813)
			p.Match(SQLv1Antlr4ParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserTEMP:
		{
			p.SetState(2814)
			p.Match(SQLv1Antlr4ParserTEMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2815)
			p.Match(SQLv1Antlr4ParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserTEMPORARY:
		{
			p.SetState(2816)
			p.Match(SQLv1Antlr4ParserTEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2817)
			p.Match(SQLv1Antlr4ParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(2823)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 276, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2820)
			p.Match(SQLv1Antlr4ParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2821)
			p.Match(SQLv1Antlr4ParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2822)
			p.Match(SQLv1Antlr4ParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2825)
		p.Simple_table_ref()
	}
	{
		p.SetState(2826)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2827)
		p.Create_table_entry()
	}
	p.SetState(2832)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 277, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2828)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2829)
				p.Create_table_entry()
			}

		}
		p.SetState(2834)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 277, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2836)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(2835)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2838)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2840)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserINHERITS {
		{
			p.SetState(2839)
			p.Table_inherits()
		}

	}
	p.SetState(2843)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserPARTITION {
		{
			p.SetState(2842)
			p.Table_partition_by()
		}

	}
	p.SetState(2846)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserWITH {
		{
			p.SetState(2845)
			p.With_table_settings()
		}

	}
	p.SetState(2849)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserTABLESTORE {
		{
			p.SetState(2848)
			p.Table_tablestore()
		}

	}
	p.SetState(2852)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserAS {
		{
			p.SetState(2851)
			p.Table_as_source()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_entryContext is an interface to support dynamic dispatch.
type ICreate_table_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column_schema() IColumn_schemaContext
	Table_constraint() ITable_constraintContext
	Table_index() ITable_indexContext
	Family_entry() IFamily_entryContext
	Changefeed() IChangefeedContext
	An_id_schema() IAn_id_schemaContext

	// IsCreate_table_entryContext differentiates from other interfaces.
	IsCreate_table_entryContext()
}

type Create_table_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_entryContext() *Create_table_entryContext {
	var p = new(Create_table_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_table_entry
	return p
}

func InitEmptyCreate_table_entryContext(p *Create_table_entryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_table_entry
}

func (*Create_table_entryContext) IsCreate_table_entryContext() {}

func NewCreate_table_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_entryContext {
	var p = new(Create_table_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_table_entry

	return p
}

func (s *Create_table_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_entryContext) Column_schema() IColumn_schemaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_schemaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_schemaContext)
}

func (s *Create_table_entryContext) Table_constraint() ITable_constraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_constraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_constraintContext)
}

func (s *Create_table_entryContext) Table_index() ITable_indexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_indexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_indexContext)
}

func (s *Create_table_entryContext) Family_entry() IFamily_entryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFamily_entryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFamily_entryContext)
}

func (s *Create_table_entryContext) Changefeed() IChangefeedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangefeedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangefeedContext)
}

func (s *Create_table_entryContext) An_id_schema() IAn_id_schemaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_schemaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_schemaContext)
}

func (s *Create_table_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterCreate_table_entry(s)
	}
}

func (s *Create_table_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitCreate_table_entry(s)
	}
}

func (p *SQLv1Antlr4Parser) Create_table_entry() (localctx ICreate_table_entryContext) {
	localctx = NewCreate_table_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, SQLv1Antlr4ParserRULE_create_table_entry)
	p.SetState(2860)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 284, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2854)
			p.Column_schema()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2855)
			p.Table_constraint()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2856)
			p.Table_index()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2857)
			p.Family_entry()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2858)
			p.Changefeed()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2859)
			p.An_id_schema()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_backup_collection_stmtContext is an interface to support dynamic dispatch.
type ICreate_backup_collection_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	Backup_collection() IBackup_collectionContext
	WITH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Backup_collection_settings() IBackup_collection_settingsContext
	RPAREN() antlr.TerminalNode
	Database_or_table_list() IDatabase_or_table_listContext

	// IsCreate_backup_collection_stmtContext differentiates from other interfaces.
	IsCreate_backup_collection_stmtContext()
}

type Create_backup_collection_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_backup_collection_stmtContext() *Create_backup_collection_stmtContext {
	var p = new(Create_backup_collection_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_backup_collection_stmt
	return p
}

func InitEmptyCreate_backup_collection_stmtContext(p *Create_backup_collection_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_backup_collection_stmt
}

func (*Create_backup_collection_stmtContext) IsCreate_backup_collection_stmtContext() {}

func NewCreate_backup_collection_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_backup_collection_stmtContext {
	var p = new(Create_backup_collection_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_backup_collection_stmt

	return p
}

func (s *Create_backup_collection_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_backup_collection_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCREATE, 0)
}

func (s *Create_backup_collection_stmtContext) Backup_collection() IBackup_collectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackup_collectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackup_collectionContext)
}

func (s *Create_backup_collection_stmtContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWITH, 0)
}

func (s *Create_backup_collection_stmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Create_backup_collection_stmtContext) Backup_collection_settings() IBackup_collection_settingsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackup_collection_settingsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackup_collection_settingsContext)
}

func (s *Create_backup_collection_stmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Create_backup_collection_stmtContext) Database_or_table_list() IDatabase_or_table_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabase_or_table_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabase_or_table_listContext)
}

func (s *Create_backup_collection_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_backup_collection_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_backup_collection_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterCreate_backup_collection_stmt(s)
	}
}

func (s *Create_backup_collection_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitCreate_backup_collection_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Create_backup_collection_stmt() (localctx ICreate_backup_collection_stmtContext) {
	localctx = NewCreate_backup_collection_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, SQLv1Antlr4ParserRULE_create_backup_collection_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2862)
		p.Match(SQLv1Antlr4ParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2863)
		p.Backup_collection()
	}
	{
		p.SetState(2864)
		p.Match(SQLv1Antlr4ParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2865)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2866)
		p.Backup_collection_settings()
	}
	{
		p.SetState(2867)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2869)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserDATABASE || _la == SQLv1Antlr4ParserTABLE {
		{
			p.SetState(2868)
			p.Database_or_table_list()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_backup_collection_stmtContext is an interface to support dynamic dispatch.
type IAlter_backup_collection_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	Backup_collection() IBackup_collectionContext
	Alter_backup_collection_actions() IAlter_backup_collection_actionsContext
	Alter_backup_collection_entries() IAlter_backup_collection_entriesContext

	// IsAlter_backup_collection_stmtContext differentiates from other interfaces.
	IsAlter_backup_collection_stmtContext()
}

type Alter_backup_collection_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_backup_collection_stmtContext() *Alter_backup_collection_stmtContext {
	var p = new(Alter_backup_collection_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_backup_collection_stmt
	return p
}

func InitEmptyAlter_backup_collection_stmtContext(p *Alter_backup_collection_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_backup_collection_stmt
}

func (*Alter_backup_collection_stmtContext) IsAlter_backup_collection_stmtContext() {}

func NewAlter_backup_collection_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_backup_collection_stmtContext {
	var p = new(Alter_backup_collection_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_backup_collection_stmt

	return p
}

func (s *Alter_backup_collection_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_backup_collection_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserALTER, 0)
}

func (s *Alter_backup_collection_stmtContext) Backup_collection() IBackup_collectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackup_collectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackup_collectionContext)
}

func (s *Alter_backup_collection_stmtContext) Alter_backup_collection_actions() IAlter_backup_collection_actionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_backup_collection_actionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_backup_collection_actionsContext)
}

func (s *Alter_backup_collection_stmtContext) Alter_backup_collection_entries() IAlter_backup_collection_entriesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_backup_collection_entriesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_backup_collection_entriesContext)
}

func (s *Alter_backup_collection_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_backup_collection_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_backup_collection_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_backup_collection_stmt(s)
	}
}

func (s *Alter_backup_collection_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_backup_collection_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_backup_collection_stmt() (localctx IAlter_backup_collection_stmtContext) {
	localctx = NewAlter_backup_collection_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, SQLv1Antlr4ParserRULE_alter_backup_collection_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2871)
		p.Match(SQLv1Antlr4ParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2872)
		p.Backup_collection()
	}
	p.SetState(2875)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserSET:
		{
			p.SetState(2873)
			p.Alter_backup_collection_actions()
		}

	case SQLv1Antlr4ParserADD, SQLv1Antlr4ParserDROP:
		{
			p.SetState(2874)
			p.Alter_backup_collection_entries()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_backup_collection_stmtContext is an interface to support dynamic dispatch.
type IDrop_backup_collection_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	Backup_collection() IBackup_collectionContext

	// IsDrop_backup_collection_stmtContext differentiates from other interfaces.
	IsDrop_backup_collection_stmtContext()
}

type Drop_backup_collection_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_backup_collection_stmtContext() *Drop_backup_collection_stmtContext {
	var p = new(Drop_backup_collection_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_backup_collection_stmt
	return p
}

func InitEmptyDrop_backup_collection_stmtContext(p *Drop_backup_collection_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_backup_collection_stmt
}

func (*Drop_backup_collection_stmtContext) IsDrop_backup_collection_stmtContext() {}

func NewDrop_backup_collection_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_backup_collection_stmtContext {
	var p = new(Drop_backup_collection_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_backup_collection_stmt

	return p
}

func (s *Drop_backup_collection_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_backup_collection_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDROP, 0)
}

func (s *Drop_backup_collection_stmtContext) Backup_collection() IBackup_collectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackup_collectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackup_collectionContext)
}

func (s *Drop_backup_collection_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_backup_collection_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_backup_collection_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterDrop_backup_collection_stmt(s)
	}
}

func (s *Drop_backup_collection_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitDrop_backup_collection_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Drop_backup_collection_stmt() (localctx IDrop_backup_collection_stmtContext) {
	localctx = NewDrop_backup_collection_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, SQLv1Antlr4ParserRULE_drop_backup_collection_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2877)
		p.Match(SQLv1Antlr4ParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2878)
		p.Backup_collection()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatabase_or_table_listContext is an interface to support dynamic dispatch.
type IDatabase_or_table_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATABASE() antlr.TerminalNode
	Table_list() ITable_listContext

	// IsDatabase_or_table_listContext differentiates from other interfaces.
	IsDatabase_or_table_listContext()
}

type Database_or_table_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatabase_or_table_listContext() *Database_or_table_listContext {
	var p = new(Database_or_table_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_database_or_table_list
	return p
}

func InitEmptyDatabase_or_table_listContext(p *Database_or_table_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_database_or_table_list
}

func (*Database_or_table_listContext) IsDatabase_or_table_listContext() {}

func NewDatabase_or_table_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Database_or_table_listContext {
	var p = new(Database_or_table_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_database_or_table_list

	return p
}

func (s *Database_or_table_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Database_or_table_listContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDATABASE, 0)
}

func (s *Database_or_table_listContext) Table_list() ITable_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_listContext)
}

func (s *Database_or_table_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Database_or_table_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Database_or_table_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterDatabase_or_table_list(s)
	}
}

func (s *Database_or_table_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitDatabase_or_table_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Database_or_table_list() (localctx IDatabase_or_table_listContext) {
	localctx = NewDatabase_or_table_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, SQLv1Antlr4ParserRULE_database_or_table_list)
	p.SetState(2882)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserDATABASE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2880)
			p.Match(SQLv1Antlr4ParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserTABLE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2881)
			p.Table_list()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_listContext is an interface to support dynamic dispatch.
type ITable_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTABLE() []antlr.TerminalNode
	TABLE(i int) antlr.TerminalNode
	AllAn_id_table() []IAn_id_tableContext
	An_id_table(i int) IAn_id_tableContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTable_listContext differentiates from other interfaces.
	IsTable_listContext()
}

type Table_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_listContext() *Table_listContext {
	var p = new(Table_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_list
	return p
}

func InitEmptyTable_listContext(p *Table_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_list
}

func (*Table_listContext) IsTable_listContext() {}

func NewTable_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_listContext {
	var p = new(Table_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_list

	return p
}

func (s *Table_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_listContext) AllTABLE() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserTABLE)
}

func (s *Table_listContext) TABLE(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTABLE, i)
}

func (s *Table_listContext) AllAn_id_table() []IAn_id_tableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_id_tableContext); ok {
			len++
		}
	}

	tst := make([]IAn_id_tableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_id_tableContext); ok {
			tst[i] = t.(IAn_id_tableContext)
			i++
		}
	}

	return tst
}

func (s *Table_listContext) An_id_table(i int) IAn_id_tableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_tableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_tableContext)
}

func (s *Table_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Table_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Table_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterTable_list(s)
	}
}

func (s *Table_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitTable_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Table_list() (localctx ITable_listContext) {
	localctx = NewTable_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, SQLv1Antlr4ParserRULE_table_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2884)
		p.Match(SQLv1Antlr4ParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2885)
		p.An_id_table()
	}
	p.SetState(2891)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(2886)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2887)
			p.Match(SQLv1Antlr4ParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2888)
			p.An_id_table()
		}

		p.SetState(2893)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_backup_collection_actionsContext is an interface to support dynamic dispatch.
type IAlter_backup_collection_actionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAlter_backup_collection_action() []IAlter_backup_collection_actionContext
	Alter_backup_collection_action(i int) IAlter_backup_collection_actionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlter_backup_collection_actionsContext differentiates from other interfaces.
	IsAlter_backup_collection_actionsContext()
}

type Alter_backup_collection_actionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_backup_collection_actionsContext() *Alter_backup_collection_actionsContext {
	var p = new(Alter_backup_collection_actionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_backup_collection_actions
	return p
}

func InitEmptyAlter_backup_collection_actionsContext(p *Alter_backup_collection_actionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_backup_collection_actions
}

func (*Alter_backup_collection_actionsContext) IsAlter_backup_collection_actionsContext() {}

func NewAlter_backup_collection_actionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_backup_collection_actionsContext {
	var p = new(Alter_backup_collection_actionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_backup_collection_actions

	return p
}

func (s *Alter_backup_collection_actionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_backup_collection_actionsContext) AllAlter_backup_collection_action() []IAlter_backup_collection_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlter_backup_collection_actionContext); ok {
			len++
		}
	}

	tst := make([]IAlter_backup_collection_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlter_backup_collection_actionContext); ok {
			tst[i] = t.(IAlter_backup_collection_actionContext)
			i++
		}
	}

	return tst
}

func (s *Alter_backup_collection_actionsContext) Alter_backup_collection_action(i int) IAlter_backup_collection_actionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_backup_collection_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_backup_collection_actionContext)
}

func (s *Alter_backup_collection_actionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Alter_backup_collection_actionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Alter_backup_collection_actionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_backup_collection_actionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_backup_collection_actionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_backup_collection_actions(s)
	}
}

func (s *Alter_backup_collection_actionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_backup_collection_actions(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_backup_collection_actions() (localctx IAlter_backup_collection_actionsContext) {
	localctx = NewAlter_backup_collection_actionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, SQLv1Antlr4ParserRULE_alter_backup_collection_actions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2894)
		p.Alter_backup_collection_action()
	}
	p.SetState(2899)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(2895)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2896)
			p.Alter_backup_collection_action()
		}

		p.SetState(2901)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_backup_collection_actionContext is an interface to support dynamic dispatch.
type IAlter_backup_collection_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Alter_table_set_table_setting_compat() IAlter_table_set_table_setting_compatContext
	Alter_table_reset_table_setting() IAlter_table_reset_table_settingContext

	// IsAlter_backup_collection_actionContext differentiates from other interfaces.
	IsAlter_backup_collection_actionContext()
}

type Alter_backup_collection_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_backup_collection_actionContext() *Alter_backup_collection_actionContext {
	var p = new(Alter_backup_collection_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_backup_collection_action
	return p
}

func InitEmptyAlter_backup_collection_actionContext(p *Alter_backup_collection_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_backup_collection_action
}

func (*Alter_backup_collection_actionContext) IsAlter_backup_collection_actionContext() {}

func NewAlter_backup_collection_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_backup_collection_actionContext {
	var p = new(Alter_backup_collection_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_backup_collection_action

	return p
}

func (s *Alter_backup_collection_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_backup_collection_actionContext) Alter_table_set_table_setting_compat() IAlter_table_set_table_setting_compatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_set_table_setting_compatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_set_table_setting_compatContext)
}

func (s *Alter_backup_collection_actionContext) Alter_table_reset_table_setting() IAlter_table_reset_table_settingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_reset_table_settingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_reset_table_settingContext)
}

func (s *Alter_backup_collection_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_backup_collection_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_backup_collection_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_backup_collection_action(s)
	}
}

func (s *Alter_backup_collection_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_backup_collection_action(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_backup_collection_action() (localctx IAlter_backup_collection_actionContext) {
	localctx = NewAlter_backup_collection_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, SQLv1Antlr4ParserRULE_alter_backup_collection_action)
	p.SetState(2904)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserSET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2902)
			p.Alter_table_set_table_setting_compat()
		}

	case SQLv1Antlr4ParserRESET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2903)
			p.Alter_table_reset_table_setting()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_backup_collection_entriesContext is an interface to support dynamic dispatch.
type IAlter_backup_collection_entriesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAlter_backup_collection_entry() []IAlter_backup_collection_entryContext
	Alter_backup_collection_entry(i int) IAlter_backup_collection_entryContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlter_backup_collection_entriesContext differentiates from other interfaces.
	IsAlter_backup_collection_entriesContext()
}

type Alter_backup_collection_entriesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_backup_collection_entriesContext() *Alter_backup_collection_entriesContext {
	var p = new(Alter_backup_collection_entriesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_backup_collection_entries
	return p
}

func InitEmptyAlter_backup_collection_entriesContext(p *Alter_backup_collection_entriesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_backup_collection_entries
}

func (*Alter_backup_collection_entriesContext) IsAlter_backup_collection_entriesContext() {}

func NewAlter_backup_collection_entriesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_backup_collection_entriesContext {
	var p = new(Alter_backup_collection_entriesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_backup_collection_entries

	return p
}

func (s *Alter_backup_collection_entriesContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_backup_collection_entriesContext) AllAlter_backup_collection_entry() []IAlter_backup_collection_entryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlter_backup_collection_entryContext); ok {
			len++
		}
	}

	tst := make([]IAlter_backup_collection_entryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlter_backup_collection_entryContext); ok {
			tst[i] = t.(IAlter_backup_collection_entryContext)
			i++
		}
	}

	return tst
}

func (s *Alter_backup_collection_entriesContext) Alter_backup_collection_entry(i int) IAlter_backup_collection_entryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_backup_collection_entryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_backup_collection_entryContext)
}

func (s *Alter_backup_collection_entriesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Alter_backup_collection_entriesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Alter_backup_collection_entriesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_backup_collection_entriesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_backup_collection_entriesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_backup_collection_entries(s)
	}
}

func (s *Alter_backup_collection_entriesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_backup_collection_entries(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_backup_collection_entries() (localctx IAlter_backup_collection_entriesContext) {
	localctx = NewAlter_backup_collection_entriesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, SQLv1Antlr4ParserRULE_alter_backup_collection_entries)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2906)
		p.Alter_backup_collection_entry()
	}
	p.SetState(2911)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(2907)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2908)
			p.Alter_backup_collection_entry()
		}

		p.SetState(2913)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_backup_collection_entryContext is an interface to support dynamic dispatch.
type IAlter_backup_collection_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	DROP() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	An_id_table() IAn_id_tableContext

	// IsAlter_backup_collection_entryContext differentiates from other interfaces.
	IsAlter_backup_collection_entryContext()
}

type Alter_backup_collection_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_backup_collection_entryContext() *Alter_backup_collection_entryContext {
	var p = new(Alter_backup_collection_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_backup_collection_entry
	return p
}

func InitEmptyAlter_backup_collection_entryContext(p *Alter_backup_collection_entryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_backup_collection_entry
}

func (*Alter_backup_collection_entryContext) IsAlter_backup_collection_entryContext() {}

func NewAlter_backup_collection_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_backup_collection_entryContext {
	var p = new(Alter_backup_collection_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_backup_collection_entry

	return p
}

func (s *Alter_backup_collection_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_backup_collection_entryContext) ADD() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserADD, 0)
}

func (s *Alter_backup_collection_entryContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDATABASE, 0)
}

func (s *Alter_backup_collection_entryContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDROP, 0)
}

func (s *Alter_backup_collection_entryContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTABLE, 0)
}

func (s *Alter_backup_collection_entryContext) An_id_table() IAn_id_tableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_tableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_tableContext)
}

func (s *Alter_backup_collection_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_backup_collection_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_backup_collection_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_backup_collection_entry(s)
	}
}

func (s *Alter_backup_collection_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_backup_collection_entry(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_backup_collection_entry() (localctx IAlter_backup_collection_entryContext) {
	localctx = NewAlter_backup_collection_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, SQLv1Antlr4ParserRULE_alter_backup_collection_entry)
	p.SetState(2924)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 292, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2914)
			p.Match(SQLv1Antlr4ParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2915)
			p.Match(SQLv1Antlr4ParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2916)
			p.Match(SQLv1Antlr4ParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2917)
			p.Match(SQLv1Antlr4ParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2918)
			p.Match(SQLv1Antlr4ParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2919)
			p.Match(SQLv1Antlr4ParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2920)
			p.An_id_table()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2921)
			p.Match(SQLv1Antlr4ParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2922)
			p.Match(SQLv1Antlr4ParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2923)
			p.An_id_table()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBackup_collectionContext is an interface to support dynamic dispatch.
type IBackup_collectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BACKUP() antlr.TerminalNode
	COLLECTION() antlr.TerminalNode
	Object_ref() IObject_refContext

	// IsBackup_collectionContext differentiates from other interfaces.
	IsBackup_collectionContext()
}

type Backup_collectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBackup_collectionContext() *Backup_collectionContext {
	var p = new(Backup_collectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_backup_collection
	return p
}

func InitEmptyBackup_collectionContext(p *Backup_collectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_backup_collection
}

func (*Backup_collectionContext) IsBackup_collectionContext() {}

func NewBackup_collectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Backup_collectionContext {
	var p = new(Backup_collectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_backup_collection

	return p
}

func (s *Backup_collectionContext) GetParser() antlr.Parser { return s.parser }

func (s *Backup_collectionContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserBACKUP, 0)
}

func (s *Backup_collectionContext) COLLECTION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOLLECTION, 0)
}

func (s *Backup_collectionContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Backup_collectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Backup_collectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Backup_collectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterBackup_collection(s)
	}
}

func (s *Backup_collectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitBackup_collection(s)
	}
}

func (p *SQLv1Antlr4Parser) Backup_collection() (localctx IBackup_collectionContext) {
	localctx = NewBackup_collectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, SQLv1Antlr4ParserRULE_backup_collection)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2926)
		p.Match(SQLv1Antlr4ParserBACKUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2927)
		p.Match(SQLv1Antlr4ParserCOLLECTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2928)
		p.Object_ref()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBackup_collection_settingsContext is an interface to support dynamic dispatch.
type IBackup_collection_settingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBackup_collection_settings_entry() []IBackup_collection_settings_entryContext
	Backup_collection_settings_entry(i int) IBackup_collection_settings_entryContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsBackup_collection_settingsContext differentiates from other interfaces.
	IsBackup_collection_settingsContext()
}

type Backup_collection_settingsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBackup_collection_settingsContext() *Backup_collection_settingsContext {
	var p = new(Backup_collection_settingsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_backup_collection_settings
	return p
}

func InitEmptyBackup_collection_settingsContext(p *Backup_collection_settingsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_backup_collection_settings
}

func (*Backup_collection_settingsContext) IsBackup_collection_settingsContext() {}

func NewBackup_collection_settingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Backup_collection_settingsContext {
	var p = new(Backup_collection_settingsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_backup_collection_settings

	return p
}

func (s *Backup_collection_settingsContext) GetParser() antlr.Parser { return s.parser }

func (s *Backup_collection_settingsContext) AllBackup_collection_settings_entry() []IBackup_collection_settings_entryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBackup_collection_settings_entryContext); ok {
			len++
		}
	}

	tst := make([]IBackup_collection_settings_entryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBackup_collection_settings_entryContext); ok {
			tst[i] = t.(IBackup_collection_settings_entryContext)
			i++
		}
	}

	return tst
}

func (s *Backup_collection_settingsContext) Backup_collection_settings_entry(i int) IBackup_collection_settings_entryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackup_collection_settings_entryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackup_collection_settings_entryContext)
}

func (s *Backup_collection_settingsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Backup_collection_settingsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Backup_collection_settingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Backup_collection_settingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Backup_collection_settingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterBackup_collection_settings(s)
	}
}

func (s *Backup_collection_settingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitBackup_collection_settings(s)
	}
}

func (p *SQLv1Antlr4Parser) Backup_collection_settings() (localctx IBackup_collection_settingsContext) {
	localctx = NewBackup_collection_settingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, SQLv1Antlr4ParserRULE_backup_collection_settings)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2930)
		p.Backup_collection_settings_entry()
	}
	p.SetState(2935)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(2931)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2932)
			p.Backup_collection_settings_entry()
		}

		p.SetState(2937)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBackup_collection_settings_entryContext is an interface to support dynamic dispatch.
type IBackup_collection_settings_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext
	EQUALS() antlr.TerminalNode
	Table_setting_value() ITable_setting_valueContext

	// IsBackup_collection_settings_entryContext differentiates from other interfaces.
	IsBackup_collection_settings_entryContext()
}

type Backup_collection_settings_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBackup_collection_settings_entryContext() *Backup_collection_settings_entryContext {
	var p = new(Backup_collection_settings_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_backup_collection_settings_entry
	return p
}

func InitEmptyBackup_collection_settings_entryContext(p *Backup_collection_settings_entryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_backup_collection_settings_entry
}

func (*Backup_collection_settings_entryContext) IsBackup_collection_settings_entryContext() {}

func NewBackup_collection_settings_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Backup_collection_settings_entryContext {
	var p = new(Backup_collection_settings_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_backup_collection_settings_entry

	return p
}

func (s *Backup_collection_settings_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Backup_collection_settings_entryContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Backup_collection_settings_entryContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEQUALS, 0)
}

func (s *Backup_collection_settings_entryContext) Table_setting_value() ITable_setting_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_setting_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_setting_valueContext)
}

func (s *Backup_collection_settings_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Backup_collection_settings_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Backup_collection_settings_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterBackup_collection_settings_entry(s)
	}
}

func (s *Backup_collection_settings_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitBackup_collection_settings_entry(s)
	}
}

func (p *SQLv1Antlr4Parser) Backup_collection_settings_entry() (localctx IBackup_collection_settings_entryContext) {
	localctx = NewBackup_collection_settings_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, SQLv1Antlr4ParserRULE_backup_collection_settings_entry)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2938)
		p.An_id()
	}
	{
		p.SetState(2939)
		p.Match(SQLv1Antlr4ParserEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2940)
		p.Table_setting_value()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBackup_stmtContext is an interface to support dynamic dispatch.
type IBackup_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BACKUP() antlr.TerminalNode
	Object_ref() IObject_refContext
	INCREMENTAL() antlr.TerminalNode

	// IsBackup_stmtContext differentiates from other interfaces.
	IsBackup_stmtContext()
}

type Backup_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBackup_stmtContext() *Backup_stmtContext {
	var p = new(Backup_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_backup_stmt
	return p
}

func InitEmptyBackup_stmtContext(p *Backup_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_backup_stmt
}

func (*Backup_stmtContext) IsBackup_stmtContext() {}

func NewBackup_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Backup_stmtContext {
	var p = new(Backup_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_backup_stmt

	return p
}

func (s *Backup_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Backup_stmtContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserBACKUP, 0)
}

func (s *Backup_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Backup_stmtContext) INCREMENTAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINCREMENTAL, 0)
}

func (s *Backup_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Backup_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Backup_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterBackup_stmt(s)
	}
}

func (s *Backup_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitBackup_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Backup_stmt() (localctx IBackup_stmtContext) {
	localctx = NewBackup_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, SQLv1Antlr4ParserRULE_backup_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2942)
		p.Match(SQLv1Antlr4ParserBACKUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2943)
		p.Object_ref()
	}
	p.SetState(2945)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserINCREMENTAL {
		{
			p.SetState(2944)
			p.Match(SQLv1Antlr4ParserINCREMENTAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRestore_stmtContext is an interface to support dynamic dispatch.
type IRestore_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESTORE() antlr.TerminalNode
	Object_ref() IObject_refContext
	AT() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode

	// IsRestore_stmtContext differentiates from other interfaces.
	IsRestore_stmtContext()
}

type Restore_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRestore_stmtContext() *Restore_stmtContext {
	var p = new(Restore_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_restore_stmt
	return p
}

func InitEmptyRestore_stmtContext(p *Restore_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_restore_stmt
}

func (*Restore_stmtContext) IsRestore_stmtContext() {}

func NewRestore_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Restore_stmtContext {
	var p = new(Restore_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_restore_stmt

	return p
}

func (s *Restore_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Restore_stmtContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRESTORE, 0)
}

func (s *Restore_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Restore_stmtContext) AT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAT, 0)
}

func (s *Restore_stmtContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRING_VALUE, 0)
}

func (s *Restore_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Restore_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Restore_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRestore_stmt(s)
	}
}

func (s *Restore_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRestore_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Restore_stmt() (localctx IRestore_stmtContext) {
	localctx = NewRestore_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, SQLv1Antlr4ParserRULE_restore_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2947)
		p.Match(SQLv1Antlr4ParserRESTORE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2948)
		p.Object_ref()
	}
	p.SetState(2951)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserAT {
		{
			p.SetState(2949)
			p.Match(SQLv1Antlr4ParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2950)
			p.Match(SQLv1Antlr4ParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_inheritsContext is an interface to support dynamic dispatch.
type ITable_inheritsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INHERITS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllSimple_table_ref_core() []ISimple_table_ref_coreContext
	Simple_table_ref_core(i int) ISimple_table_ref_coreContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTable_inheritsContext differentiates from other interfaces.
	IsTable_inheritsContext()
}

type Table_inheritsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_inheritsContext() *Table_inheritsContext {
	var p = new(Table_inheritsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_inherits
	return p
}

func InitEmptyTable_inheritsContext(p *Table_inheritsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_inherits
}

func (*Table_inheritsContext) IsTable_inheritsContext() {}

func NewTable_inheritsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_inheritsContext {
	var p = new(Table_inheritsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_inherits

	return p
}

func (s *Table_inheritsContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_inheritsContext) INHERITS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINHERITS, 0)
}

func (s *Table_inheritsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Table_inheritsContext) AllSimple_table_ref_core() []ISimple_table_ref_coreContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimple_table_ref_coreContext); ok {
			len++
		}
	}

	tst := make([]ISimple_table_ref_coreContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimple_table_ref_coreContext); ok {
			tst[i] = t.(ISimple_table_ref_coreContext)
			i++
		}
	}

	return tst
}

func (s *Table_inheritsContext) Simple_table_ref_core(i int) ISimple_table_ref_coreContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_table_ref_coreContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_table_ref_coreContext)
}

func (s *Table_inheritsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Table_inheritsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Table_inheritsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Table_inheritsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_inheritsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_inheritsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterTable_inherits(s)
	}
}

func (s *Table_inheritsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitTable_inherits(s)
	}
}

func (p *SQLv1Antlr4Parser) Table_inherits() (localctx ITable_inheritsContext) {
	localctx = NewTable_inheritsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, SQLv1Antlr4ParserRULE_table_inherits)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2953)
		p.Match(SQLv1Antlr4ParserINHERITS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2954)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2955)
		p.Simple_table_ref_core()
	}
	p.SetState(2960)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(2956)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2957)
			p.Simple_table_ref_core()
		}

		p.SetState(2962)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2963)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_partition_byContext is an interface to support dynamic dispatch.
type ITable_partition_byContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	HASH() antlr.TerminalNode
	Pure_column_list() IPure_column_listContext

	// IsTable_partition_byContext differentiates from other interfaces.
	IsTable_partition_byContext()
}

type Table_partition_byContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_partition_byContext() *Table_partition_byContext {
	var p = new(Table_partition_byContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_partition_by
	return p
}

func InitEmptyTable_partition_byContext(p *Table_partition_byContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_partition_by
}

func (*Table_partition_byContext) IsTable_partition_byContext() {}

func NewTable_partition_byContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_partition_byContext {
	var p = new(Table_partition_byContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_partition_by

	return p
}

func (s *Table_partition_byContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_partition_byContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPARTITION, 0)
}

func (s *Table_partition_byContext) BY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserBY, 0)
}

func (s *Table_partition_byContext) HASH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserHASH, 0)
}

func (s *Table_partition_byContext) Pure_column_list() IPure_column_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPure_column_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPure_column_listContext)
}

func (s *Table_partition_byContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_partition_byContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_partition_byContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterTable_partition_by(s)
	}
}

func (s *Table_partition_byContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitTable_partition_by(s)
	}
}

func (p *SQLv1Antlr4Parser) Table_partition_by() (localctx ITable_partition_byContext) {
	localctx = NewTable_partition_byContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, SQLv1Antlr4ParserRULE_table_partition_by)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2965)
		p.Match(SQLv1Antlr4ParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2966)
		p.Match(SQLv1Antlr4ParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2967)
		p.Match(SQLv1Antlr4ParserHASH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2968)
		p.Pure_column_list()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWith_table_settingsContext is an interface to support dynamic dispatch.
type IWith_table_settingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllTable_settings_entry() []ITable_settings_entryContext
	Table_settings_entry(i int) ITable_settings_entryContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWith_table_settingsContext differentiates from other interfaces.
	IsWith_table_settingsContext()
}

type With_table_settingsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_table_settingsContext() *With_table_settingsContext {
	var p = new(With_table_settingsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_with_table_settings
	return p
}

func InitEmptyWith_table_settingsContext(p *With_table_settingsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_with_table_settings
}

func (*With_table_settingsContext) IsWith_table_settingsContext() {}

func NewWith_table_settingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_table_settingsContext {
	var p = new(With_table_settingsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_with_table_settings

	return p
}

func (s *With_table_settingsContext) GetParser() antlr.Parser { return s.parser }

func (s *With_table_settingsContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWITH, 0)
}

func (s *With_table_settingsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *With_table_settingsContext) AllTable_settings_entry() []ITable_settings_entryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITable_settings_entryContext); ok {
			len++
		}
	}

	tst := make([]ITable_settings_entryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITable_settings_entryContext); ok {
			tst[i] = t.(ITable_settings_entryContext)
			i++
		}
	}

	return tst
}

func (s *With_table_settingsContext) Table_settings_entry(i int) ITable_settings_entryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_settings_entryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_settings_entryContext)
}

func (s *With_table_settingsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *With_table_settingsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *With_table_settingsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *With_table_settingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_table_settingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *With_table_settingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterWith_table_settings(s)
	}
}

func (s *With_table_settingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitWith_table_settings(s)
	}
}

func (p *SQLv1Antlr4Parser) With_table_settings() (localctx IWith_table_settingsContext) {
	localctx = NewWith_table_settingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, SQLv1Antlr4ParserRULE_with_table_settings)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2970)
		p.Match(SQLv1Antlr4ParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2971)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2972)
		p.Table_settings_entry()
	}
	p.SetState(2977)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(2973)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2974)
			p.Table_settings_entry()
		}

		p.SetState(2979)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2980)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_tablestoreContext is an interface to support dynamic dispatch.
type ITable_tablestoreContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLESTORE() antlr.TerminalNode
	Simple_table_ref_core() ISimple_table_ref_coreContext

	// IsTable_tablestoreContext differentiates from other interfaces.
	IsTable_tablestoreContext()
}

type Table_tablestoreContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_tablestoreContext() *Table_tablestoreContext {
	var p = new(Table_tablestoreContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_tablestore
	return p
}

func InitEmptyTable_tablestoreContext(p *Table_tablestoreContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_tablestore
}

func (*Table_tablestoreContext) IsTable_tablestoreContext() {}

func NewTable_tablestoreContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_tablestoreContext {
	var p = new(Table_tablestoreContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_tablestore

	return p
}

func (s *Table_tablestoreContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_tablestoreContext) TABLESTORE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTABLESTORE, 0)
}

func (s *Table_tablestoreContext) Simple_table_ref_core() ISimple_table_ref_coreContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_table_ref_coreContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_table_ref_coreContext)
}

func (s *Table_tablestoreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_tablestoreContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_tablestoreContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterTable_tablestore(s)
	}
}

func (s *Table_tablestoreContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitTable_tablestore(s)
	}
}

func (p *SQLv1Antlr4Parser) Table_tablestore() (localctx ITable_tablestoreContext) {
	localctx = NewTable_tablestoreContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, SQLv1Antlr4ParserRULE_table_tablestore)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2982)
		p.Match(SQLv1Antlr4ParserTABLESTORE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2983)
		p.Simple_table_ref_core()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_settings_entryContext is an interface to support dynamic dispatch.
type ITable_settings_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext
	EQUALS() antlr.TerminalNode
	Table_setting_value() ITable_setting_valueContext

	// IsTable_settings_entryContext differentiates from other interfaces.
	IsTable_settings_entryContext()
}

type Table_settings_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_settings_entryContext() *Table_settings_entryContext {
	var p = new(Table_settings_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_settings_entry
	return p
}

func InitEmptyTable_settings_entryContext(p *Table_settings_entryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_settings_entry
}

func (*Table_settings_entryContext) IsTable_settings_entryContext() {}

func NewTable_settings_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_settings_entryContext {
	var p = new(Table_settings_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_settings_entry

	return p
}

func (s *Table_settings_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_settings_entryContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Table_settings_entryContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEQUALS, 0)
}

func (s *Table_settings_entryContext) Table_setting_value() ITable_setting_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_setting_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_setting_valueContext)
}

func (s *Table_settings_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_settings_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_settings_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterTable_settings_entry(s)
	}
}

func (s *Table_settings_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitTable_settings_entry(s)
	}
}

func (p *SQLv1Antlr4Parser) Table_settings_entry() (localctx ITable_settings_entryContext) {
	localctx = NewTable_settings_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, SQLv1Antlr4ParserRULE_table_settings_entry)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2985)
		p.An_id()
	}
	{
		p.SetState(2986)
		p.Match(SQLv1Antlr4ParserEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2987)
		p.Table_setting_value()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_as_sourceContext is an interface to support dynamic dispatch.
type ITable_as_sourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	Values_source() IValues_sourceContext

	// IsTable_as_sourceContext differentiates from other interfaces.
	IsTable_as_sourceContext()
}

type Table_as_sourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_as_sourceContext() *Table_as_sourceContext {
	var p = new(Table_as_sourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_as_source
	return p
}

func InitEmptyTable_as_sourceContext(p *Table_as_sourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_as_source
}

func (*Table_as_sourceContext) IsTable_as_sourceContext() {}

func NewTable_as_sourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_as_sourceContext {
	var p = new(Table_as_sourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_as_source

	return p
}

func (s *Table_as_sourceContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_as_sourceContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAS, 0)
}

func (s *Table_as_sourceContext) Values_source() IValues_sourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValues_sourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValues_sourceContext)
}

func (s *Table_as_sourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_as_sourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_as_sourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterTable_as_source(s)
	}
}

func (s *Table_as_sourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitTable_as_source(s)
	}
}

func (p *SQLv1Antlr4Parser) Table_as_source() (localctx ITable_as_sourceContext) {
	localctx = NewTable_as_sourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, SQLv1Antlr4ParserRULE_table_as_source)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2989)
		p.Match(SQLv1Antlr4ParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2990)
		p.Values_source()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_stmtContext is an interface to support dynamic dispatch.
type IAlter_table_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Simple_table_ref() ISimple_table_refContext
	AllAlter_table_action() []IAlter_table_actionContext
	Alter_table_action(i int) IAlter_table_actionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlter_table_stmtContext differentiates from other interfaces.
	IsAlter_table_stmtContext()
}

type Alter_table_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_stmtContext() *Alter_table_stmtContext {
	var p = new(Alter_table_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_stmt
	return p
}

func InitEmptyAlter_table_stmtContext(p *Alter_table_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_stmt
}

func (*Alter_table_stmtContext) IsAlter_table_stmtContext() {}

func NewAlter_table_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_stmtContext {
	var p = new(Alter_table_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_stmt

	return p
}

func (s *Alter_table_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserALTER, 0)
}

func (s *Alter_table_stmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTABLE, 0)
}

func (s *Alter_table_stmtContext) Simple_table_ref() ISimple_table_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_table_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_table_refContext)
}

func (s *Alter_table_stmtContext) AllAlter_table_action() []IAlter_table_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlter_table_actionContext); ok {
			len++
		}
	}

	tst := make([]IAlter_table_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlter_table_actionContext); ok {
			tst[i] = t.(IAlter_table_actionContext)
			i++
		}
	}

	return tst
}

func (s *Alter_table_stmtContext) Alter_table_action(i int) IAlter_table_actionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_actionContext)
}

func (s *Alter_table_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Alter_table_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Alter_table_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_table_stmt(s)
	}
}

func (s *Alter_table_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_table_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_table_stmt() (localctx IAlter_table_stmtContext) {
	localctx = NewAlter_table_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, SQLv1Antlr4ParserRULE_alter_table_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2992)
		p.Match(SQLv1Antlr4ParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2993)
		p.Match(SQLv1Antlr4ParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2994)
		p.Simple_table_ref()
	}
	{
		p.SetState(2995)
		p.Alter_table_action()
	}
	p.SetState(3000)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(2996)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2997)
			p.Alter_table_action()
		}

		p.SetState(3002)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_actionContext is an interface to support dynamic dispatch.
type IAlter_table_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Alter_table_add_column() IAlter_table_add_columnContext
	Alter_table_drop_column() IAlter_table_drop_columnContext
	Alter_table_alter_column() IAlter_table_alter_columnContext
	Alter_table_add_column_family() IAlter_table_add_column_familyContext
	Alter_table_alter_column_family() IAlter_table_alter_column_familyContext
	Alter_table_set_table_setting_uncompat() IAlter_table_set_table_setting_uncompatContext
	Alter_table_set_table_setting_compat() IAlter_table_set_table_setting_compatContext
	Alter_table_reset_table_setting() IAlter_table_reset_table_settingContext
	Alter_table_add_index() IAlter_table_add_indexContext
	Alter_table_drop_index() IAlter_table_drop_indexContext
	Alter_table_rename_to() IAlter_table_rename_toContext
	Alter_table_add_changefeed() IAlter_table_add_changefeedContext
	Alter_table_alter_changefeed() IAlter_table_alter_changefeedContext
	Alter_table_drop_changefeed() IAlter_table_drop_changefeedContext
	Alter_table_rename_index_to() IAlter_table_rename_index_toContext
	Alter_table_alter_index() IAlter_table_alter_indexContext
	Alter_table_alter_column_drop_not_null() IAlter_table_alter_column_drop_not_nullContext

	// IsAlter_table_actionContext differentiates from other interfaces.
	IsAlter_table_actionContext()
}

type Alter_table_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_actionContext() *Alter_table_actionContext {
	var p = new(Alter_table_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_action
	return p
}

func InitEmptyAlter_table_actionContext(p *Alter_table_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_action
}

func (*Alter_table_actionContext) IsAlter_table_actionContext() {}

func NewAlter_table_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_actionContext {
	var p = new(Alter_table_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_action

	return p
}

func (s *Alter_table_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_actionContext) Alter_table_add_column() IAlter_table_add_columnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_add_columnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_add_columnContext)
}

func (s *Alter_table_actionContext) Alter_table_drop_column() IAlter_table_drop_columnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_drop_columnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_drop_columnContext)
}

func (s *Alter_table_actionContext) Alter_table_alter_column() IAlter_table_alter_columnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_alter_columnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_alter_columnContext)
}

func (s *Alter_table_actionContext) Alter_table_add_column_family() IAlter_table_add_column_familyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_add_column_familyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_add_column_familyContext)
}

func (s *Alter_table_actionContext) Alter_table_alter_column_family() IAlter_table_alter_column_familyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_alter_column_familyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_alter_column_familyContext)
}

func (s *Alter_table_actionContext) Alter_table_set_table_setting_uncompat() IAlter_table_set_table_setting_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_set_table_setting_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_set_table_setting_uncompatContext)
}

func (s *Alter_table_actionContext) Alter_table_set_table_setting_compat() IAlter_table_set_table_setting_compatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_set_table_setting_compatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_set_table_setting_compatContext)
}

func (s *Alter_table_actionContext) Alter_table_reset_table_setting() IAlter_table_reset_table_settingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_reset_table_settingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_reset_table_settingContext)
}

func (s *Alter_table_actionContext) Alter_table_add_index() IAlter_table_add_indexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_add_indexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_add_indexContext)
}

func (s *Alter_table_actionContext) Alter_table_drop_index() IAlter_table_drop_indexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_drop_indexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_drop_indexContext)
}

func (s *Alter_table_actionContext) Alter_table_rename_to() IAlter_table_rename_toContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_rename_toContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_rename_toContext)
}

func (s *Alter_table_actionContext) Alter_table_add_changefeed() IAlter_table_add_changefeedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_add_changefeedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_add_changefeedContext)
}

func (s *Alter_table_actionContext) Alter_table_alter_changefeed() IAlter_table_alter_changefeedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_alter_changefeedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_alter_changefeedContext)
}

func (s *Alter_table_actionContext) Alter_table_drop_changefeed() IAlter_table_drop_changefeedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_drop_changefeedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_drop_changefeedContext)
}

func (s *Alter_table_actionContext) Alter_table_rename_index_to() IAlter_table_rename_index_toContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_rename_index_toContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_rename_index_toContext)
}

func (s *Alter_table_actionContext) Alter_table_alter_index() IAlter_table_alter_indexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_alter_indexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_alter_indexContext)
}

func (s *Alter_table_actionContext) Alter_table_alter_column_drop_not_null() IAlter_table_alter_column_drop_not_nullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_alter_column_drop_not_nullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_alter_column_drop_not_nullContext)
}

func (s *Alter_table_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_table_action(s)
	}
}

func (s *Alter_table_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_table_action(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_table_action() (localctx IAlter_table_actionContext) {
	localctx = NewAlter_table_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, SQLv1Antlr4ParserRULE_alter_table_action)
	p.SetState(3020)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 299, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3003)
			p.Alter_table_add_column()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3004)
			p.Alter_table_drop_column()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3005)
			p.Alter_table_alter_column()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3006)
			p.Alter_table_add_column_family()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3007)
			p.Alter_table_alter_column_family()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3008)
			p.Alter_table_set_table_setting_uncompat()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3009)
			p.Alter_table_set_table_setting_compat()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3010)
			p.Alter_table_reset_table_setting()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3011)
			p.Alter_table_add_index()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3012)
			p.Alter_table_drop_index()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3013)
			p.Alter_table_rename_to()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3014)
			p.Alter_table_add_changefeed()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3015)
			p.Alter_table_alter_changefeed()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(3016)
			p.Alter_table_drop_changefeed()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(3017)
			p.Alter_table_rename_index_to()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(3018)
			p.Alter_table_alter_index()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(3019)
			p.Alter_table_alter_column_drop_not_null()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_external_table_stmtContext is an interface to support dynamic dispatch.
type IAlter_external_table_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Simple_table_ref() ISimple_table_refContext
	AllAlter_external_table_action() []IAlter_external_table_actionContext
	Alter_external_table_action(i int) IAlter_external_table_actionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlter_external_table_stmtContext differentiates from other interfaces.
	IsAlter_external_table_stmtContext()
}

type Alter_external_table_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_external_table_stmtContext() *Alter_external_table_stmtContext {
	var p = new(Alter_external_table_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_external_table_stmt
	return p
}

func InitEmptyAlter_external_table_stmtContext(p *Alter_external_table_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_external_table_stmt
}

func (*Alter_external_table_stmtContext) IsAlter_external_table_stmtContext() {}

func NewAlter_external_table_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_external_table_stmtContext {
	var p = new(Alter_external_table_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_external_table_stmt

	return p
}

func (s *Alter_external_table_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_external_table_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserALTER, 0)
}

func (s *Alter_external_table_stmtContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXTERNAL, 0)
}

func (s *Alter_external_table_stmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTABLE, 0)
}

func (s *Alter_external_table_stmtContext) Simple_table_ref() ISimple_table_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_table_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_table_refContext)
}

func (s *Alter_external_table_stmtContext) AllAlter_external_table_action() []IAlter_external_table_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlter_external_table_actionContext); ok {
			len++
		}
	}

	tst := make([]IAlter_external_table_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlter_external_table_actionContext); ok {
			tst[i] = t.(IAlter_external_table_actionContext)
			i++
		}
	}

	return tst
}

func (s *Alter_external_table_stmtContext) Alter_external_table_action(i int) IAlter_external_table_actionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_external_table_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_external_table_actionContext)
}

func (s *Alter_external_table_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Alter_external_table_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Alter_external_table_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_external_table_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_external_table_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_external_table_stmt(s)
	}
}

func (s *Alter_external_table_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_external_table_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_external_table_stmt() (localctx IAlter_external_table_stmtContext) {
	localctx = NewAlter_external_table_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, SQLv1Antlr4ParserRULE_alter_external_table_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3022)
		p.Match(SQLv1Antlr4ParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3023)
		p.Match(SQLv1Antlr4ParserEXTERNAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3024)
		p.Match(SQLv1Antlr4ParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3025)
		p.Simple_table_ref()
	}
	{
		p.SetState(3026)
		p.Alter_external_table_action()
	}
	p.SetState(3031)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(3027)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3028)
			p.Alter_external_table_action()
		}

		p.SetState(3033)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_external_table_actionContext is an interface to support dynamic dispatch.
type IAlter_external_table_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Alter_table_add_column() IAlter_table_add_columnContext
	Alter_table_drop_column() IAlter_table_drop_columnContext
	Alter_table_set_table_setting_uncompat() IAlter_table_set_table_setting_uncompatContext
	Alter_table_set_table_setting_compat() IAlter_table_set_table_setting_compatContext
	Alter_table_reset_table_setting() IAlter_table_reset_table_settingContext

	// IsAlter_external_table_actionContext differentiates from other interfaces.
	IsAlter_external_table_actionContext()
}

type Alter_external_table_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_external_table_actionContext() *Alter_external_table_actionContext {
	var p = new(Alter_external_table_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_external_table_action
	return p
}

func InitEmptyAlter_external_table_actionContext(p *Alter_external_table_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_external_table_action
}

func (*Alter_external_table_actionContext) IsAlter_external_table_actionContext() {}

func NewAlter_external_table_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_external_table_actionContext {
	var p = new(Alter_external_table_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_external_table_action

	return p
}

func (s *Alter_external_table_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_external_table_actionContext) Alter_table_add_column() IAlter_table_add_columnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_add_columnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_add_columnContext)
}

func (s *Alter_external_table_actionContext) Alter_table_drop_column() IAlter_table_drop_columnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_drop_columnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_drop_columnContext)
}

func (s *Alter_external_table_actionContext) Alter_table_set_table_setting_uncompat() IAlter_table_set_table_setting_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_set_table_setting_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_set_table_setting_uncompatContext)
}

func (s *Alter_external_table_actionContext) Alter_table_set_table_setting_compat() IAlter_table_set_table_setting_compatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_set_table_setting_compatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_set_table_setting_compatContext)
}

func (s *Alter_external_table_actionContext) Alter_table_reset_table_setting() IAlter_table_reset_table_settingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_reset_table_settingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_reset_table_settingContext)
}

func (s *Alter_external_table_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_external_table_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_external_table_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_external_table_action(s)
	}
}

func (s *Alter_external_table_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_external_table_action(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_external_table_action() (localctx IAlter_external_table_actionContext) {
	localctx = NewAlter_external_table_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, SQLv1Antlr4ParserRULE_alter_external_table_action)
	p.SetState(3039)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 301, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3034)
			p.Alter_table_add_column()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3035)
			p.Alter_table_drop_column()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3036)
			p.Alter_table_set_table_setting_uncompat()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3037)
			p.Alter_table_set_table_setting_compat()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3038)
			p.Alter_table_reset_table_setting()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_store_stmtContext is an interface to support dynamic dispatch.
type IAlter_table_store_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	TABLESTORE() antlr.TerminalNode
	Object_ref() IObject_refContext
	AllAlter_table_store_action() []IAlter_table_store_actionContext
	Alter_table_store_action(i int) IAlter_table_store_actionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlter_table_store_stmtContext differentiates from other interfaces.
	IsAlter_table_store_stmtContext()
}

type Alter_table_store_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_store_stmtContext() *Alter_table_store_stmtContext {
	var p = new(Alter_table_store_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_store_stmt
	return p
}

func InitEmptyAlter_table_store_stmtContext(p *Alter_table_store_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_store_stmt
}

func (*Alter_table_store_stmtContext) IsAlter_table_store_stmtContext() {}

func NewAlter_table_store_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_store_stmtContext {
	var p = new(Alter_table_store_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_store_stmt

	return p
}

func (s *Alter_table_store_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_store_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserALTER, 0)
}

func (s *Alter_table_store_stmtContext) TABLESTORE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTABLESTORE, 0)
}

func (s *Alter_table_store_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Alter_table_store_stmtContext) AllAlter_table_store_action() []IAlter_table_store_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlter_table_store_actionContext); ok {
			len++
		}
	}

	tst := make([]IAlter_table_store_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlter_table_store_actionContext); ok {
			tst[i] = t.(IAlter_table_store_actionContext)
			i++
		}
	}

	return tst
}

func (s *Alter_table_store_stmtContext) Alter_table_store_action(i int) IAlter_table_store_actionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_store_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_store_actionContext)
}

func (s *Alter_table_store_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Alter_table_store_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Alter_table_store_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_store_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_store_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_table_store_stmt(s)
	}
}

func (s *Alter_table_store_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_table_store_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_table_store_stmt() (localctx IAlter_table_store_stmtContext) {
	localctx = NewAlter_table_store_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, SQLv1Antlr4ParserRULE_alter_table_store_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3041)
		p.Match(SQLv1Antlr4ParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3042)
		p.Match(SQLv1Antlr4ParserTABLESTORE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3043)
		p.Object_ref()
	}
	{
		p.SetState(3044)
		p.Alter_table_store_action()
	}
	p.SetState(3049)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(3045)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3046)
			p.Alter_table_store_action()
		}

		p.SetState(3051)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_store_actionContext is an interface to support dynamic dispatch.
type IAlter_table_store_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Alter_table_add_column() IAlter_table_add_columnContext
	Alter_table_drop_column() IAlter_table_drop_columnContext

	// IsAlter_table_store_actionContext differentiates from other interfaces.
	IsAlter_table_store_actionContext()
}

type Alter_table_store_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_store_actionContext() *Alter_table_store_actionContext {
	var p = new(Alter_table_store_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_store_action
	return p
}

func InitEmptyAlter_table_store_actionContext(p *Alter_table_store_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_store_action
}

func (*Alter_table_store_actionContext) IsAlter_table_store_actionContext() {}

func NewAlter_table_store_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_store_actionContext {
	var p = new(Alter_table_store_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_store_action

	return p
}

func (s *Alter_table_store_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_store_actionContext) Alter_table_add_column() IAlter_table_add_columnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_add_columnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_add_columnContext)
}

func (s *Alter_table_store_actionContext) Alter_table_drop_column() IAlter_table_drop_columnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_drop_columnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_drop_columnContext)
}

func (s *Alter_table_store_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_store_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_store_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_table_store_action(s)
	}
}

func (s *Alter_table_store_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_table_store_action(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_table_store_action() (localctx IAlter_table_store_actionContext) {
	localctx = NewAlter_table_store_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, SQLv1Antlr4ParserRULE_alter_table_store_action)
	p.SetState(3054)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserADD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3052)
			p.Alter_table_add_column()
		}

	case SQLv1Antlr4ParserDROP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3053)
			p.Alter_table_drop_column()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_add_columnContext is an interface to support dynamic dispatch.
type IAlter_table_add_columnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	Column_schema() IColumn_schemaContext
	COLUMN() antlr.TerminalNode

	// IsAlter_table_add_columnContext differentiates from other interfaces.
	IsAlter_table_add_columnContext()
}

type Alter_table_add_columnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_add_columnContext() *Alter_table_add_columnContext {
	var p = new(Alter_table_add_columnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_add_column
	return p
}

func InitEmptyAlter_table_add_columnContext(p *Alter_table_add_columnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_add_column
}

func (*Alter_table_add_columnContext) IsAlter_table_add_columnContext() {}

func NewAlter_table_add_columnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_add_columnContext {
	var p = new(Alter_table_add_columnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_add_column

	return p
}

func (s *Alter_table_add_columnContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_add_columnContext) ADD() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserADD, 0)
}

func (s *Alter_table_add_columnContext) Column_schema() IColumn_schemaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_schemaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_schemaContext)
}

func (s *Alter_table_add_columnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOLUMN, 0)
}

func (s *Alter_table_add_columnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_add_columnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_add_columnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_table_add_column(s)
	}
}

func (s *Alter_table_add_columnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_table_add_column(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_table_add_column() (localctx IAlter_table_add_columnContext) {
	localctx = NewAlter_table_add_columnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, SQLv1Antlr4ParserRULE_alter_table_add_column)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3056)
		p.Match(SQLv1Antlr4ParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3058)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserCOLUMN {
		{
			p.SetState(3057)
			p.Match(SQLv1Antlr4ParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3060)
		p.Column_schema()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_drop_columnContext is an interface to support dynamic dispatch.
type IAlter_table_drop_columnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	An_id() IAn_idContext
	COLUMN() antlr.TerminalNode

	// IsAlter_table_drop_columnContext differentiates from other interfaces.
	IsAlter_table_drop_columnContext()
}

type Alter_table_drop_columnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_drop_columnContext() *Alter_table_drop_columnContext {
	var p = new(Alter_table_drop_columnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_drop_column
	return p
}

func InitEmptyAlter_table_drop_columnContext(p *Alter_table_drop_columnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_drop_column
}

func (*Alter_table_drop_columnContext) IsAlter_table_drop_columnContext() {}

func NewAlter_table_drop_columnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_drop_columnContext {
	var p = new(Alter_table_drop_columnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_drop_column

	return p
}

func (s *Alter_table_drop_columnContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_drop_columnContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDROP, 0)
}

func (s *Alter_table_drop_columnContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Alter_table_drop_columnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOLUMN, 0)
}

func (s *Alter_table_drop_columnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_drop_columnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_drop_columnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_table_drop_column(s)
	}
}

func (s *Alter_table_drop_columnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_table_drop_column(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_table_drop_column() (localctx IAlter_table_drop_columnContext) {
	localctx = NewAlter_table_drop_columnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, SQLv1Antlr4ParserRULE_alter_table_drop_column)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3062)
		p.Match(SQLv1Antlr4ParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3064)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 305, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3063)
			p.Match(SQLv1Antlr4ParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3066)
		p.An_id()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_alter_columnContext is an interface to support dynamic dispatch.
type IAlter_table_alter_columnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	An_id() IAn_idContext
	SET() antlr.TerminalNode
	Family_relation() IFamily_relationContext

	// IsAlter_table_alter_columnContext differentiates from other interfaces.
	IsAlter_table_alter_columnContext()
}

type Alter_table_alter_columnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_alter_columnContext() *Alter_table_alter_columnContext {
	var p = new(Alter_table_alter_columnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_alter_column
	return p
}

func InitEmptyAlter_table_alter_columnContext(p *Alter_table_alter_columnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_alter_column
}

func (*Alter_table_alter_columnContext) IsAlter_table_alter_columnContext() {}

func NewAlter_table_alter_columnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_alter_columnContext {
	var p = new(Alter_table_alter_columnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_alter_column

	return p
}

func (s *Alter_table_alter_columnContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_alter_columnContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserALTER, 0)
}

func (s *Alter_table_alter_columnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOLUMN, 0)
}

func (s *Alter_table_alter_columnContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Alter_table_alter_columnContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSET, 0)
}

func (s *Alter_table_alter_columnContext) Family_relation() IFamily_relationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFamily_relationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFamily_relationContext)
}

func (s *Alter_table_alter_columnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_alter_columnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_alter_columnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_table_alter_column(s)
	}
}

func (s *Alter_table_alter_columnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_table_alter_column(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_table_alter_column() (localctx IAlter_table_alter_columnContext) {
	localctx = NewAlter_table_alter_columnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, SQLv1Antlr4ParserRULE_alter_table_alter_column)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3068)
		p.Match(SQLv1Antlr4ParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3069)
		p.Match(SQLv1Antlr4ParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3070)
		p.An_id()
	}
	{
		p.SetState(3071)
		p.Match(SQLv1Antlr4ParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3072)
		p.Family_relation()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_alter_column_drop_not_nullContext is an interface to support dynamic dispatch.
type IAlter_table_alter_column_drop_not_nullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	An_id() IAn_idContext
	DROP() antlr.TerminalNode
	NOT() antlr.TerminalNode
	NULL() antlr.TerminalNode

	// IsAlter_table_alter_column_drop_not_nullContext differentiates from other interfaces.
	IsAlter_table_alter_column_drop_not_nullContext()
}

type Alter_table_alter_column_drop_not_nullContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_alter_column_drop_not_nullContext() *Alter_table_alter_column_drop_not_nullContext {
	var p = new(Alter_table_alter_column_drop_not_nullContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_alter_column_drop_not_null
	return p
}

func InitEmptyAlter_table_alter_column_drop_not_nullContext(p *Alter_table_alter_column_drop_not_nullContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_alter_column_drop_not_null
}

func (*Alter_table_alter_column_drop_not_nullContext) IsAlter_table_alter_column_drop_not_nullContext() {
}

func NewAlter_table_alter_column_drop_not_nullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_alter_column_drop_not_nullContext {
	var p = new(Alter_table_alter_column_drop_not_nullContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_alter_column_drop_not_null

	return p
}

func (s *Alter_table_alter_column_drop_not_nullContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_alter_column_drop_not_nullContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserALTER, 0)
}

func (s *Alter_table_alter_column_drop_not_nullContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOLUMN, 0)
}

func (s *Alter_table_alter_column_drop_not_nullContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Alter_table_alter_column_drop_not_nullContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDROP, 0)
}

func (s *Alter_table_alter_column_drop_not_nullContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNOT, 0)
}

func (s *Alter_table_alter_column_drop_not_nullContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNULL, 0)
}

func (s *Alter_table_alter_column_drop_not_nullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_alter_column_drop_not_nullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_alter_column_drop_not_nullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_table_alter_column_drop_not_null(s)
	}
}

func (s *Alter_table_alter_column_drop_not_nullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_table_alter_column_drop_not_null(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_table_alter_column_drop_not_null() (localctx IAlter_table_alter_column_drop_not_nullContext) {
	localctx = NewAlter_table_alter_column_drop_not_nullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, SQLv1Antlr4ParserRULE_alter_table_alter_column_drop_not_null)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3074)
		p.Match(SQLv1Antlr4ParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3075)
		p.Match(SQLv1Antlr4ParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3076)
		p.An_id()
	}
	{
		p.SetState(3077)
		p.Match(SQLv1Antlr4ParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3078)
		p.Match(SQLv1Antlr4ParserNOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3079)
		p.Match(SQLv1Antlr4ParserNULL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_add_column_familyContext is an interface to support dynamic dispatch.
type IAlter_table_add_column_familyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	Family_entry() IFamily_entryContext

	// IsAlter_table_add_column_familyContext differentiates from other interfaces.
	IsAlter_table_add_column_familyContext()
}

type Alter_table_add_column_familyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_add_column_familyContext() *Alter_table_add_column_familyContext {
	var p = new(Alter_table_add_column_familyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_add_column_family
	return p
}

func InitEmptyAlter_table_add_column_familyContext(p *Alter_table_add_column_familyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_add_column_family
}

func (*Alter_table_add_column_familyContext) IsAlter_table_add_column_familyContext() {}

func NewAlter_table_add_column_familyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_add_column_familyContext {
	var p = new(Alter_table_add_column_familyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_add_column_family

	return p
}

func (s *Alter_table_add_column_familyContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_add_column_familyContext) ADD() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserADD, 0)
}

func (s *Alter_table_add_column_familyContext) Family_entry() IFamily_entryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFamily_entryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFamily_entryContext)
}

func (s *Alter_table_add_column_familyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_add_column_familyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_add_column_familyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_table_add_column_family(s)
	}
}

func (s *Alter_table_add_column_familyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_table_add_column_family(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_table_add_column_family() (localctx IAlter_table_add_column_familyContext) {
	localctx = NewAlter_table_add_column_familyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, SQLv1Antlr4ParserRULE_alter_table_add_column_family)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3081)
		p.Match(SQLv1Antlr4ParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3082)
		p.Family_entry()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_alter_column_familyContext is an interface to support dynamic dispatch.
type IAlter_table_alter_column_familyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	FAMILY() antlr.TerminalNode
	AllAn_id() []IAn_idContext
	An_id(i int) IAn_idContext
	SET() antlr.TerminalNode
	Family_setting_value() IFamily_setting_valueContext

	// IsAlter_table_alter_column_familyContext differentiates from other interfaces.
	IsAlter_table_alter_column_familyContext()
}

type Alter_table_alter_column_familyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_alter_column_familyContext() *Alter_table_alter_column_familyContext {
	var p = new(Alter_table_alter_column_familyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_alter_column_family
	return p
}

func InitEmptyAlter_table_alter_column_familyContext(p *Alter_table_alter_column_familyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_alter_column_family
}

func (*Alter_table_alter_column_familyContext) IsAlter_table_alter_column_familyContext() {}

func NewAlter_table_alter_column_familyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_alter_column_familyContext {
	var p = new(Alter_table_alter_column_familyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_alter_column_family

	return p
}

func (s *Alter_table_alter_column_familyContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_alter_column_familyContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserALTER, 0)
}

func (s *Alter_table_alter_column_familyContext) FAMILY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFAMILY, 0)
}

func (s *Alter_table_alter_column_familyContext) AllAn_id() []IAn_idContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_idContext); ok {
			len++
		}
	}

	tst := make([]IAn_idContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_idContext); ok {
			tst[i] = t.(IAn_idContext)
			i++
		}
	}

	return tst
}

func (s *Alter_table_alter_column_familyContext) An_id(i int) IAn_idContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Alter_table_alter_column_familyContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSET, 0)
}

func (s *Alter_table_alter_column_familyContext) Family_setting_value() IFamily_setting_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFamily_setting_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFamily_setting_valueContext)
}

func (s *Alter_table_alter_column_familyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_alter_column_familyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_alter_column_familyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_table_alter_column_family(s)
	}
}

func (s *Alter_table_alter_column_familyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_table_alter_column_family(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_table_alter_column_family() (localctx IAlter_table_alter_column_familyContext) {
	localctx = NewAlter_table_alter_column_familyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, SQLv1Antlr4ParserRULE_alter_table_alter_column_family)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3084)
		p.Match(SQLv1Antlr4ParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3085)
		p.Match(SQLv1Antlr4ParserFAMILY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3086)
		p.An_id()
	}
	{
		p.SetState(3087)
		p.Match(SQLv1Antlr4ParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3088)
		p.An_id()
	}
	{
		p.SetState(3089)
		p.Family_setting_value()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_set_table_setting_uncompatContext is an interface to support dynamic dispatch.
type IAlter_table_set_table_setting_uncompatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	An_id() IAn_idContext
	Table_setting_value() ITable_setting_valueContext

	// IsAlter_table_set_table_setting_uncompatContext differentiates from other interfaces.
	IsAlter_table_set_table_setting_uncompatContext()
}

type Alter_table_set_table_setting_uncompatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_set_table_setting_uncompatContext() *Alter_table_set_table_setting_uncompatContext {
	var p = new(Alter_table_set_table_setting_uncompatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_set_table_setting_uncompat
	return p
}

func InitEmptyAlter_table_set_table_setting_uncompatContext(p *Alter_table_set_table_setting_uncompatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_set_table_setting_uncompat
}

func (*Alter_table_set_table_setting_uncompatContext) IsAlter_table_set_table_setting_uncompatContext() {
}

func NewAlter_table_set_table_setting_uncompatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_set_table_setting_uncompatContext {
	var p = new(Alter_table_set_table_setting_uncompatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_set_table_setting_uncompat

	return p
}

func (s *Alter_table_set_table_setting_uncompatContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_set_table_setting_uncompatContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSET, 0)
}

func (s *Alter_table_set_table_setting_uncompatContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Alter_table_set_table_setting_uncompatContext) Table_setting_value() ITable_setting_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_setting_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_setting_valueContext)
}

func (s *Alter_table_set_table_setting_uncompatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_set_table_setting_uncompatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_set_table_setting_uncompatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_table_set_table_setting_uncompat(s)
	}
}

func (s *Alter_table_set_table_setting_uncompatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_table_set_table_setting_uncompat(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_table_set_table_setting_uncompat() (localctx IAlter_table_set_table_setting_uncompatContext) {
	localctx = NewAlter_table_set_table_setting_uncompatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, SQLv1Antlr4ParserRULE_alter_table_set_table_setting_uncompat)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3091)
		p.Match(SQLv1Antlr4ParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3092)
		p.An_id()
	}
	{
		p.SetState(3093)
		p.Table_setting_value()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_set_table_setting_compatContext is an interface to support dynamic dispatch.
type IAlter_table_set_table_setting_compatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllAlter_table_setting_entry() []IAlter_table_setting_entryContext
	Alter_table_setting_entry(i int) IAlter_table_setting_entryContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlter_table_set_table_setting_compatContext differentiates from other interfaces.
	IsAlter_table_set_table_setting_compatContext()
}

type Alter_table_set_table_setting_compatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_set_table_setting_compatContext() *Alter_table_set_table_setting_compatContext {
	var p = new(Alter_table_set_table_setting_compatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_set_table_setting_compat
	return p
}

func InitEmptyAlter_table_set_table_setting_compatContext(p *Alter_table_set_table_setting_compatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_set_table_setting_compat
}

func (*Alter_table_set_table_setting_compatContext) IsAlter_table_set_table_setting_compatContext() {}

func NewAlter_table_set_table_setting_compatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_set_table_setting_compatContext {
	var p = new(Alter_table_set_table_setting_compatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_set_table_setting_compat

	return p
}

func (s *Alter_table_set_table_setting_compatContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_set_table_setting_compatContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSET, 0)
}

func (s *Alter_table_set_table_setting_compatContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Alter_table_set_table_setting_compatContext) AllAlter_table_setting_entry() []IAlter_table_setting_entryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlter_table_setting_entryContext); ok {
			len++
		}
	}

	tst := make([]IAlter_table_setting_entryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlter_table_setting_entryContext); ok {
			tst[i] = t.(IAlter_table_setting_entryContext)
			i++
		}
	}

	return tst
}

func (s *Alter_table_set_table_setting_compatContext) Alter_table_setting_entry(i int) IAlter_table_setting_entryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_setting_entryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_setting_entryContext)
}

func (s *Alter_table_set_table_setting_compatContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Alter_table_set_table_setting_compatContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Alter_table_set_table_setting_compatContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Alter_table_set_table_setting_compatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_set_table_setting_compatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_set_table_setting_compatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_table_set_table_setting_compat(s)
	}
}

func (s *Alter_table_set_table_setting_compatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_table_set_table_setting_compat(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_table_set_table_setting_compat() (localctx IAlter_table_set_table_setting_compatContext) {
	localctx = NewAlter_table_set_table_setting_compatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, SQLv1Antlr4ParserRULE_alter_table_set_table_setting_compat)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3095)
		p.Match(SQLv1Antlr4ParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3096)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3097)
		p.Alter_table_setting_entry()
	}
	p.SetState(3102)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(3098)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3099)
			p.Alter_table_setting_entry()
		}

		p.SetState(3104)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3105)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_reset_table_settingContext is an interface to support dynamic dispatch.
type IAlter_table_reset_table_settingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESET() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllAn_id() []IAn_idContext
	An_id(i int) IAn_idContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlter_table_reset_table_settingContext differentiates from other interfaces.
	IsAlter_table_reset_table_settingContext()
}

type Alter_table_reset_table_settingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_reset_table_settingContext() *Alter_table_reset_table_settingContext {
	var p = new(Alter_table_reset_table_settingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_reset_table_setting
	return p
}

func InitEmptyAlter_table_reset_table_settingContext(p *Alter_table_reset_table_settingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_reset_table_setting
}

func (*Alter_table_reset_table_settingContext) IsAlter_table_reset_table_settingContext() {}

func NewAlter_table_reset_table_settingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_reset_table_settingContext {
	var p = new(Alter_table_reset_table_settingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_reset_table_setting

	return p
}

func (s *Alter_table_reset_table_settingContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_reset_table_settingContext) RESET() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRESET, 0)
}

func (s *Alter_table_reset_table_settingContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Alter_table_reset_table_settingContext) AllAn_id() []IAn_idContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_idContext); ok {
			len++
		}
	}

	tst := make([]IAn_idContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_idContext); ok {
			tst[i] = t.(IAn_idContext)
			i++
		}
	}

	return tst
}

func (s *Alter_table_reset_table_settingContext) An_id(i int) IAn_idContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Alter_table_reset_table_settingContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Alter_table_reset_table_settingContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Alter_table_reset_table_settingContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Alter_table_reset_table_settingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_reset_table_settingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_reset_table_settingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_table_reset_table_setting(s)
	}
}

func (s *Alter_table_reset_table_settingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_table_reset_table_setting(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_table_reset_table_setting() (localctx IAlter_table_reset_table_settingContext) {
	localctx = NewAlter_table_reset_table_settingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, SQLv1Antlr4ParserRULE_alter_table_reset_table_setting)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3107)
		p.Match(SQLv1Antlr4ParserRESET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3108)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3109)
		p.An_id()
	}
	p.SetState(3114)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(3110)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3111)
			p.An_id()
		}

		p.SetState(3116)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3117)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_add_indexContext is an interface to support dynamic dispatch.
type IAlter_table_add_indexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	Table_index() ITable_indexContext

	// IsAlter_table_add_indexContext differentiates from other interfaces.
	IsAlter_table_add_indexContext()
}

type Alter_table_add_indexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_add_indexContext() *Alter_table_add_indexContext {
	var p = new(Alter_table_add_indexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_add_index
	return p
}

func InitEmptyAlter_table_add_indexContext(p *Alter_table_add_indexContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_add_index
}

func (*Alter_table_add_indexContext) IsAlter_table_add_indexContext() {}

func NewAlter_table_add_indexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_add_indexContext {
	var p = new(Alter_table_add_indexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_add_index

	return p
}

func (s *Alter_table_add_indexContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_add_indexContext) ADD() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserADD, 0)
}

func (s *Alter_table_add_indexContext) Table_index() ITable_indexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_indexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_indexContext)
}

func (s *Alter_table_add_indexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_add_indexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_add_indexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_table_add_index(s)
	}
}

func (s *Alter_table_add_indexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_table_add_index(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_table_add_index() (localctx IAlter_table_add_indexContext) {
	localctx = NewAlter_table_add_indexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, SQLv1Antlr4ParserRULE_alter_table_add_index)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3119)
		p.Match(SQLv1Antlr4ParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3120)
		p.Table_index()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_drop_indexContext is an interface to support dynamic dispatch.
type IAlter_table_drop_indexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	An_id() IAn_idContext

	// IsAlter_table_drop_indexContext differentiates from other interfaces.
	IsAlter_table_drop_indexContext()
}

type Alter_table_drop_indexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_drop_indexContext() *Alter_table_drop_indexContext {
	var p = new(Alter_table_drop_indexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_drop_index
	return p
}

func InitEmptyAlter_table_drop_indexContext(p *Alter_table_drop_indexContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_drop_index
}

func (*Alter_table_drop_indexContext) IsAlter_table_drop_indexContext() {}

func NewAlter_table_drop_indexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_drop_indexContext {
	var p = new(Alter_table_drop_indexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_drop_index

	return p
}

func (s *Alter_table_drop_indexContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_drop_indexContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDROP, 0)
}

func (s *Alter_table_drop_indexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINDEX, 0)
}

func (s *Alter_table_drop_indexContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Alter_table_drop_indexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_drop_indexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_drop_indexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_table_drop_index(s)
	}
}

func (s *Alter_table_drop_indexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_table_drop_index(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_table_drop_index() (localctx IAlter_table_drop_indexContext) {
	localctx = NewAlter_table_drop_indexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, SQLv1Antlr4ParserRULE_alter_table_drop_index)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3122)
		p.Match(SQLv1Antlr4ParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3123)
		p.Match(SQLv1Antlr4ParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3124)
		p.An_id()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_rename_toContext is an interface to support dynamic dispatch.
type IAlter_table_rename_toContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RENAME() antlr.TerminalNode
	TO() antlr.TerminalNode
	An_id_table() IAn_id_tableContext

	// IsAlter_table_rename_toContext differentiates from other interfaces.
	IsAlter_table_rename_toContext()
}

type Alter_table_rename_toContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_rename_toContext() *Alter_table_rename_toContext {
	var p = new(Alter_table_rename_toContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_rename_to
	return p
}

func InitEmptyAlter_table_rename_toContext(p *Alter_table_rename_toContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_rename_to
}

func (*Alter_table_rename_toContext) IsAlter_table_rename_toContext() {}

func NewAlter_table_rename_toContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_rename_toContext {
	var p = new(Alter_table_rename_toContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_rename_to

	return p
}

func (s *Alter_table_rename_toContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_rename_toContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRENAME, 0)
}

func (s *Alter_table_rename_toContext) TO() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTO, 0)
}

func (s *Alter_table_rename_toContext) An_id_table() IAn_id_tableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_tableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_tableContext)
}

func (s *Alter_table_rename_toContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_rename_toContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_rename_toContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_table_rename_to(s)
	}
}

func (s *Alter_table_rename_toContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_table_rename_to(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_table_rename_to() (localctx IAlter_table_rename_toContext) {
	localctx = NewAlter_table_rename_toContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, SQLv1Antlr4ParserRULE_alter_table_rename_to)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3126)
		p.Match(SQLv1Antlr4ParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3127)
		p.Match(SQLv1Antlr4ParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3128)
		p.An_id_table()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_rename_index_toContext is an interface to support dynamic dispatch.
type IAlter_table_rename_index_toContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RENAME() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	AllAn_id() []IAn_idContext
	An_id(i int) IAn_idContext
	TO() antlr.TerminalNode

	// IsAlter_table_rename_index_toContext differentiates from other interfaces.
	IsAlter_table_rename_index_toContext()
}

type Alter_table_rename_index_toContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_rename_index_toContext() *Alter_table_rename_index_toContext {
	var p = new(Alter_table_rename_index_toContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_rename_index_to
	return p
}

func InitEmptyAlter_table_rename_index_toContext(p *Alter_table_rename_index_toContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_rename_index_to
}

func (*Alter_table_rename_index_toContext) IsAlter_table_rename_index_toContext() {}

func NewAlter_table_rename_index_toContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_rename_index_toContext {
	var p = new(Alter_table_rename_index_toContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_rename_index_to

	return p
}

func (s *Alter_table_rename_index_toContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_rename_index_toContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRENAME, 0)
}

func (s *Alter_table_rename_index_toContext) INDEX() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINDEX, 0)
}

func (s *Alter_table_rename_index_toContext) AllAn_id() []IAn_idContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_idContext); ok {
			len++
		}
	}

	tst := make([]IAn_idContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_idContext); ok {
			tst[i] = t.(IAn_idContext)
			i++
		}
	}

	return tst
}

func (s *Alter_table_rename_index_toContext) An_id(i int) IAn_idContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Alter_table_rename_index_toContext) TO() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTO, 0)
}

func (s *Alter_table_rename_index_toContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_rename_index_toContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_rename_index_toContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_table_rename_index_to(s)
	}
}

func (s *Alter_table_rename_index_toContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_table_rename_index_to(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_table_rename_index_to() (localctx IAlter_table_rename_index_toContext) {
	localctx = NewAlter_table_rename_index_toContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, SQLv1Antlr4ParserRULE_alter_table_rename_index_to)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3130)
		p.Match(SQLv1Antlr4ParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3131)
		p.Match(SQLv1Antlr4ParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3132)
		p.An_id()
	}
	{
		p.SetState(3133)
		p.Match(SQLv1Antlr4ParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3134)
		p.An_id()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_add_changefeedContext is an interface to support dynamic dispatch.
type IAlter_table_add_changefeedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	Changefeed() IChangefeedContext

	// IsAlter_table_add_changefeedContext differentiates from other interfaces.
	IsAlter_table_add_changefeedContext()
}

type Alter_table_add_changefeedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_add_changefeedContext() *Alter_table_add_changefeedContext {
	var p = new(Alter_table_add_changefeedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_add_changefeed
	return p
}

func InitEmptyAlter_table_add_changefeedContext(p *Alter_table_add_changefeedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_add_changefeed
}

func (*Alter_table_add_changefeedContext) IsAlter_table_add_changefeedContext() {}

func NewAlter_table_add_changefeedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_add_changefeedContext {
	var p = new(Alter_table_add_changefeedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_add_changefeed

	return p
}

func (s *Alter_table_add_changefeedContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_add_changefeedContext) ADD() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserADD, 0)
}

func (s *Alter_table_add_changefeedContext) Changefeed() IChangefeedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangefeedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangefeedContext)
}

func (s *Alter_table_add_changefeedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_add_changefeedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_add_changefeedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_table_add_changefeed(s)
	}
}

func (s *Alter_table_add_changefeedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_table_add_changefeed(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_table_add_changefeed() (localctx IAlter_table_add_changefeedContext) {
	localctx = NewAlter_table_add_changefeedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, SQLv1Antlr4ParserRULE_alter_table_add_changefeed)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3136)
		p.Match(SQLv1Antlr4ParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3137)
		p.Changefeed()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_alter_changefeedContext is an interface to support dynamic dispatch.
type IAlter_table_alter_changefeedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	CHANGEFEED() antlr.TerminalNode
	An_id() IAn_idContext
	Changefeed_alter_settings() IChangefeed_alter_settingsContext

	// IsAlter_table_alter_changefeedContext differentiates from other interfaces.
	IsAlter_table_alter_changefeedContext()
}

type Alter_table_alter_changefeedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_alter_changefeedContext() *Alter_table_alter_changefeedContext {
	var p = new(Alter_table_alter_changefeedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_alter_changefeed
	return p
}

func InitEmptyAlter_table_alter_changefeedContext(p *Alter_table_alter_changefeedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_alter_changefeed
}

func (*Alter_table_alter_changefeedContext) IsAlter_table_alter_changefeedContext() {}

func NewAlter_table_alter_changefeedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_alter_changefeedContext {
	var p = new(Alter_table_alter_changefeedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_alter_changefeed

	return p
}

func (s *Alter_table_alter_changefeedContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_alter_changefeedContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserALTER, 0)
}

func (s *Alter_table_alter_changefeedContext) CHANGEFEED() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCHANGEFEED, 0)
}

func (s *Alter_table_alter_changefeedContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Alter_table_alter_changefeedContext) Changefeed_alter_settings() IChangefeed_alter_settingsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangefeed_alter_settingsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangefeed_alter_settingsContext)
}

func (s *Alter_table_alter_changefeedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_alter_changefeedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_alter_changefeedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_table_alter_changefeed(s)
	}
}

func (s *Alter_table_alter_changefeedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_table_alter_changefeed(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_table_alter_changefeed() (localctx IAlter_table_alter_changefeedContext) {
	localctx = NewAlter_table_alter_changefeedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, SQLv1Antlr4ParserRULE_alter_table_alter_changefeed)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3139)
		p.Match(SQLv1Antlr4ParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3140)
		p.Match(SQLv1Antlr4ParserCHANGEFEED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3141)
		p.An_id()
	}
	{
		p.SetState(3142)
		p.Changefeed_alter_settings()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_drop_changefeedContext is an interface to support dynamic dispatch.
type IAlter_table_drop_changefeedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	CHANGEFEED() antlr.TerminalNode
	An_id() IAn_idContext

	// IsAlter_table_drop_changefeedContext differentiates from other interfaces.
	IsAlter_table_drop_changefeedContext()
}

type Alter_table_drop_changefeedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_drop_changefeedContext() *Alter_table_drop_changefeedContext {
	var p = new(Alter_table_drop_changefeedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_drop_changefeed
	return p
}

func InitEmptyAlter_table_drop_changefeedContext(p *Alter_table_drop_changefeedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_drop_changefeed
}

func (*Alter_table_drop_changefeedContext) IsAlter_table_drop_changefeedContext() {}

func NewAlter_table_drop_changefeedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_drop_changefeedContext {
	var p = new(Alter_table_drop_changefeedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_drop_changefeed

	return p
}

func (s *Alter_table_drop_changefeedContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_drop_changefeedContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDROP, 0)
}

func (s *Alter_table_drop_changefeedContext) CHANGEFEED() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCHANGEFEED, 0)
}

func (s *Alter_table_drop_changefeedContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Alter_table_drop_changefeedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_drop_changefeedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_drop_changefeedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_table_drop_changefeed(s)
	}
}

func (s *Alter_table_drop_changefeedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_table_drop_changefeed(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_table_drop_changefeed() (localctx IAlter_table_drop_changefeedContext) {
	localctx = NewAlter_table_drop_changefeedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, SQLv1Antlr4ParserRULE_alter_table_drop_changefeed)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3144)
		p.Match(SQLv1Antlr4ParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3145)
		p.Match(SQLv1Antlr4ParserCHANGEFEED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3146)
		p.An_id()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_alter_indexContext is an interface to support dynamic dispatch.
type IAlter_table_alter_indexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	An_id() IAn_idContext
	Alter_table_alter_index_action() IAlter_table_alter_index_actionContext

	// IsAlter_table_alter_indexContext differentiates from other interfaces.
	IsAlter_table_alter_indexContext()
}

type Alter_table_alter_indexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_alter_indexContext() *Alter_table_alter_indexContext {
	var p = new(Alter_table_alter_indexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_alter_index
	return p
}

func InitEmptyAlter_table_alter_indexContext(p *Alter_table_alter_indexContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_alter_index
}

func (*Alter_table_alter_indexContext) IsAlter_table_alter_indexContext() {}

func NewAlter_table_alter_indexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_alter_indexContext {
	var p = new(Alter_table_alter_indexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_alter_index

	return p
}

func (s *Alter_table_alter_indexContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_alter_indexContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserALTER, 0)
}

func (s *Alter_table_alter_indexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINDEX, 0)
}

func (s *Alter_table_alter_indexContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Alter_table_alter_indexContext) Alter_table_alter_index_action() IAlter_table_alter_index_actionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_alter_index_actionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_alter_index_actionContext)
}

func (s *Alter_table_alter_indexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_alter_indexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_alter_indexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_table_alter_index(s)
	}
}

func (s *Alter_table_alter_indexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_table_alter_index(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_table_alter_index() (localctx IAlter_table_alter_indexContext) {
	localctx = NewAlter_table_alter_indexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, SQLv1Antlr4ParserRULE_alter_table_alter_index)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3148)
		p.Match(SQLv1Antlr4ParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3149)
		p.Match(SQLv1Antlr4ParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3150)
		p.An_id()
	}
	{
		p.SetState(3151)
		p.Alter_table_alter_index_action()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumn_schemaContext is an interface to support dynamic dispatch.
type IColumn_schemaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id_schema() IAn_id_schemaContext
	Type_name_or_bind() IType_name_or_bindContext
	Opt_column_constraints() IOpt_column_constraintsContext
	Family_relation() IFamily_relationContext

	// IsColumn_schemaContext differentiates from other interfaces.
	IsColumn_schemaContext()
}

type Column_schemaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_schemaContext() *Column_schemaContext {
	var p = new(Column_schemaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_column_schema
	return p
}

func InitEmptyColumn_schemaContext(p *Column_schemaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_column_schema
}

func (*Column_schemaContext) IsColumn_schemaContext() {}

func NewColumn_schemaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_schemaContext {
	var p = new(Column_schemaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_column_schema

	return p
}

func (s *Column_schemaContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_schemaContext) An_id_schema() IAn_id_schemaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_schemaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_schemaContext)
}

func (s *Column_schemaContext) Type_name_or_bind() IType_name_or_bindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Column_schemaContext) Opt_column_constraints() IOpt_column_constraintsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_column_constraintsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_column_constraintsContext)
}

func (s *Column_schemaContext) Family_relation() IFamily_relationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFamily_relationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFamily_relationContext)
}

func (s *Column_schemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_schemaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Column_schemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterColumn_schema(s)
	}
}

func (s *Column_schemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitColumn_schema(s)
	}
}

func (p *SQLv1Antlr4Parser) Column_schema() (localctx IColumn_schemaContext) {
	localctx = NewColumn_schemaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, SQLv1Antlr4ParserRULE_column_schema)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3153)
		p.An_id_schema()
	}
	{
		p.SetState(3154)
		p.Type_name_or_bind()
	}
	p.SetState(3156)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserFAMILY {
		{
			p.SetState(3155)
			p.Family_relation()
		}

	}
	{
		p.SetState(3158)
		p.Opt_column_constraints()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFamily_relationContext is an interface to support dynamic dispatch.
type IFamily_relationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FAMILY() antlr.TerminalNode
	An_id() IAn_idContext

	// IsFamily_relationContext differentiates from other interfaces.
	IsFamily_relationContext()
}

type Family_relationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFamily_relationContext() *Family_relationContext {
	var p = new(Family_relationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_family_relation
	return p
}

func InitEmptyFamily_relationContext(p *Family_relationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_family_relation
}

func (*Family_relationContext) IsFamily_relationContext() {}

func NewFamily_relationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Family_relationContext {
	var p = new(Family_relationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_family_relation

	return p
}

func (s *Family_relationContext) GetParser() antlr.Parser { return s.parser }

func (s *Family_relationContext) FAMILY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFAMILY, 0)
}

func (s *Family_relationContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Family_relationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Family_relationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Family_relationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterFamily_relation(s)
	}
}

func (s *Family_relationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitFamily_relation(s)
	}
}

func (p *SQLv1Antlr4Parser) Family_relation() (localctx IFamily_relationContext) {
	localctx = NewFamily_relationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, SQLv1Antlr4ParserRULE_family_relation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3160)
		p.Match(SQLv1Antlr4ParserFAMILY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3161)
		p.An_id()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_column_constraintsContext is an interface to support dynamic dispatch.
type IOpt_column_constraintsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	Expr() IExprContext
	NOT() antlr.TerminalNode

	// IsOpt_column_constraintsContext differentiates from other interfaces.
	IsOpt_column_constraintsContext()
}

type Opt_column_constraintsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_column_constraintsContext() *Opt_column_constraintsContext {
	var p = new(Opt_column_constraintsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_opt_column_constraints
	return p
}

func InitEmptyOpt_column_constraintsContext(p *Opt_column_constraintsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_opt_column_constraints
}

func (*Opt_column_constraintsContext) IsOpt_column_constraintsContext() {}

func NewOpt_column_constraintsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_column_constraintsContext {
	var p = new(Opt_column_constraintsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_opt_column_constraints

	return p
}

func (s *Opt_column_constraintsContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_column_constraintsContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNULL, 0)
}

func (s *Opt_column_constraintsContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDEFAULT, 0)
}

func (s *Opt_column_constraintsContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Opt_column_constraintsContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNOT, 0)
}

func (s *Opt_column_constraintsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_column_constraintsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_column_constraintsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterOpt_column_constraints(s)
	}
}

func (s *Opt_column_constraintsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitOpt_column_constraints(s)
	}
}

func (p *SQLv1Antlr4Parser) Opt_column_constraints() (localctx IOpt_column_constraintsContext) {
	localctx = NewOpt_column_constraintsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, SQLv1Antlr4ParserRULE_opt_column_constraints)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3167)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserNOT || _la == SQLv1Antlr4ParserNULL {
		p.SetState(3164)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserNOT {
			{
				p.SetState(3163)
				p.Match(SQLv1Antlr4ParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3166)
			p.Match(SQLv1Antlr4ParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3171)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserDEFAULT {
		{
			p.SetState(3169)
			p.Match(SQLv1Antlr4ParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3170)
			p.Expr()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumn_order_by_specificationContext is an interface to support dynamic dispatch.
type IColumn_order_by_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsColumn_order_by_specificationContext differentiates from other interfaces.
	IsColumn_order_by_specificationContext()
}

type Column_order_by_specificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_order_by_specificationContext() *Column_order_by_specificationContext {
	var p = new(Column_order_by_specificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_column_order_by_specification
	return p
}

func InitEmptyColumn_order_by_specificationContext(p *Column_order_by_specificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_column_order_by_specification
}

func (*Column_order_by_specificationContext) IsColumn_order_by_specificationContext() {}

func NewColumn_order_by_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_order_by_specificationContext {
	var p = new(Column_order_by_specificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_column_order_by_specification

	return p
}

func (s *Column_order_by_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_order_by_specificationContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Column_order_by_specificationContext) ASC() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserASC, 0)
}

func (s *Column_order_by_specificationContext) DESC() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDESC, 0)
}

func (s *Column_order_by_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_order_by_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Column_order_by_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterColumn_order_by_specification(s)
	}
}

func (s *Column_order_by_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitColumn_order_by_specification(s)
	}
}

func (p *SQLv1Antlr4Parser) Column_order_by_specification() (localctx IColumn_order_by_specificationContext) {
	localctx = NewColumn_order_by_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, SQLv1Antlr4ParserRULE_column_order_by_specification)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3173)
		p.An_id()
	}
	p.SetState(3175)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserASC || _la == SQLv1Antlr4ParserDESC {
		{
			p.SetState(3174)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLv1Antlr4ParserASC || _la == SQLv1Antlr4ParserDESC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_constraintContext is an interface to support dynamic dispatch.
type ITable_constraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRIMARY() antlr.TerminalNode
	KEY() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllAn_id() []IAn_idContext
	An_id(i int) IAn_idContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	AllColumn_order_by_specification() []IColumn_order_by_specificationContext
	Column_order_by_specification(i int) IColumn_order_by_specificationContext

	// IsTable_constraintContext differentiates from other interfaces.
	IsTable_constraintContext()
}

type Table_constraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_constraintContext() *Table_constraintContext {
	var p = new(Table_constraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_constraint
	return p
}

func InitEmptyTable_constraintContext(p *Table_constraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_constraint
}

func (*Table_constraintContext) IsTable_constraintContext() {}

func NewTable_constraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_constraintContext {
	var p = new(Table_constraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_constraint

	return p
}

func (s *Table_constraintContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_constraintContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPRIMARY, 0)
}

func (s *Table_constraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserKEY, 0)
}

func (s *Table_constraintContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Table_constraintContext) AllAn_id() []IAn_idContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_idContext); ok {
			len++
		}
	}

	tst := make([]IAn_idContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_idContext); ok {
			tst[i] = t.(IAn_idContext)
			i++
		}
	}

	return tst
}

func (s *Table_constraintContext) An_id(i int) IAn_idContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Table_constraintContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Table_constraintContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Table_constraintContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Table_constraintContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPARTITION, 0)
}

func (s *Table_constraintContext) BY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserBY, 0)
}

func (s *Table_constraintContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserORDER, 0)
}

func (s *Table_constraintContext) AllColumn_order_by_specification() []IColumn_order_by_specificationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumn_order_by_specificationContext); ok {
			len++
		}
	}

	tst := make([]IColumn_order_by_specificationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumn_order_by_specificationContext); ok {
			tst[i] = t.(IColumn_order_by_specificationContext)
			i++
		}
	}

	return tst
}

func (s *Table_constraintContext) Column_order_by_specification(i int) IColumn_order_by_specificationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_order_by_specificationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_order_by_specificationContext)
}

func (s *Table_constraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_constraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_constraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterTable_constraint(s)
	}
}

func (s *Table_constraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitTable_constraint(s)
	}
}

func (p *SQLv1Antlr4Parser) Table_constraint() (localctx ITable_constraintContext) {
	localctx = NewTable_constraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, SQLv1Antlr4ParserRULE_table_constraint)
	var _la int

	p.SetState(3216)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserPRIMARY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3177)
			p.Match(SQLv1Antlr4ParserPRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3178)
			p.Match(SQLv1Antlr4ParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3179)
			p.Match(SQLv1Antlr4ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3180)
			p.An_id()
		}
		p.SetState(3185)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SQLv1Antlr4ParserCOMMA {
			{
				p.SetState(3181)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3182)
				p.An_id()
			}

			p.SetState(3187)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3188)
			p.Match(SQLv1Antlr4ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserPARTITION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3190)
			p.Match(SQLv1Antlr4ParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3191)
			p.Match(SQLv1Antlr4ParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3192)
			p.Match(SQLv1Antlr4ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3193)
			p.An_id()
		}
		p.SetState(3198)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SQLv1Antlr4ParserCOMMA {
			{
				p.SetState(3194)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3195)
				p.An_id()
			}

			p.SetState(3200)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3201)
			p.Match(SQLv1Antlr4ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserORDER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3203)
			p.Match(SQLv1Antlr4ParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3204)
			p.Match(SQLv1Antlr4ParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3205)
			p.Match(SQLv1Antlr4ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3206)
			p.Column_order_by_specification()
		}
		p.SetState(3211)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SQLv1Antlr4ParserCOMMA {
			{
				p.SetState(3207)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3208)
				p.Column_order_by_specification()
			}

			p.SetState(3213)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3214)
			p.Match(SQLv1Antlr4ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_indexContext is an interface to support dynamic dispatch.
type ITable_indexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INDEX() antlr.TerminalNode
	An_id() IAn_idContext
	Table_index_type() ITable_index_typeContext
	ON() antlr.TerminalNode
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	AllAn_id_schema() []IAn_id_schemaContext
	An_id_schema(i int) IAn_id_schemaContext
	AllRPAREN() []antlr.TerminalNode
	RPAREN(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	COVER() antlr.TerminalNode
	With_index_settings() IWith_index_settingsContext

	// IsTable_indexContext differentiates from other interfaces.
	IsTable_indexContext()
}

type Table_indexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_indexContext() *Table_indexContext {
	var p = new(Table_indexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_index
	return p
}

func InitEmptyTable_indexContext(p *Table_indexContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_index
}

func (*Table_indexContext) IsTable_indexContext() {}

func NewTable_indexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_indexContext {
	var p = new(Table_indexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_index

	return p
}

func (s *Table_indexContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_indexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINDEX, 0)
}

func (s *Table_indexContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Table_indexContext) Table_index_type() ITable_index_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_index_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_index_typeContext)
}

func (s *Table_indexContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserON, 0)
}

func (s *Table_indexContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserLPAREN)
}

func (s *Table_indexContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, i)
}

func (s *Table_indexContext) AllAn_id_schema() []IAn_id_schemaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_id_schemaContext); ok {
			len++
		}
	}

	tst := make([]IAn_id_schemaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_id_schemaContext); ok {
			tst[i] = t.(IAn_id_schemaContext)
			i++
		}
	}

	return tst
}

func (s *Table_indexContext) An_id_schema(i int) IAn_id_schemaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_schemaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_schemaContext)
}

func (s *Table_indexContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserRPAREN)
}

func (s *Table_indexContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, i)
}

func (s *Table_indexContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Table_indexContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Table_indexContext) COVER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOVER, 0)
}

func (s *Table_indexContext) With_index_settings() IWith_index_settingsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_index_settingsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_index_settingsContext)
}

func (s *Table_indexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_indexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_indexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterTable_index(s)
	}
}

func (s *Table_indexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitTable_index(s)
	}
}

func (p *SQLv1Antlr4Parser) Table_index() (localctx ITable_indexContext) {
	localctx = NewTable_indexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, SQLv1Antlr4ParserRULE_table_index)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3218)
		p.Match(SQLv1Antlr4ParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3219)
		p.An_id()
	}
	{
		p.SetState(3220)
		p.Table_index_type()
	}
	{
		p.SetState(3221)
		p.Match(SQLv1Antlr4ParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3222)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3223)
		p.An_id_schema()
	}
	p.SetState(3228)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(3224)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3225)
			p.An_id_schema()
		}

		p.SetState(3230)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3231)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3244)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserCOVER {
		{
			p.SetState(3232)
			p.Match(SQLv1Antlr4ParserCOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3233)
			p.Match(SQLv1Antlr4ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3234)
			p.An_id_schema()
		}
		p.SetState(3239)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SQLv1Antlr4ParserCOMMA {
			{
				p.SetState(3235)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3236)
				p.An_id_schema()
			}

			p.SetState(3241)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3242)
			p.Match(SQLv1Antlr4ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3247)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserWITH {
		{
			p.SetState(3246)
			p.With_index_settings()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_index_typeContext is an interface to support dynamic dispatch.
type ITable_index_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Global_index() IGlobal_indexContext
	Local_index() ILocal_indexContext
	USING() antlr.TerminalNode
	Index_subtype() IIndex_subtypeContext

	// IsTable_index_typeContext differentiates from other interfaces.
	IsTable_index_typeContext()
}

type Table_index_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_index_typeContext() *Table_index_typeContext {
	var p = new(Table_index_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_index_type
	return p
}

func InitEmptyTable_index_typeContext(p *Table_index_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_index_type
}

func (*Table_index_typeContext) IsTable_index_typeContext() {}

func NewTable_index_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_index_typeContext {
	var p = new(Table_index_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_index_type

	return p
}

func (s *Table_index_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_index_typeContext) Global_index() IGlobal_indexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGlobal_indexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGlobal_indexContext)
}

func (s *Table_index_typeContext) Local_index() ILocal_indexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocal_indexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocal_indexContext)
}

func (s *Table_index_typeContext) USING() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUSING, 0)
}

func (s *Table_index_typeContext) Index_subtype() IIndex_subtypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_subtypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_subtypeContext)
}

func (s *Table_index_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_index_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_index_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterTable_index_type(s)
	}
}

func (s *Table_index_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitTable_index_type(s)
	}
}

func (p *SQLv1Antlr4Parser) Table_index_type() (localctx ITable_index_typeContext) {
	localctx = NewTable_index_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, SQLv1Antlr4ParserRULE_table_index_type)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3251)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserGLOBAL:
		{
			p.SetState(3249)
			p.Global_index()
		}

	case SQLv1Antlr4ParserLOCAL:
		{
			p.SetState(3250)
			p.Local_index()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(3255)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserUSING {
		{
			p.SetState(3253)
			p.Match(SQLv1Antlr4ParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3254)
			p.Index_subtype()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGlobal_indexContext is an interface to support dynamic dispatch.
type IGlobal_indexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GLOBAL() antlr.TerminalNode
	UNIQUE() antlr.TerminalNode
	SYNC() antlr.TerminalNode
	ASYNC() antlr.TerminalNode

	// IsGlobal_indexContext differentiates from other interfaces.
	IsGlobal_indexContext()
}

type Global_indexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobal_indexContext() *Global_indexContext {
	var p = new(Global_indexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_global_index
	return p
}

func InitEmptyGlobal_indexContext(p *Global_indexContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_global_index
}

func (*Global_indexContext) IsGlobal_indexContext() {}

func NewGlobal_indexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Global_indexContext {
	var p = new(Global_indexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_global_index

	return p
}

func (s *Global_indexContext) GetParser() antlr.Parser { return s.parser }

func (s *Global_indexContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGLOBAL, 0)
}

func (s *Global_indexContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUNIQUE, 0)
}

func (s *Global_indexContext) SYNC() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSYNC, 0)
}

func (s *Global_indexContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserASYNC, 0)
}

func (s *Global_indexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Global_indexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Global_indexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterGlobal_index(s)
	}
}

func (s *Global_indexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitGlobal_index(s)
	}
}

func (p *SQLv1Antlr4Parser) Global_index() (localctx IGlobal_indexContext) {
	localctx = NewGlobal_indexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, SQLv1Antlr4ParserRULE_global_index)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3257)
		p.Match(SQLv1Antlr4ParserGLOBAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3259)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserUNIQUE {
		{
			p.SetState(3258)
			p.Match(SQLv1Antlr4ParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3262)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserASYNC || _la == SQLv1Antlr4ParserSYNC {
		{
			p.SetState(3261)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLv1Antlr4ParserASYNC || _la == SQLv1Antlr4ParserSYNC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILocal_indexContext is an interface to support dynamic dispatch.
type ILocal_indexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCAL() antlr.TerminalNode

	// IsLocal_indexContext differentiates from other interfaces.
	IsLocal_indexContext()
}

type Local_indexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocal_indexContext() *Local_indexContext {
	var p = new(Local_indexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_local_index
	return p
}

func InitEmptyLocal_indexContext(p *Local_indexContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_local_index
}

func (*Local_indexContext) IsLocal_indexContext() {}

func NewLocal_indexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Local_indexContext {
	var p = new(Local_indexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_local_index

	return p
}

func (s *Local_indexContext) GetParser() antlr.Parser { return s.parser }

func (s *Local_indexContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLOCAL, 0)
}

func (s *Local_indexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Local_indexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Local_indexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterLocal_index(s)
	}
}

func (s *Local_indexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitLocal_index(s)
	}
}

func (p *SQLv1Antlr4Parser) Local_index() (localctx ILocal_indexContext) {
	localctx = NewLocal_indexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, SQLv1Antlr4ParserRULE_local_index)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3264)
		p.Match(SQLv1Antlr4ParserLOCAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndex_subtypeContext is an interface to support dynamic dispatch.
type IIndex_subtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext

	// IsIndex_subtypeContext differentiates from other interfaces.
	IsIndex_subtypeContext()
}

type Index_subtypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_subtypeContext() *Index_subtypeContext {
	var p = new(Index_subtypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_index_subtype
	return p
}

func InitEmptyIndex_subtypeContext(p *Index_subtypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_index_subtype
}

func (*Index_subtypeContext) IsIndex_subtypeContext() {}

func NewIndex_subtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_subtypeContext {
	var p = new(Index_subtypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_index_subtype

	return p
}

func (s *Index_subtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_subtypeContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Index_subtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_subtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_subtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterIndex_subtype(s)
	}
}

func (s *Index_subtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitIndex_subtype(s)
	}
}

func (p *SQLv1Antlr4Parser) Index_subtype() (localctx IIndex_subtypeContext) {
	localctx = NewIndex_subtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, SQLv1Antlr4ParserRULE_index_subtype)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3266)
		p.An_id()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWith_index_settingsContext is an interface to support dynamic dispatch.
type IWith_index_settingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllIndex_setting_entry() []IIndex_setting_entryContext
	Index_setting_entry(i int) IIndex_setting_entryContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWith_index_settingsContext differentiates from other interfaces.
	IsWith_index_settingsContext()
}

type With_index_settingsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_index_settingsContext() *With_index_settingsContext {
	var p = new(With_index_settingsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_with_index_settings
	return p
}

func InitEmptyWith_index_settingsContext(p *With_index_settingsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_with_index_settings
}

func (*With_index_settingsContext) IsWith_index_settingsContext() {}

func NewWith_index_settingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_index_settingsContext {
	var p = new(With_index_settingsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_with_index_settings

	return p
}

func (s *With_index_settingsContext) GetParser() antlr.Parser { return s.parser }

func (s *With_index_settingsContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWITH, 0)
}

func (s *With_index_settingsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *With_index_settingsContext) AllIndex_setting_entry() []IIndex_setting_entryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndex_setting_entryContext); ok {
			len++
		}
	}

	tst := make([]IIndex_setting_entryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndex_setting_entryContext); ok {
			tst[i] = t.(IIndex_setting_entryContext)
			i++
		}
	}

	return tst
}

func (s *With_index_settingsContext) Index_setting_entry(i int) IIndex_setting_entryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_setting_entryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_setting_entryContext)
}

func (s *With_index_settingsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *With_index_settingsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *With_index_settingsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *With_index_settingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_index_settingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *With_index_settingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterWith_index_settings(s)
	}
}

func (s *With_index_settingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitWith_index_settings(s)
	}
}

func (p *SQLv1Antlr4Parser) With_index_settings() (localctx IWith_index_settingsContext) {
	localctx = NewWith_index_settingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, SQLv1Antlr4ParserRULE_with_index_settings)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3268)
		p.Match(SQLv1Antlr4ParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3269)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3270)
		p.Index_setting_entry()
	}
	p.SetState(3275)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 325, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3271)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3272)
				p.Index_setting_entry()
			}

		}
		p.SetState(3277)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 325, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(3279)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(3278)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3281)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndex_setting_entryContext is an interface to support dynamic dispatch.
type IIndex_setting_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext
	EQUALS() antlr.TerminalNode
	Index_setting_value() IIndex_setting_valueContext

	// IsIndex_setting_entryContext differentiates from other interfaces.
	IsIndex_setting_entryContext()
}

type Index_setting_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_setting_entryContext() *Index_setting_entryContext {
	var p = new(Index_setting_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_index_setting_entry
	return p
}

func InitEmptyIndex_setting_entryContext(p *Index_setting_entryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_index_setting_entry
}

func (*Index_setting_entryContext) IsIndex_setting_entryContext() {}

func NewIndex_setting_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_setting_entryContext {
	var p = new(Index_setting_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_index_setting_entry

	return p
}

func (s *Index_setting_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_setting_entryContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Index_setting_entryContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEQUALS, 0)
}

func (s *Index_setting_entryContext) Index_setting_value() IIndex_setting_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_setting_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_setting_valueContext)
}

func (s *Index_setting_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_setting_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_setting_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterIndex_setting_entry(s)
	}
}

func (s *Index_setting_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitIndex_setting_entry(s)
	}
}

func (p *SQLv1Antlr4Parser) Index_setting_entry() (localctx IIndex_setting_entryContext) {
	localctx = NewIndex_setting_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, SQLv1Antlr4ParserRULE_index_setting_entry)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3283)
		p.An_id()
	}
	{
		p.SetState(3284)
		p.Match(SQLv1Antlr4ParserEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3285)
		p.Index_setting_value()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndex_setting_valueContext is an interface to support dynamic dispatch.
type IIndex_setting_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_or_type() IId_or_typeContext
	STRING_VALUE() antlr.TerminalNode
	Integer() IIntegerContext
	Bool_value() IBool_valueContext

	// IsIndex_setting_valueContext differentiates from other interfaces.
	IsIndex_setting_valueContext()
}

type Index_setting_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_setting_valueContext() *Index_setting_valueContext {
	var p = new(Index_setting_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_index_setting_value
	return p
}

func InitEmptyIndex_setting_valueContext(p *Index_setting_valueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_index_setting_value
}

func (*Index_setting_valueContext) IsIndex_setting_valueContext() {}

func NewIndex_setting_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_setting_valueContext {
	var p = new(Index_setting_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_index_setting_value

	return p
}

func (s *Index_setting_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_setting_valueContext) Id_or_type() IId_or_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_or_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_or_typeContext)
}

func (s *Index_setting_valueContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRING_VALUE, 0)
}

func (s *Index_setting_valueContext) Integer() IIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerContext)
}

func (s *Index_setting_valueContext) Bool_value() IBool_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_valueContext)
}

func (s *Index_setting_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_setting_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_setting_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterIndex_setting_value(s)
	}
}

func (s *Index_setting_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitIndex_setting_value(s)
	}
}

func (p *SQLv1Antlr4Parser) Index_setting_value() (localctx IIndex_setting_valueContext) {
	localctx = NewIndex_setting_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, SQLv1Antlr4ParserRULE_index_setting_value)
	p.SetState(3291)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALL, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserANY, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCALLABLE, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDICT, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserENUM, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFLOW, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserLIST, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOPTIONAL, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESOURCE, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSET, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSTREAM, SQLv1Antlr4ParserSTRUCT, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTAGGED, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTUPLE, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVARIANT, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWITHOUT, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3287)
			p.Id_or_type()
		}

	case SQLv1Antlr4ParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3288)
			p.Match(SQLv1Antlr4ParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserDIGITS, SQLv1Antlr4ParserINTEGER_VALUE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3289)
			p.Integer()
		}

	case SQLv1Antlr4ParserFALSE, SQLv1Antlr4ParserTRUE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3290)
			p.Bool_value()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChangefeedContext is an interface to support dynamic dispatch.
type IChangefeedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHANGEFEED() antlr.TerminalNode
	An_id() IAn_idContext
	WITH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Changefeed_settings() IChangefeed_settingsContext
	RPAREN() antlr.TerminalNode

	// IsChangefeedContext differentiates from other interfaces.
	IsChangefeedContext()
}

type ChangefeedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChangefeedContext() *ChangefeedContext {
	var p = new(ChangefeedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_changefeed
	return p
}

func InitEmptyChangefeedContext(p *ChangefeedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_changefeed
}

func (*ChangefeedContext) IsChangefeedContext() {}

func NewChangefeedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChangefeedContext {
	var p = new(ChangefeedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_changefeed

	return p
}

func (s *ChangefeedContext) GetParser() antlr.Parser { return s.parser }

func (s *ChangefeedContext) CHANGEFEED() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCHANGEFEED, 0)
}

func (s *ChangefeedContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *ChangefeedContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWITH, 0)
}

func (s *ChangefeedContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *ChangefeedContext) Changefeed_settings() IChangefeed_settingsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangefeed_settingsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangefeed_settingsContext)
}

func (s *ChangefeedContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *ChangefeedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChangefeedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChangefeedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterChangefeed(s)
	}
}

func (s *ChangefeedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitChangefeed(s)
	}
}

func (p *SQLv1Antlr4Parser) Changefeed() (localctx IChangefeedContext) {
	localctx = NewChangefeedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, SQLv1Antlr4ParserRULE_changefeed)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3293)
		p.Match(SQLv1Antlr4ParserCHANGEFEED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3294)
		p.An_id()
	}
	{
		p.SetState(3295)
		p.Match(SQLv1Antlr4ParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3296)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3297)
		p.Changefeed_settings()
	}
	{
		p.SetState(3298)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChangefeed_settingsContext is an interface to support dynamic dispatch.
type IChangefeed_settingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllChangefeed_settings_entry() []IChangefeed_settings_entryContext
	Changefeed_settings_entry(i int) IChangefeed_settings_entryContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsChangefeed_settingsContext differentiates from other interfaces.
	IsChangefeed_settingsContext()
}

type Changefeed_settingsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChangefeed_settingsContext() *Changefeed_settingsContext {
	var p = new(Changefeed_settingsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_changefeed_settings
	return p
}

func InitEmptyChangefeed_settingsContext(p *Changefeed_settingsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_changefeed_settings
}

func (*Changefeed_settingsContext) IsChangefeed_settingsContext() {}

func NewChangefeed_settingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Changefeed_settingsContext {
	var p = new(Changefeed_settingsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_changefeed_settings

	return p
}

func (s *Changefeed_settingsContext) GetParser() antlr.Parser { return s.parser }

func (s *Changefeed_settingsContext) AllChangefeed_settings_entry() []IChangefeed_settings_entryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IChangefeed_settings_entryContext); ok {
			len++
		}
	}

	tst := make([]IChangefeed_settings_entryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IChangefeed_settings_entryContext); ok {
			tst[i] = t.(IChangefeed_settings_entryContext)
			i++
		}
	}

	return tst
}

func (s *Changefeed_settingsContext) Changefeed_settings_entry(i int) IChangefeed_settings_entryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangefeed_settings_entryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangefeed_settings_entryContext)
}

func (s *Changefeed_settingsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Changefeed_settingsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Changefeed_settingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Changefeed_settingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Changefeed_settingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterChangefeed_settings(s)
	}
}

func (s *Changefeed_settingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitChangefeed_settings(s)
	}
}

func (p *SQLv1Antlr4Parser) Changefeed_settings() (localctx IChangefeed_settingsContext) {
	localctx = NewChangefeed_settingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, SQLv1Antlr4ParserRULE_changefeed_settings)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3300)
		p.Changefeed_settings_entry()
	}
	p.SetState(3305)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(3301)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3302)
			p.Changefeed_settings_entry()
		}

		p.SetState(3307)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChangefeed_settings_entryContext is an interface to support dynamic dispatch.
type IChangefeed_settings_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext
	EQUALS() antlr.TerminalNode
	Changefeed_setting_value() IChangefeed_setting_valueContext

	// IsChangefeed_settings_entryContext differentiates from other interfaces.
	IsChangefeed_settings_entryContext()
}

type Changefeed_settings_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChangefeed_settings_entryContext() *Changefeed_settings_entryContext {
	var p = new(Changefeed_settings_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_changefeed_settings_entry
	return p
}

func InitEmptyChangefeed_settings_entryContext(p *Changefeed_settings_entryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_changefeed_settings_entry
}

func (*Changefeed_settings_entryContext) IsChangefeed_settings_entryContext() {}

func NewChangefeed_settings_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Changefeed_settings_entryContext {
	var p = new(Changefeed_settings_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_changefeed_settings_entry

	return p
}

func (s *Changefeed_settings_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Changefeed_settings_entryContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Changefeed_settings_entryContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEQUALS, 0)
}

func (s *Changefeed_settings_entryContext) Changefeed_setting_value() IChangefeed_setting_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangefeed_setting_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangefeed_setting_valueContext)
}

func (s *Changefeed_settings_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Changefeed_settings_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Changefeed_settings_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterChangefeed_settings_entry(s)
	}
}

func (s *Changefeed_settings_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitChangefeed_settings_entry(s)
	}
}

func (p *SQLv1Antlr4Parser) Changefeed_settings_entry() (localctx IChangefeed_settings_entryContext) {
	localctx = NewChangefeed_settings_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, SQLv1Antlr4ParserRULE_changefeed_settings_entry)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3308)
		p.An_id()
	}
	{
		p.SetState(3309)
		p.Match(SQLv1Antlr4ParserEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3310)
		p.Changefeed_setting_value()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChangefeed_setting_valueContext is an interface to support dynamic dispatch.
type IChangefeed_setting_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext

	// IsChangefeed_setting_valueContext differentiates from other interfaces.
	IsChangefeed_setting_valueContext()
}

type Changefeed_setting_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChangefeed_setting_valueContext() *Changefeed_setting_valueContext {
	var p = new(Changefeed_setting_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_changefeed_setting_value
	return p
}

func InitEmptyChangefeed_setting_valueContext(p *Changefeed_setting_valueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_changefeed_setting_value
}

func (*Changefeed_setting_valueContext) IsChangefeed_setting_valueContext() {}

func NewChangefeed_setting_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Changefeed_setting_valueContext {
	var p = new(Changefeed_setting_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_changefeed_setting_value

	return p
}

func (s *Changefeed_setting_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Changefeed_setting_valueContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Changefeed_setting_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Changefeed_setting_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Changefeed_setting_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterChangefeed_setting_value(s)
	}
}

func (s *Changefeed_setting_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitChangefeed_setting_value(s)
	}
}

func (p *SQLv1Antlr4Parser) Changefeed_setting_value() (localctx IChangefeed_setting_valueContext) {
	localctx = NewChangefeed_setting_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 538, SQLv1Antlr4ParserRULE_changefeed_setting_value)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3312)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChangefeed_alter_settingsContext is an interface to support dynamic dispatch.
type IChangefeed_alter_settingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISABLE() antlr.TerminalNode
	SET() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Changefeed_settings() IChangefeed_settingsContext
	RPAREN() antlr.TerminalNode

	// IsChangefeed_alter_settingsContext differentiates from other interfaces.
	IsChangefeed_alter_settingsContext()
}

type Changefeed_alter_settingsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChangefeed_alter_settingsContext() *Changefeed_alter_settingsContext {
	var p = new(Changefeed_alter_settingsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_changefeed_alter_settings
	return p
}

func InitEmptyChangefeed_alter_settingsContext(p *Changefeed_alter_settingsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_changefeed_alter_settings
}

func (*Changefeed_alter_settingsContext) IsChangefeed_alter_settingsContext() {}

func NewChangefeed_alter_settingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Changefeed_alter_settingsContext {
	var p = new(Changefeed_alter_settingsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_changefeed_alter_settings

	return p
}

func (s *Changefeed_alter_settingsContext) GetParser() antlr.Parser { return s.parser }

func (s *Changefeed_alter_settingsContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDISABLE, 0)
}

func (s *Changefeed_alter_settingsContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSET, 0)
}

func (s *Changefeed_alter_settingsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Changefeed_alter_settingsContext) Changefeed_settings() IChangefeed_settingsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangefeed_settingsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangefeed_settingsContext)
}

func (s *Changefeed_alter_settingsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Changefeed_alter_settingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Changefeed_alter_settingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Changefeed_alter_settingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterChangefeed_alter_settings(s)
	}
}

func (s *Changefeed_alter_settingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitChangefeed_alter_settings(s)
	}
}

func (p *SQLv1Antlr4Parser) Changefeed_alter_settings() (localctx IChangefeed_alter_settingsContext) {
	localctx = NewChangefeed_alter_settingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 540, SQLv1Antlr4ParserRULE_changefeed_alter_settings)
	p.SetState(3320)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserDISABLE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3314)
			p.Match(SQLv1Antlr4ParserDISABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserSET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3315)
			p.Match(SQLv1Antlr4ParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3316)
			p.Match(SQLv1Antlr4ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3317)
			p.Changefeed_settings()
		}
		{
			p.SetState(3318)
			p.Match(SQLv1Antlr4ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_setting_entryContext is an interface to support dynamic dispatch.
type IAlter_table_setting_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext
	EQUALS() antlr.TerminalNode
	Table_setting_value() ITable_setting_valueContext

	// IsAlter_table_setting_entryContext differentiates from other interfaces.
	IsAlter_table_setting_entryContext()
}

type Alter_table_setting_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_setting_entryContext() *Alter_table_setting_entryContext {
	var p = new(Alter_table_setting_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_setting_entry
	return p
}

func InitEmptyAlter_table_setting_entryContext(p *Alter_table_setting_entryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_setting_entry
}

func (*Alter_table_setting_entryContext) IsAlter_table_setting_entryContext() {}

func NewAlter_table_setting_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_setting_entryContext {
	var p = new(Alter_table_setting_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_setting_entry

	return p
}

func (s *Alter_table_setting_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_setting_entryContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Alter_table_setting_entryContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEQUALS, 0)
}

func (s *Alter_table_setting_entryContext) Table_setting_value() ITable_setting_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_setting_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_setting_valueContext)
}

func (s *Alter_table_setting_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_setting_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_setting_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_table_setting_entry(s)
	}
}

func (s *Alter_table_setting_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_table_setting_entry(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_table_setting_entry() (localctx IAlter_table_setting_entryContext) {
	localctx = NewAlter_table_setting_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 542, SQLv1Antlr4ParserRULE_alter_table_setting_entry)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3322)
		p.An_id()
	}
	{
		p.SetState(3323)
		p.Match(SQLv1Antlr4ParserEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3324)
		p.Table_setting_value()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_setting_valueContext is an interface to support dynamic dispatch.
type ITable_setting_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id() IIdContext
	STRING_VALUE() antlr.TerminalNode
	Integer() IIntegerContext
	Split_boundaries() ISplit_boundariesContext
	Expr() IExprContext
	ON() antlr.TerminalNode
	An_id() IAn_idContext
	AS() antlr.TerminalNode
	SECONDS() antlr.TerminalNode
	MILLISECONDS() antlr.TerminalNode
	MICROSECONDS() antlr.TerminalNode
	NANOSECONDS() antlr.TerminalNode
	Bool_value() IBool_valueContext

	// IsTable_setting_valueContext differentiates from other interfaces.
	IsTable_setting_valueContext()
}

type Table_setting_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_setting_valueContext() *Table_setting_valueContext {
	var p = new(Table_setting_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_setting_value
	return p
}

func InitEmptyTable_setting_valueContext(p *Table_setting_valueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_setting_value
}

func (*Table_setting_valueContext) IsTable_setting_valueContext() {}

func NewTable_setting_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_setting_valueContext {
	var p = new(Table_setting_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_setting_value

	return p
}

func (s *Table_setting_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_setting_valueContext) Id() IIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *Table_setting_valueContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRING_VALUE, 0)
}

func (s *Table_setting_valueContext) Integer() IIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerContext)
}

func (s *Table_setting_valueContext) Split_boundaries() ISplit_boundariesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISplit_boundariesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISplit_boundariesContext)
}

func (s *Table_setting_valueContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Table_setting_valueContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserON, 0)
}

func (s *Table_setting_valueContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Table_setting_valueContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAS, 0)
}

func (s *Table_setting_valueContext) SECONDS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSECONDS, 0)
}

func (s *Table_setting_valueContext) MILLISECONDS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMILLISECONDS, 0)
}

func (s *Table_setting_valueContext) MICROSECONDS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMICROSECONDS, 0)
}

func (s *Table_setting_valueContext) NANOSECONDS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNANOSECONDS, 0)
}

func (s *Table_setting_valueContext) Bool_value() IBool_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_valueContext)
}

func (s *Table_setting_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_setting_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_setting_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterTable_setting_value(s)
	}
}

func (s *Table_setting_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitTable_setting_value(s)
	}
}

func (p *SQLv1Antlr4Parser) Table_setting_value() (localctx ITable_setting_valueContext) {
	localctx = NewTable_setting_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, SQLv1Antlr4ParserRULE_table_setting_value)
	var _la int

	p.SetState(3338)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 331, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3326)
			p.Id()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3327)
			p.Match(SQLv1Antlr4ParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3328)
			p.Integer()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3329)
			p.Split_boundaries()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3330)
			p.Expr()
		}
		{
			p.SetState(3331)
			p.Match(SQLv1Antlr4ParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3332)
			p.An_id()
		}
		p.SetState(3335)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserAS {
			{
				p.SetState(3333)
				p.Match(SQLv1Antlr4ParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3334)
				_la = p.GetTokenStream().LA(1)

				if !(((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&11) != 0) || _la == SQLv1Antlr4ParserSECONDS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3337)
			p.Bool_value()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFamily_entryContext is an interface to support dynamic dispatch.
type IFamily_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FAMILY() antlr.TerminalNode
	An_id() IAn_idContext
	Family_settings() IFamily_settingsContext

	// IsFamily_entryContext differentiates from other interfaces.
	IsFamily_entryContext()
}

type Family_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFamily_entryContext() *Family_entryContext {
	var p = new(Family_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_family_entry
	return p
}

func InitEmptyFamily_entryContext(p *Family_entryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_family_entry
}

func (*Family_entryContext) IsFamily_entryContext() {}

func NewFamily_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Family_entryContext {
	var p = new(Family_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_family_entry

	return p
}

func (s *Family_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Family_entryContext) FAMILY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFAMILY, 0)
}

func (s *Family_entryContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Family_entryContext) Family_settings() IFamily_settingsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFamily_settingsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFamily_settingsContext)
}

func (s *Family_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Family_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Family_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterFamily_entry(s)
	}
}

func (s *Family_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitFamily_entry(s)
	}
}

func (p *SQLv1Antlr4Parser) Family_entry() (localctx IFamily_entryContext) {
	localctx = NewFamily_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 546, SQLv1Antlr4ParserRULE_family_entry)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3340)
		p.Match(SQLv1Antlr4ParserFAMILY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3341)
		p.An_id()
	}
	{
		p.SetState(3342)
		p.Family_settings()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFamily_settingsContext is an interface to support dynamic dispatch.
type IFamily_settingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllFamily_settings_entry() []IFamily_settings_entryContext
	Family_settings_entry(i int) IFamily_settings_entryContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFamily_settingsContext differentiates from other interfaces.
	IsFamily_settingsContext()
}

type Family_settingsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFamily_settingsContext() *Family_settingsContext {
	var p = new(Family_settingsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_family_settings
	return p
}

func InitEmptyFamily_settingsContext(p *Family_settingsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_family_settings
}

func (*Family_settingsContext) IsFamily_settingsContext() {}

func NewFamily_settingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Family_settingsContext {
	var p = new(Family_settingsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_family_settings

	return p
}

func (s *Family_settingsContext) GetParser() antlr.Parser { return s.parser }

func (s *Family_settingsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Family_settingsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Family_settingsContext) AllFamily_settings_entry() []IFamily_settings_entryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFamily_settings_entryContext); ok {
			len++
		}
	}

	tst := make([]IFamily_settings_entryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFamily_settings_entryContext); ok {
			tst[i] = t.(IFamily_settings_entryContext)
			i++
		}
	}

	return tst
}

func (s *Family_settingsContext) Family_settings_entry(i int) IFamily_settings_entryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFamily_settings_entryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFamily_settings_entryContext)
}

func (s *Family_settingsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Family_settingsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Family_settingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Family_settingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Family_settingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterFamily_settings(s)
	}
}

func (s *Family_settingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitFamily_settings(s)
	}
}

func (p *SQLv1Antlr4Parser) Family_settings() (localctx IFamily_settingsContext) {
	localctx = NewFamily_settingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, SQLv1Antlr4ParserRULE_family_settings)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3344)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3353)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-43)) & ^0x3f) == 0 && ((int64(1)<<(_la-43))&-537919489) != 0) || ((int64((_la-107)) & ^0x3f) == 0 && ((int64(1)<<(_la-107))&-4415763283973) != 0) || ((int64((_la-171)) & ^0x3f) == 0 && ((int64(1)<<(_la-171))&-2199023288321) != 0) || ((int64((_la-235)) & ^0x3f) == 0 && ((int64(1)<<(_la-235))&-6922034860651454977) != 0) || ((int64((_la-299)) & ^0x3f) == 0 && ((int64(1)<<(_la-299))&67100671) != 0) {
		{
			p.SetState(3345)
			p.Family_settings_entry()
		}
		p.SetState(3350)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SQLv1Antlr4ParserCOMMA {
			{
				p.SetState(3346)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3347)
				p.Family_settings_entry()
			}

			p.SetState(3352)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(3355)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFamily_settings_entryContext is an interface to support dynamic dispatch.
type IFamily_settings_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext
	EQUALS() antlr.TerminalNode
	Family_setting_value() IFamily_setting_valueContext

	// IsFamily_settings_entryContext differentiates from other interfaces.
	IsFamily_settings_entryContext()
}

type Family_settings_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFamily_settings_entryContext() *Family_settings_entryContext {
	var p = new(Family_settings_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_family_settings_entry
	return p
}

func InitEmptyFamily_settings_entryContext(p *Family_settings_entryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_family_settings_entry
}

func (*Family_settings_entryContext) IsFamily_settings_entryContext() {}

func NewFamily_settings_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Family_settings_entryContext {
	var p = new(Family_settings_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_family_settings_entry

	return p
}

func (s *Family_settings_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Family_settings_entryContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Family_settings_entryContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEQUALS, 0)
}

func (s *Family_settings_entryContext) Family_setting_value() IFamily_setting_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFamily_setting_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFamily_setting_valueContext)
}

func (s *Family_settings_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Family_settings_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Family_settings_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterFamily_settings_entry(s)
	}
}

func (s *Family_settings_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitFamily_settings_entry(s)
	}
}

func (p *SQLv1Antlr4Parser) Family_settings_entry() (localctx IFamily_settings_entryContext) {
	localctx = NewFamily_settings_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, SQLv1Antlr4ParserRULE_family_settings_entry)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3357)
		p.An_id()
	}
	{
		p.SetState(3358)
		p.Match(SQLv1Antlr4ParserEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3359)
		p.Family_setting_value()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFamily_setting_valueContext is an interface to support dynamic dispatch.
type IFamily_setting_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_VALUE() antlr.TerminalNode

	// IsFamily_setting_valueContext differentiates from other interfaces.
	IsFamily_setting_valueContext()
}

type Family_setting_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFamily_setting_valueContext() *Family_setting_valueContext {
	var p = new(Family_setting_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_family_setting_value
	return p
}

func InitEmptyFamily_setting_valueContext(p *Family_setting_valueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_family_setting_value
}

func (*Family_setting_valueContext) IsFamily_setting_valueContext() {}

func NewFamily_setting_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Family_setting_valueContext {
	var p = new(Family_setting_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_family_setting_value

	return p
}

func (s *Family_setting_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Family_setting_valueContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRING_VALUE, 0)
}

func (s *Family_setting_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Family_setting_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Family_setting_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterFamily_setting_value(s)
	}
}

func (s *Family_setting_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitFamily_setting_value(s)
	}
}

func (p *SQLv1Antlr4Parser) Family_setting_value() (localctx IFamily_setting_valueContext) {
	localctx = NewFamily_setting_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 552, SQLv1Antlr4ParserRULE_family_setting_value)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3361)
		p.Match(SQLv1Antlr4ParserSTRING_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISplit_boundariesContext is an interface to support dynamic dispatch.
type ISplit_boundariesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllLiteral_value_list() []ILiteral_value_listContext
	Literal_value_list(i int) ILiteral_value_listContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSplit_boundariesContext differentiates from other interfaces.
	IsSplit_boundariesContext()
}

type Split_boundariesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySplit_boundariesContext() *Split_boundariesContext {
	var p = new(Split_boundariesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_split_boundaries
	return p
}

func InitEmptySplit_boundariesContext(p *Split_boundariesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_split_boundaries
}

func (*Split_boundariesContext) IsSplit_boundariesContext() {}

func NewSplit_boundariesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Split_boundariesContext {
	var p = new(Split_boundariesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_split_boundaries

	return p
}

func (s *Split_boundariesContext) GetParser() antlr.Parser { return s.parser }

func (s *Split_boundariesContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Split_boundariesContext) AllLiteral_value_list() []ILiteral_value_listContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILiteral_value_listContext); ok {
			len++
		}
	}

	tst := make([]ILiteral_value_listContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILiteral_value_listContext); ok {
			tst[i] = t.(ILiteral_value_listContext)
			i++
		}
	}

	return tst
}

func (s *Split_boundariesContext) Literal_value_list(i int) ILiteral_value_listContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteral_value_listContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteral_value_listContext)
}

func (s *Split_boundariesContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Split_boundariesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Split_boundariesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Split_boundariesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Split_boundariesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Split_boundariesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSplit_boundaries(s)
	}
}

func (s *Split_boundariesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSplit_boundaries(s)
	}
}

func (p *SQLv1Antlr4Parser) Split_boundaries() (localctx ISplit_boundariesContext) {
	localctx = NewSplit_boundariesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 554, SQLv1Antlr4ParserRULE_split_boundaries)
	var _la int

	p.SetState(3375)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 335, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3363)
			p.Match(SQLv1Antlr4ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3364)
			p.Literal_value_list()
		}
		p.SetState(3369)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SQLv1Antlr4ParserCOMMA {
			{
				p.SetState(3365)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3366)
				p.Literal_value_list()
			}

			p.SetState(3371)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3372)
			p.Match(SQLv1Antlr4ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3374)
			p.Literal_value_list()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteral_value_listContext is an interface to support dynamic dispatch.
type ILiteral_value_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllLiteral_value() []ILiteral_valueContext
	Literal_value(i int) ILiteral_valueContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLiteral_value_listContext differentiates from other interfaces.
	IsLiteral_value_listContext()
}

type Literal_value_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteral_value_listContext() *Literal_value_listContext {
	var p = new(Literal_value_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_literal_value_list
	return p
}

func InitEmptyLiteral_value_listContext(p *Literal_value_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_literal_value_list
}

func (*Literal_value_listContext) IsLiteral_value_listContext() {}

func NewLiteral_value_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Literal_value_listContext {
	var p = new(Literal_value_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_literal_value_list

	return p
}

func (s *Literal_value_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Literal_value_listContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Literal_value_listContext) AllLiteral_value() []ILiteral_valueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILiteral_valueContext); ok {
			len++
		}
	}

	tst := make([]ILiteral_valueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILiteral_valueContext); ok {
			tst[i] = t.(ILiteral_valueContext)
			i++
		}
	}

	return tst
}

func (s *Literal_value_listContext) Literal_value(i int) ILiteral_valueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteral_valueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteral_valueContext)
}

func (s *Literal_value_listContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Literal_value_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Literal_value_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Literal_value_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Literal_value_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Literal_value_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterLiteral_value_list(s)
	}
}

func (s *Literal_value_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitLiteral_value_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Literal_value_list() (localctx ILiteral_value_listContext) {
	localctx = NewLiteral_value_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 556, SQLv1Antlr4ParserRULE_literal_value_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3377)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3378)
		p.Literal_value()
	}
	p.SetState(3383)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(3379)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3380)
			p.Literal_value()
		}

		p.SetState(3385)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3386)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_alter_index_actionContext is an interface to support dynamic dispatch.
type IAlter_table_alter_index_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Alter_table_set_table_setting_uncompat() IAlter_table_set_table_setting_uncompatContext
	Alter_table_set_table_setting_compat() IAlter_table_set_table_setting_compatContext
	Alter_table_reset_table_setting() IAlter_table_reset_table_settingContext

	// IsAlter_table_alter_index_actionContext differentiates from other interfaces.
	IsAlter_table_alter_index_actionContext()
}

type Alter_table_alter_index_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_alter_index_actionContext() *Alter_table_alter_index_actionContext {
	var p = new(Alter_table_alter_index_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_alter_index_action
	return p
}

func InitEmptyAlter_table_alter_index_actionContext(p *Alter_table_alter_index_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_alter_index_action
}

func (*Alter_table_alter_index_actionContext) IsAlter_table_alter_index_actionContext() {}

func NewAlter_table_alter_index_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_alter_index_actionContext {
	var p = new(Alter_table_alter_index_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_table_alter_index_action

	return p
}

func (s *Alter_table_alter_index_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_alter_index_actionContext) Alter_table_set_table_setting_uncompat() IAlter_table_set_table_setting_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_set_table_setting_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_set_table_setting_uncompatContext)
}

func (s *Alter_table_alter_index_actionContext) Alter_table_set_table_setting_compat() IAlter_table_set_table_setting_compatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_set_table_setting_compatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_set_table_setting_compatContext)
}

func (s *Alter_table_alter_index_actionContext) Alter_table_reset_table_setting() IAlter_table_reset_table_settingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_reset_table_settingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_reset_table_settingContext)
}

func (s *Alter_table_alter_index_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_alter_index_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_alter_index_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_table_alter_index_action(s)
	}
}

func (s *Alter_table_alter_index_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_table_alter_index_action(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_table_alter_index_action() (localctx IAlter_table_alter_index_actionContext) {
	localctx = NewAlter_table_alter_index_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 558, SQLv1Antlr4ParserRULE_alter_table_alter_index_action)
	p.SetState(3391)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 337, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3388)
			p.Alter_table_set_table_setting_uncompat()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3389)
			p.Alter_table_set_table_setting_compat()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3390)
			p.Alter_table_reset_table_setting()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_table_stmtContext is an interface to support dynamic dispatch.
type IDrop_table_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	Simple_table_ref() ISimple_table_refContext
	TABLE() antlr.TerminalNode
	TABLESTORE() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDrop_table_stmtContext differentiates from other interfaces.
	IsDrop_table_stmtContext()
}

type Drop_table_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_table_stmtContext() *Drop_table_stmtContext {
	var p = new(Drop_table_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_table_stmt
	return p
}

func InitEmptyDrop_table_stmtContext(p *Drop_table_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_table_stmt
}

func (*Drop_table_stmtContext) IsDrop_table_stmtContext() {}

func NewDrop_table_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_table_stmtContext {
	var p = new(Drop_table_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_table_stmt

	return p
}

func (s *Drop_table_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_table_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDROP, 0)
}

func (s *Drop_table_stmtContext) Simple_table_ref() ISimple_table_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_table_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_table_refContext)
}

func (s *Drop_table_stmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTABLE, 0)
}

func (s *Drop_table_stmtContext) TABLESTORE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTABLESTORE, 0)
}

func (s *Drop_table_stmtContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXTERNAL, 0)
}

func (s *Drop_table_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIF, 0)
}

func (s *Drop_table_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXISTS, 0)
}

func (s *Drop_table_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_table_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_table_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterDrop_table_stmt(s)
	}
}

func (s *Drop_table_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitDrop_table_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Drop_table_stmt() (localctx IDrop_table_stmtContext) {
	localctx = NewDrop_table_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 560, SQLv1Antlr4ParserRULE_drop_table_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3393)
		p.Match(SQLv1Antlr4ParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3398)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserTABLE:
		{
			p.SetState(3394)
			p.Match(SQLv1Antlr4ParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserTABLESTORE:
		{
			p.SetState(3395)
			p.Match(SQLv1Antlr4ParserTABLESTORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserEXTERNAL:
		{
			p.SetState(3396)
			p.Match(SQLv1Antlr4ParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3397)
			p.Match(SQLv1Antlr4ParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(3402)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 339, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3400)
			p.Match(SQLv1Antlr4ParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3401)
			p.Match(SQLv1Antlr4ParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3404)
		p.Simple_table_ref()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_user_stmtContext is an interface to support dynamic dispatch.
type ICreate_user_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	USER() antlr.TerminalNode
	Role_name() IRole_nameContext
	Create_user_option() ICreate_user_optionContext

	// IsCreate_user_stmtContext differentiates from other interfaces.
	IsCreate_user_stmtContext()
}

type Create_user_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_user_stmtContext() *Create_user_stmtContext {
	var p = new(Create_user_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_user_stmt
	return p
}

func InitEmptyCreate_user_stmtContext(p *Create_user_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_user_stmt
}

func (*Create_user_stmtContext) IsCreate_user_stmtContext() {}

func NewCreate_user_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_user_stmtContext {
	var p = new(Create_user_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_user_stmt

	return p
}

func (s *Create_user_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_user_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCREATE, 0)
}

func (s *Create_user_stmtContext) USER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUSER, 0)
}

func (s *Create_user_stmtContext) Role_name() IRole_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRole_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRole_nameContext)
}

func (s *Create_user_stmtContext) Create_user_option() ICreate_user_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_user_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_user_optionContext)
}

func (s *Create_user_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_user_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_user_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterCreate_user_stmt(s)
	}
}

func (s *Create_user_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitCreate_user_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Create_user_stmt() (localctx ICreate_user_stmtContext) {
	localctx = NewCreate_user_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 562, SQLv1Antlr4ParserRULE_create_user_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3406)
		p.Match(SQLv1Antlr4ParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3407)
		p.Match(SQLv1Antlr4ParserUSER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3408)
		p.Role_name()
	}
	p.SetState(3410)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserENCRYPTED || _la == SQLv1Antlr4ParserPASSWORD {
		{
			p.SetState(3409)
			p.Create_user_option()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_user_stmtContext is an interface to support dynamic dispatch.
type IAlter_user_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	USER() antlr.TerminalNode
	AllRole_name() []IRole_nameContext
	Role_name(i int) IRole_nameContext
	Create_user_option() ICreate_user_optionContext
	RENAME() antlr.TerminalNode
	TO() antlr.TerminalNode
	WITH() antlr.TerminalNode

	// IsAlter_user_stmtContext differentiates from other interfaces.
	IsAlter_user_stmtContext()
}

type Alter_user_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_user_stmtContext() *Alter_user_stmtContext {
	var p = new(Alter_user_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_user_stmt
	return p
}

func InitEmptyAlter_user_stmtContext(p *Alter_user_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_user_stmt
}

func (*Alter_user_stmtContext) IsAlter_user_stmtContext() {}

func NewAlter_user_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_user_stmtContext {
	var p = new(Alter_user_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_user_stmt

	return p
}

func (s *Alter_user_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_user_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserALTER, 0)
}

func (s *Alter_user_stmtContext) USER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUSER, 0)
}

func (s *Alter_user_stmtContext) AllRole_name() []IRole_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRole_nameContext); ok {
			len++
		}
	}

	tst := make([]IRole_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRole_nameContext); ok {
			tst[i] = t.(IRole_nameContext)
			i++
		}
	}

	return tst
}

func (s *Alter_user_stmtContext) Role_name(i int) IRole_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRole_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRole_nameContext)
}

func (s *Alter_user_stmtContext) Create_user_option() ICreate_user_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_user_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_user_optionContext)
}

func (s *Alter_user_stmtContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRENAME, 0)
}

func (s *Alter_user_stmtContext) TO() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTO, 0)
}

func (s *Alter_user_stmtContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWITH, 0)
}

func (s *Alter_user_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_user_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_user_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_user_stmt(s)
	}
}

func (s *Alter_user_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_user_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_user_stmt() (localctx IAlter_user_stmtContext) {
	localctx = NewAlter_user_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 564, SQLv1Antlr4ParserRULE_alter_user_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3412)
		p.Match(SQLv1Antlr4ParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3413)
		p.Match(SQLv1Antlr4ParserUSER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3414)
		p.Role_name()
	}
	p.SetState(3422)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserWITH:
		p.SetState(3416)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserWITH {
			{
				p.SetState(3415)
				p.Match(SQLv1Antlr4ParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3418)
			p.Create_user_option()
		}

	case SQLv1Antlr4ParserRENAME:
		{
			p.SetState(3419)
			p.Match(SQLv1Antlr4ParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3420)
			p.Match(SQLv1Antlr4ParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3421)
			p.Role_name()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_group_stmtContext is an interface to support dynamic dispatch.
type ICreate_group_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	AllRole_name() []IRole_nameContext
	Role_name(i int) IRole_nameContext
	WITH() antlr.TerminalNode
	USER() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCreate_group_stmtContext differentiates from other interfaces.
	IsCreate_group_stmtContext()
}

type Create_group_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_group_stmtContext() *Create_group_stmtContext {
	var p = new(Create_group_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_group_stmt
	return p
}

func InitEmptyCreate_group_stmtContext(p *Create_group_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_group_stmt
}

func (*Create_group_stmtContext) IsCreate_group_stmtContext() {}

func NewCreate_group_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_group_stmtContext {
	var p = new(Create_group_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_group_stmt

	return p
}

func (s *Create_group_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_group_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCREATE, 0)
}

func (s *Create_group_stmtContext) GROUP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGROUP, 0)
}

func (s *Create_group_stmtContext) AllRole_name() []IRole_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRole_nameContext); ok {
			len++
		}
	}

	tst := make([]IRole_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRole_nameContext); ok {
			tst[i] = t.(IRole_nameContext)
			i++
		}
	}

	return tst
}

func (s *Create_group_stmtContext) Role_name(i int) IRole_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRole_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRole_nameContext)
}

func (s *Create_group_stmtContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWITH, 0)
}

func (s *Create_group_stmtContext) USER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUSER, 0)
}

func (s *Create_group_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Create_group_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Create_group_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_group_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_group_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterCreate_group_stmt(s)
	}
}

func (s *Create_group_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitCreate_group_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Create_group_stmt() (localctx ICreate_group_stmtContext) {
	localctx = NewCreate_group_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 566, SQLv1Antlr4ParserRULE_create_group_stmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3424)
		p.Match(SQLv1Antlr4ParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3425)
		p.Match(SQLv1Antlr4ParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3426)
		p.Role_name()
	}
	p.SetState(3440)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserWITH {
		{
			p.SetState(3427)
			p.Match(SQLv1Antlr4ParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3428)
			p.Match(SQLv1Antlr4ParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3429)
			p.Role_name()
		}
		p.SetState(3434)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 343, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3430)
					p.Match(SQLv1Antlr4ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3431)
					p.Role_name()
				}

			}
			p.SetState(3436)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 343, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(3438)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserCOMMA {
			{
				p.SetState(3437)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_group_stmtContext is an interface to support dynamic dispatch.
type IAlter_group_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	AllRole_name() []IRole_nameContext
	Role_name(i int) IRole_nameContext
	USER() antlr.TerminalNode
	RENAME() antlr.TerminalNode
	TO() antlr.TerminalNode
	ADD() antlr.TerminalNode
	DROP() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlter_group_stmtContext differentiates from other interfaces.
	IsAlter_group_stmtContext()
}

type Alter_group_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_group_stmtContext() *Alter_group_stmtContext {
	var p = new(Alter_group_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_group_stmt
	return p
}

func InitEmptyAlter_group_stmtContext(p *Alter_group_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_group_stmt
}

func (*Alter_group_stmtContext) IsAlter_group_stmtContext() {}

func NewAlter_group_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_group_stmtContext {
	var p = new(Alter_group_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_group_stmt

	return p
}

func (s *Alter_group_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_group_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserALTER, 0)
}

func (s *Alter_group_stmtContext) GROUP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGROUP, 0)
}

func (s *Alter_group_stmtContext) AllRole_name() []IRole_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRole_nameContext); ok {
			len++
		}
	}

	tst := make([]IRole_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRole_nameContext); ok {
			tst[i] = t.(IRole_nameContext)
			i++
		}
	}

	return tst
}

func (s *Alter_group_stmtContext) Role_name(i int) IRole_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRole_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRole_nameContext)
}

func (s *Alter_group_stmtContext) USER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUSER, 0)
}

func (s *Alter_group_stmtContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRENAME, 0)
}

func (s *Alter_group_stmtContext) TO() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTO, 0)
}

func (s *Alter_group_stmtContext) ADD() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserADD, 0)
}

func (s *Alter_group_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDROP, 0)
}

func (s *Alter_group_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Alter_group_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Alter_group_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_group_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_group_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_group_stmt(s)
	}
}

func (s *Alter_group_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_group_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_group_stmt() (localctx IAlter_group_stmtContext) {
	localctx = NewAlter_group_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 568, SQLv1Antlr4ParserRULE_alter_group_stmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3442)
		p.Match(SQLv1Antlr4ParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3443)
		p.Match(SQLv1Antlr4ParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3444)
		p.Role_name()
	}
	p.SetState(3461)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserADD, SQLv1Antlr4ParserDROP:
		{
			p.SetState(3445)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLv1Antlr4ParserADD || _la == SQLv1Antlr4ParserDROP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3446)
			p.Match(SQLv1Antlr4ParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3447)
			p.Role_name()
		}
		p.SetState(3452)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 346, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3448)
					p.Match(SQLv1Antlr4ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3449)
					p.Role_name()
				}

			}
			p.SetState(3454)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 346, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(3456)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserCOMMA {
			{
				p.SetState(3455)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case SQLv1Antlr4ParserRENAME:
		{
			p.SetState(3458)
			p.Match(SQLv1Antlr4ParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3459)
			p.Match(SQLv1Antlr4ParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3460)
			p.Role_name()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_role_stmtContext is an interface to support dynamic dispatch.
type IDrop_role_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	AllRole_name() []IRole_nameContext
	Role_name(i int) IRole_nameContext
	USER() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDrop_role_stmtContext differentiates from other interfaces.
	IsDrop_role_stmtContext()
}

type Drop_role_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_role_stmtContext() *Drop_role_stmtContext {
	var p = new(Drop_role_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_role_stmt
	return p
}

func InitEmptyDrop_role_stmtContext(p *Drop_role_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_role_stmt
}

func (*Drop_role_stmtContext) IsDrop_role_stmtContext() {}

func NewDrop_role_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_role_stmtContext {
	var p = new(Drop_role_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_role_stmt

	return p
}

func (s *Drop_role_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_role_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDROP, 0)
}

func (s *Drop_role_stmtContext) AllRole_name() []IRole_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRole_nameContext); ok {
			len++
		}
	}

	tst := make([]IRole_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRole_nameContext); ok {
			tst[i] = t.(IRole_nameContext)
			i++
		}
	}

	return tst
}

func (s *Drop_role_stmtContext) Role_name(i int) IRole_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRole_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRole_nameContext)
}

func (s *Drop_role_stmtContext) USER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUSER, 0)
}

func (s *Drop_role_stmtContext) GROUP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGROUP, 0)
}

func (s *Drop_role_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIF, 0)
}

func (s *Drop_role_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXISTS, 0)
}

func (s *Drop_role_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Drop_role_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Drop_role_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_role_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_role_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterDrop_role_stmt(s)
	}
}

func (s *Drop_role_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitDrop_role_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Drop_role_stmt() (localctx IDrop_role_stmtContext) {
	localctx = NewDrop_role_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 570, SQLv1Antlr4ParserRULE_drop_role_stmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3463)
		p.Match(SQLv1Antlr4ParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3464)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLv1Antlr4ParserGROUP || _la == SQLv1Antlr4ParserUSER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3467)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 349, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3465)
			p.Match(SQLv1Antlr4ParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3466)
			p.Match(SQLv1Antlr4ParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3469)
		p.Role_name()
	}
	p.SetState(3474)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 350, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3470)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3471)
				p.Role_name()
			}

		}
		p.SetState(3476)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 350, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(3478)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(3477)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRole_nameContext is an interface to support dynamic dispatch.
type IRole_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id_or_type() IAn_id_or_typeContext
	Bind_parameter() IBind_parameterContext

	// IsRole_nameContext differentiates from other interfaces.
	IsRole_nameContext()
}

type Role_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRole_nameContext() *Role_nameContext {
	var p = new(Role_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_role_name
	return p
}

func InitEmptyRole_nameContext(p *Role_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_role_name
}

func (*Role_nameContext) IsRole_nameContext() {}

func NewRole_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Role_nameContext {
	var p = new(Role_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_role_name

	return p
}

func (s *Role_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Role_nameContext) An_id_or_type() IAn_id_or_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_or_typeContext)
}

func (s *Role_nameContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Role_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Role_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Role_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRole_name(s)
	}
}

func (s *Role_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRole_name(s)
	}
}

func (p *SQLv1Antlr4Parser) Role_name() (localctx IRole_nameContext) {
	localctx = NewRole_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 572, SQLv1Antlr4ParserRULE_role_name)
	p.SetState(3482)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALL, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserANY, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCALLABLE, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDICT, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserENUM, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFLOW, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserLIST, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOPTIONAL, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESOURCE, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSET, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSTREAM, SQLv1Antlr4ParserSTRUCT, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTAGGED, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTUPLE, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVARIANT, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWITHOUT, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserSTRING_VALUE, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3480)
			p.An_id_or_type()
		}

	case SQLv1Antlr4ParserDOLLAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3481)
			p.Bind_parameter()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_user_optionContext is an interface to support dynamic dispatch.
type ICreate_user_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PASSWORD() antlr.TerminalNode
	Expr() IExprContext
	ENCRYPTED() antlr.TerminalNode

	// IsCreate_user_optionContext differentiates from other interfaces.
	IsCreate_user_optionContext()
}

type Create_user_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_user_optionContext() *Create_user_optionContext {
	var p = new(Create_user_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_user_option
	return p
}

func InitEmptyCreate_user_optionContext(p *Create_user_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_user_option
}

func (*Create_user_optionContext) IsCreate_user_optionContext() {}

func NewCreate_user_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_user_optionContext {
	var p = new(Create_user_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_user_option

	return p
}

func (s *Create_user_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_user_optionContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPASSWORD, 0)
}

func (s *Create_user_optionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Create_user_optionContext) ENCRYPTED() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserENCRYPTED, 0)
}

func (s *Create_user_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_user_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_user_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterCreate_user_option(s)
	}
}

func (s *Create_user_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitCreate_user_option(s)
	}
}

func (p *SQLv1Antlr4Parser) Create_user_option() (localctx ICreate_user_optionContext) {
	localctx = NewCreate_user_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 574, SQLv1Antlr4ParserRULE_create_user_option)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3485)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserENCRYPTED {
		{
			p.SetState(3484)
			p.Match(SQLv1Antlr4ParserENCRYPTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3487)
		p.Match(SQLv1Antlr4ParserPASSWORD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3488)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrant_permissions_stmtContext is an interface to support dynamic dispatch.
type IGrant_permissions_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGRANT() []antlr.TerminalNode
	GRANT(i int) antlr.TerminalNode
	Permission_name_target() IPermission_name_targetContext
	ON() antlr.TerminalNode
	AllAn_id_schema() []IAn_id_schemaContext
	An_id_schema(i int) IAn_id_schemaContext
	TO() antlr.TerminalNode
	AllRole_name() []IRole_nameContext
	Role_name(i int) IRole_nameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WITH() antlr.TerminalNode
	OPTION() antlr.TerminalNode

	// IsGrant_permissions_stmtContext differentiates from other interfaces.
	IsGrant_permissions_stmtContext()
}

type Grant_permissions_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrant_permissions_stmtContext() *Grant_permissions_stmtContext {
	var p = new(Grant_permissions_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_grant_permissions_stmt
	return p
}

func InitEmptyGrant_permissions_stmtContext(p *Grant_permissions_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_grant_permissions_stmt
}

func (*Grant_permissions_stmtContext) IsGrant_permissions_stmtContext() {}

func NewGrant_permissions_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Grant_permissions_stmtContext {
	var p = new(Grant_permissions_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_grant_permissions_stmt

	return p
}

func (s *Grant_permissions_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Grant_permissions_stmtContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserGRANT)
}

func (s *Grant_permissions_stmtContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGRANT, i)
}

func (s *Grant_permissions_stmtContext) Permission_name_target() IPermission_name_targetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPermission_name_targetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPermission_name_targetContext)
}

func (s *Grant_permissions_stmtContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserON, 0)
}

func (s *Grant_permissions_stmtContext) AllAn_id_schema() []IAn_id_schemaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_id_schemaContext); ok {
			len++
		}
	}

	tst := make([]IAn_id_schemaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_id_schemaContext); ok {
			tst[i] = t.(IAn_id_schemaContext)
			i++
		}
	}

	return tst
}

func (s *Grant_permissions_stmtContext) An_id_schema(i int) IAn_id_schemaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_schemaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_schemaContext)
}

func (s *Grant_permissions_stmtContext) TO() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTO, 0)
}

func (s *Grant_permissions_stmtContext) AllRole_name() []IRole_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRole_nameContext); ok {
			len++
		}
	}

	tst := make([]IRole_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRole_nameContext); ok {
			tst[i] = t.(IRole_nameContext)
			i++
		}
	}

	return tst
}

func (s *Grant_permissions_stmtContext) Role_name(i int) IRole_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRole_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRole_nameContext)
}

func (s *Grant_permissions_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Grant_permissions_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Grant_permissions_stmtContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWITH, 0)
}

func (s *Grant_permissions_stmtContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOPTION, 0)
}

func (s *Grant_permissions_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Grant_permissions_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Grant_permissions_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterGrant_permissions_stmt(s)
	}
}

func (s *Grant_permissions_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitGrant_permissions_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Grant_permissions_stmt() (localctx IGrant_permissions_stmtContext) {
	localctx = NewGrant_permissions_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 576, SQLv1Antlr4ParserRULE_grant_permissions_stmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3490)
		p.Match(SQLv1Antlr4ParserGRANT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3491)
		p.Permission_name_target()
	}
	{
		p.SetState(3492)
		p.Match(SQLv1Antlr4ParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3493)
		p.An_id_schema()
	}
	p.SetState(3498)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(3494)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3495)
			p.An_id_schema()
		}

		p.SetState(3500)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3501)
		p.Match(SQLv1Antlr4ParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3502)
		p.Role_name()
	}
	p.SetState(3507)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 355, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3503)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3504)
				p.Role_name()
			}

		}
		p.SetState(3509)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 355, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(3511)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(3510)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3516)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserWITH {
		{
			p.SetState(3513)
			p.Match(SQLv1Antlr4ParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3514)
			p.Match(SQLv1Antlr4ParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3515)
			p.Match(SQLv1Antlr4ParserOPTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRevoke_permissions_stmtContext is an interface to support dynamic dispatch.
type IRevoke_permissions_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REVOKE() antlr.TerminalNode
	Permission_name_target() IPermission_name_targetContext
	ON() antlr.TerminalNode
	AllAn_id_schema() []IAn_id_schemaContext
	An_id_schema(i int) IAn_id_schemaContext
	FROM() antlr.TerminalNode
	AllRole_name() []IRole_nameContext
	Role_name(i int) IRole_nameContext
	GRANT() antlr.TerminalNode
	OPTION() antlr.TerminalNode
	FOR() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRevoke_permissions_stmtContext differentiates from other interfaces.
	IsRevoke_permissions_stmtContext()
}

type Revoke_permissions_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevoke_permissions_stmtContext() *Revoke_permissions_stmtContext {
	var p = new(Revoke_permissions_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_revoke_permissions_stmt
	return p
}

func InitEmptyRevoke_permissions_stmtContext(p *Revoke_permissions_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_revoke_permissions_stmt
}

func (*Revoke_permissions_stmtContext) IsRevoke_permissions_stmtContext() {}

func NewRevoke_permissions_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Revoke_permissions_stmtContext {
	var p = new(Revoke_permissions_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_revoke_permissions_stmt

	return p
}

func (s *Revoke_permissions_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Revoke_permissions_stmtContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREVOKE, 0)
}

func (s *Revoke_permissions_stmtContext) Permission_name_target() IPermission_name_targetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPermission_name_targetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPermission_name_targetContext)
}

func (s *Revoke_permissions_stmtContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserON, 0)
}

func (s *Revoke_permissions_stmtContext) AllAn_id_schema() []IAn_id_schemaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_id_schemaContext); ok {
			len++
		}
	}

	tst := make([]IAn_id_schemaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_id_schemaContext); ok {
			tst[i] = t.(IAn_id_schemaContext)
			i++
		}
	}

	return tst
}

func (s *Revoke_permissions_stmtContext) An_id_schema(i int) IAn_id_schemaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_schemaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_schemaContext)
}

func (s *Revoke_permissions_stmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFROM, 0)
}

func (s *Revoke_permissions_stmtContext) AllRole_name() []IRole_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRole_nameContext); ok {
			len++
		}
	}

	tst := make([]IRole_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRole_nameContext); ok {
			tst[i] = t.(IRole_nameContext)
			i++
		}
	}

	return tst
}

func (s *Revoke_permissions_stmtContext) Role_name(i int) IRole_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRole_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRole_nameContext)
}

func (s *Revoke_permissions_stmtContext) GRANT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGRANT, 0)
}

func (s *Revoke_permissions_stmtContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOPTION, 0)
}

func (s *Revoke_permissions_stmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFOR, 0)
}

func (s *Revoke_permissions_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Revoke_permissions_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Revoke_permissions_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Revoke_permissions_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Revoke_permissions_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRevoke_permissions_stmt(s)
	}
}

func (s *Revoke_permissions_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRevoke_permissions_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Revoke_permissions_stmt() (localctx IRevoke_permissions_stmtContext) {
	localctx = NewRevoke_permissions_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 578, SQLv1Antlr4ParserRULE_revoke_permissions_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3518)
		p.Match(SQLv1Antlr4ParserREVOKE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3522)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 358, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3519)
			p.Match(SQLv1Antlr4ParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3520)
			p.Match(SQLv1Antlr4ParserOPTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3521)
			p.Match(SQLv1Antlr4ParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3524)
		p.Permission_name_target()
	}
	{
		p.SetState(3525)
		p.Match(SQLv1Antlr4ParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3526)
		p.An_id_schema()
	}
	p.SetState(3531)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(3527)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3528)
			p.An_id_schema()
		}

		p.SetState(3533)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3534)
		p.Match(SQLv1Antlr4ParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3535)
		p.Role_name()
	}
	p.SetState(3540)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(3536)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3537)
			p.Role_name()
		}

		p.SetState(3542)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPermission_idContext is an interface to support dynamic dispatch.
type IPermission_idContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONNECT() antlr.TerminalNode
	LIST() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	MANAGE() antlr.TerminalNode
	DROP() antlr.TerminalNode
	GRANT() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	ATTRIBUTES() antlr.TerminalNode
	ROW() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	ERASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	REMOVE() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	SELECT() antlr.TerminalNode
	USE() antlr.TerminalNode
	FULL() antlr.TerminalNode
	LEGACY() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	DIRECTORY() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QUEUE() antlr.TerminalNode

	// IsPermission_idContext differentiates from other interfaces.
	IsPermission_idContext()
}

type Permission_idContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPermission_idContext() *Permission_idContext {
	var p = new(Permission_idContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_permission_id
	return p
}

func InitEmptyPermission_idContext(p *Permission_idContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_permission_id
}

func (*Permission_idContext) IsPermission_idContext() {}

func NewPermission_idContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Permission_idContext {
	var p = new(Permission_idContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_permission_id

	return p
}

func (s *Permission_idContext) GetParser() antlr.Parser { return s.parser }

func (s *Permission_idContext) CONNECT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCONNECT, 0)
}

func (s *Permission_idContext) LIST() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLIST, 0)
}

func (s *Permission_idContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINSERT, 0)
}

func (s *Permission_idContext) MANAGE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMANAGE, 0)
}

func (s *Permission_idContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDROP, 0)
}

func (s *Permission_idContext) GRANT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGRANT, 0)
}

func (s *Permission_idContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMODIFY, 0)
}

func (s *Permission_idContext) TABLES() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTABLES, 0)
}

func (s *Permission_idContext) ATTRIBUTES() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserATTRIBUTES, 0)
}

func (s *Permission_idContext) ROW() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserROW, 0)
}

func (s *Permission_idContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUPDATE, 0)
}

func (s *Permission_idContext) ERASE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserERASE, 0)
}

func (s *Permission_idContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSCHEMA, 0)
}

func (s *Permission_idContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREMOVE, 0)
}

func (s *Permission_idContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDESCRIBE, 0)
}

func (s *Permission_idContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserALTER, 0)
}

func (s *Permission_idContext) SELECT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSELECT, 0)
}

func (s *Permission_idContext) USE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUSE, 0)
}

func (s *Permission_idContext) FULL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFULL, 0)
}

func (s *Permission_idContext) LEGACY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLEGACY, 0)
}

func (s *Permission_idContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCREATE, 0)
}

func (s *Permission_idContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDIRECTORY, 0)
}

func (s *Permission_idContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTABLE, 0)
}

func (s *Permission_idContext) QUEUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserQUEUE, 0)
}

func (s *Permission_idContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Permission_idContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Permission_idContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterPermission_id(s)
	}
}

func (s *Permission_idContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitPermission_id(s)
	}
}

func (p *SQLv1Antlr4Parser) Permission_id() (localctx IPermission_idContext) {
	localctx = NewPermission_idContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 580, SQLv1Antlr4ParserRULE_permission_id)
	var _la int

	p.SetState(3567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserCONNECT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3543)
			p.Match(SQLv1Antlr4ParserCONNECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserLIST:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3544)
			p.Match(SQLv1Antlr4ParserLIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserINSERT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3545)
			p.Match(SQLv1Antlr4ParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserMANAGE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3546)
			p.Match(SQLv1Antlr4ParserMANAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserDROP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3547)
			p.Match(SQLv1Antlr4ParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserGRANT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3548)
			p.Match(SQLv1Antlr4ParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserMODIFY:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3549)
			p.Match(SQLv1Antlr4ParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3550)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLv1Antlr4ParserATTRIBUTES || _la == SQLv1Antlr4ParserTABLES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserUPDATE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3551)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLv1Antlr4ParserERASE || _la == SQLv1Antlr4ParserUPDATE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3552)
			p.Match(SQLv1Antlr4ParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserREMOVE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3553)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLv1Antlr4ParserALTER || _la == SQLv1Antlr4ParserDESCRIBE || _la == SQLv1Antlr4ParserREMOVE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3554)
			p.Match(SQLv1Antlr4ParserSCHEMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserSELECT:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3555)
			p.Match(SQLv1Antlr4ParserSELECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3557)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserATTRIBUTES || _la == SQLv1Antlr4ParserROW || _la == SQLv1Antlr4ParserTABLES {
			{
				p.SetState(3556)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SQLv1Antlr4ParserATTRIBUTES || _la == SQLv1Antlr4ParserROW || _la == SQLv1Antlr4ParserTABLES) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserUSE:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3559)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLv1Antlr4ParserFULL || _la == SQLv1Antlr4ParserUSE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(3561)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserLEGACY {
			{
				p.SetState(3560)
				p.Match(SQLv1Antlr4ParserLEGACY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case SQLv1Antlr4ParserCREATE:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3563)
			p.Match(SQLv1Antlr4ParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3565)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserDIRECTORY || _la == SQLv1Antlr4ParserQUEUE || _la == SQLv1Antlr4ParserTABLE {
			{
				p.SetState(3564)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SQLv1Antlr4ParserDIRECTORY || _la == SQLv1Antlr4ParserQUEUE || _la == SQLv1Antlr4ParserTABLE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPermission_nameContext is an interface to support dynamic dispatch.
type IPermission_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Permission_id() IPermission_idContext
	STRING_VALUE() antlr.TerminalNode

	// IsPermission_nameContext differentiates from other interfaces.
	IsPermission_nameContext()
}

type Permission_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPermission_nameContext() *Permission_nameContext {
	var p = new(Permission_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_permission_name
	return p
}

func InitEmptyPermission_nameContext(p *Permission_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_permission_name
}

func (*Permission_nameContext) IsPermission_nameContext() {}

func NewPermission_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Permission_nameContext {
	var p = new(Permission_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_permission_name

	return p
}

func (s *Permission_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Permission_nameContext) Permission_id() IPermission_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPermission_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPermission_idContext)
}

func (s *Permission_nameContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRING_VALUE, 0)
}

func (s *Permission_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Permission_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Permission_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterPermission_name(s)
	}
}

func (s *Permission_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitPermission_name(s)
	}
}

func (p *SQLv1Antlr4Parser) Permission_name() (localctx IPermission_nameContext) {
	localctx = NewPermission_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 582, SQLv1Antlr4ParserRULE_permission_name)
	p.SetState(3571)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserLIST, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUSE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3569)
			p.Permission_id()
		}

	case SQLv1Antlr4ParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3570)
			p.Match(SQLv1Antlr4ParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPermission_name_targetContext is an interface to support dynamic dispatch.
type IPermission_name_targetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPermission_name() []IPermission_nameContext
	Permission_name(i int) IPermission_nameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	ALL() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode

	// IsPermission_name_targetContext differentiates from other interfaces.
	IsPermission_name_targetContext()
}

type Permission_name_targetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPermission_name_targetContext() *Permission_name_targetContext {
	var p = new(Permission_name_targetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_permission_name_target
	return p
}

func InitEmptyPermission_name_targetContext(p *Permission_name_targetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_permission_name_target
}

func (*Permission_name_targetContext) IsPermission_name_targetContext() {}

func NewPermission_name_targetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Permission_name_targetContext {
	var p = new(Permission_name_targetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_permission_name_target

	return p
}

func (s *Permission_name_targetContext) GetParser() antlr.Parser { return s.parser }

func (s *Permission_name_targetContext) AllPermission_name() []IPermission_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPermission_nameContext); ok {
			len++
		}
	}

	tst := make([]IPermission_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPermission_nameContext); ok {
			tst[i] = t.(IPermission_nameContext)
			i++
		}
	}

	return tst
}

func (s *Permission_name_targetContext) Permission_name(i int) IPermission_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPermission_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPermission_nameContext)
}

func (s *Permission_name_targetContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Permission_name_targetContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Permission_name_targetContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserALL, 0)
}

func (s *Permission_name_targetContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPRIVILEGES, 0)
}

func (s *Permission_name_targetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Permission_name_targetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Permission_name_targetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterPermission_name_target(s)
	}
}

func (s *Permission_name_targetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitPermission_name_target(s)
	}
}

func (p *SQLv1Antlr4Parser) Permission_name_target() (localctx IPermission_name_targetContext) {
	localctx = NewPermission_name_targetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 584, SQLv1Antlr4ParserRULE_permission_name_target)
	var _la int

	var _alt int

	p.SetState(3588)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserLIST, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3573)
			p.Permission_name()
		}
		p.SetState(3578)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 366, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3574)
					p.Match(SQLv1Antlr4ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3575)
					p.Permission_name()
				}

			}
			p.SetState(3580)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 366, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(3582)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserCOMMA {
			{
				p.SetState(3581)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case SQLv1Antlr4ParserALL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3584)
			p.Match(SQLv1Antlr4ParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3586)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserPRIVILEGES {
			{
				p.SetState(3585)
				p.Match(SQLv1Antlr4ParserPRIVILEGES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_resource_pool_stmtContext is an interface to support dynamic dispatch.
type ICreate_resource_pool_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	POOL() antlr.TerminalNode
	Object_ref() IObject_refContext
	With_table_settings() IWith_table_settingsContext

	// IsCreate_resource_pool_stmtContext differentiates from other interfaces.
	IsCreate_resource_pool_stmtContext()
}

type Create_resource_pool_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_resource_pool_stmtContext() *Create_resource_pool_stmtContext {
	var p = new(Create_resource_pool_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_resource_pool_stmt
	return p
}

func InitEmptyCreate_resource_pool_stmtContext(p *Create_resource_pool_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_resource_pool_stmt
}

func (*Create_resource_pool_stmtContext) IsCreate_resource_pool_stmtContext() {}

func NewCreate_resource_pool_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_resource_pool_stmtContext {
	var p = new(Create_resource_pool_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_resource_pool_stmt

	return p
}

func (s *Create_resource_pool_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_resource_pool_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCREATE, 0)
}

func (s *Create_resource_pool_stmtContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRESOURCE, 0)
}

func (s *Create_resource_pool_stmtContext) POOL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPOOL, 0)
}

func (s *Create_resource_pool_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Create_resource_pool_stmtContext) With_table_settings() IWith_table_settingsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_table_settingsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_table_settingsContext)
}

func (s *Create_resource_pool_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_resource_pool_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_resource_pool_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterCreate_resource_pool_stmt(s)
	}
}

func (s *Create_resource_pool_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitCreate_resource_pool_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Create_resource_pool_stmt() (localctx ICreate_resource_pool_stmtContext) {
	localctx = NewCreate_resource_pool_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 586, SQLv1Antlr4ParserRULE_create_resource_pool_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3590)
		p.Match(SQLv1Antlr4ParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3591)
		p.Match(SQLv1Antlr4ParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3592)
		p.Match(SQLv1Antlr4ParserPOOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3593)
		p.Object_ref()
	}
	{
		p.SetState(3594)
		p.With_table_settings()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_resource_pool_stmtContext is an interface to support dynamic dispatch.
type IAlter_resource_pool_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	POOL() antlr.TerminalNode
	Object_ref() IObject_refContext
	AllAlter_resource_pool_action() []IAlter_resource_pool_actionContext
	Alter_resource_pool_action(i int) IAlter_resource_pool_actionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlter_resource_pool_stmtContext differentiates from other interfaces.
	IsAlter_resource_pool_stmtContext()
}

type Alter_resource_pool_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_resource_pool_stmtContext() *Alter_resource_pool_stmtContext {
	var p = new(Alter_resource_pool_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_resource_pool_stmt
	return p
}

func InitEmptyAlter_resource_pool_stmtContext(p *Alter_resource_pool_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_resource_pool_stmt
}

func (*Alter_resource_pool_stmtContext) IsAlter_resource_pool_stmtContext() {}

func NewAlter_resource_pool_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_resource_pool_stmtContext {
	var p = new(Alter_resource_pool_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_resource_pool_stmt

	return p
}

func (s *Alter_resource_pool_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_resource_pool_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserALTER, 0)
}

func (s *Alter_resource_pool_stmtContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRESOURCE, 0)
}

func (s *Alter_resource_pool_stmtContext) POOL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPOOL, 0)
}

func (s *Alter_resource_pool_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Alter_resource_pool_stmtContext) AllAlter_resource_pool_action() []IAlter_resource_pool_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlter_resource_pool_actionContext); ok {
			len++
		}
	}

	tst := make([]IAlter_resource_pool_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlter_resource_pool_actionContext); ok {
			tst[i] = t.(IAlter_resource_pool_actionContext)
			i++
		}
	}

	return tst
}

func (s *Alter_resource_pool_stmtContext) Alter_resource_pool_action(i int) IAlter_resource_pool_actionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_resource_pool_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_resource_pool_actionContext)
}

func (s *Alter_resource_pool_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Alter_resource_pool_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Alter_resource_pool_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_resource_pool_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_resource_pool_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_resource_pool_stmt(s)
	}
}

func (s *Alter_resource_pool_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_resource_pool_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_resource_pool_stmt() (localctx IAlter_resource_pool_stmtContext) {
	localctx = NewAlter_resource_pool_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 588, SQLv1Antlr4ParserRULE_alter_resource_pool_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3596)
		p.Match(SQLv1Antlr4ParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3597)
		p.Match(SQLv1Antlr4ParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3598)
		p.Match(SQLv1Antlr4ParserPOOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3599)
		p.Object_ref()
	}
	{
		p.SetState(3600)
		p.Alter_resource_pool_action()
	}
	p.SetState(3605)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(3601)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3602)
			p.Alter_resource_pool_action()
		}

		p.SetState(3607)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_resource_pool_actionContext is an interface to support dynamic dispatch.
type IAlter_resource_pool_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Alter_table_set_table_setting_compat() IAlter_table_set_table_setting_compatContext
	Alter_table_reset_table_setting() IAlter_table_reset_table_settingContext

	// IsAlter_resource_pool_actionContext differentiates from other interfaces.
	IsAlter_resource_pool_actionContext()
}

type Alter_resource_pool_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_resource_pool_actionContext() *Alter_resource_pool_actionContext {
	var p = new(Alter_resource_pool_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_resource_pool_action
	return p
}

func InitEmptyAlter_resource_pool_actionContext(p *Alter_resource_pool_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_resource_pool_action
}

func (*Alter_resource_pool_actionContext) IsAlter_resource_pool_actionContext() {}

func NewAlter_resource_pool_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_resource_pool_actionContext {
	var p = new(Alter_resource_pool_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_resource_pool_action

	return p
}

func (s *Alter_resource_pool_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_resource_pool_actionContext) Alter_table_set_table_setting_compat() IAlter_table_set_table_setting_compatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_set_table_setting_compatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_set_table_setting_compatContext)
}

func (s *Alter_resource_pool_actionContext) Alter_table_reset_table_setting() IAlter_table_reset_table_settingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_reset_table_settingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_reset_table_settingContext)
}

func (s *Alter_resource_pool_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_resource_pool_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_resource_pool_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_resource_pool_action(s)
	}
}

func (s *Alter_resource_pool_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_resource_pool_action(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_resource_pool_action() (localctx IAlter_resource_pool_actionContext) {
	localctx = NewAlter_resource_pool_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 590, SQLv1Antlr4ParserRULE_alter_resource_pool_action)
	p.SetState(3610)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserSET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3608)
			p.Alter_table_set_table_setting_compat()
		}

	case SQLv1Antlr4ParserRESET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3609)
			p.Alter_table_reset_table_setting()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_resource_pool_stmtContext is an interface to support dynamic dispatch.
type IDrop_resource_pool_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	POOL() antlr.TerminalNode
	Object_ref() IObject_refContext

	// IsDrop_resource_pool_stmtContext differentiates from other interfaces.
	IsDrop_resource_pool_stmtContext()
}

type Drop_resource_pool_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_resource_pool_stmtContext() *Drop_resource_pool_stmtContext {
	var p = new(Drop_resource_pool_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_resource_pool_stmt
	return p
}

func InitEmptyDrop_resource_pool_stmtContext(p *Drop_resource_pool_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_resource_pool_stmt
}

func (*Drop_resource_pool_stmtContext) IsDrop_resource_pool_stmtContext() {}

func NewDrop_resource_pool_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_resource_pool_stmtContext {
	var p = new(Drop_resource_pool_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_resource_pool_stmt

	return p
}

func (s *Drop_resource_pool_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_resource_pool_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDROP, 0)
}

func (s *Drop_resource_pool_stmtContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRESOURCE, 0)
}

func (s *Drop_resource_pool_stmtContext) POOL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPOOL, 0)
}

func (s *Drop_resource_pool_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Drop_resource_pool_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_resource_pool_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_resource_pool_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterDrop_resource_pool_stmt(s)
	}
}

func (s *Drop_resource_pool_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitDrop_resource_pool_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Drop_resource_pool_stmt() (localctx IDrop_resource_pool_stmtContext) {
	localctx = NewDrop_resource_pool_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 592, SQLv1Antlr4ParserRULE_drop_resource_pool_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3612)
		p.Match(SQLv1Antlr4ParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3613)
		p.Match(SQLv1Antlr4ParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3614)
		p.Match(SQLv1Antlr4ParserPOOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3615)
		p.Object_ref()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_resource_pool_classifier_stmtContext is an interface to support dynamic dispatch.
type ICreate_resource_pool_classifier_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	POOL() antlr.TerminalNode
	CLASSIFIER() antlr.TerminalNode
	Object_ref() IObject_refContext
	With_table_settings() IWith_table_settingsContext

	// IsCreate_resource_pool_classifier_stmtContext differentiates from other interfaces.
	IsCreate_resource_pool_classifier_stmtContext()
}

type Create_resource_pool_classifier_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_resource_pool_classifier_stmtContext() *Create_resource_pool_classifier_stmtContext {
	var p = new(Create_resource_pool_classifier_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_resource_pool_classifier_stmt
	return p
}

func InitEmptyCreate_resource_pool_classifier_stmtContext(p *Create_resource_pool_classifier_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_resource_pool_classifier_stmt
}

func (*Create_resource_pool_classifier_stmtContext) IsCreate_resource_pool_classifier_stmtContext() {}

func NewCreate_resource_pool_classifier_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_resource_pool_classifier_stmtContext {
	var p = new(Create_resource_pool_classifier_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_resource_pool_classifier_stmt

	return p
}

func (s *Create_resource_pool_classifier_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_resource_pool_classifier_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCREATE, 0)
}

func (s *Create_resource_pool_classifier_stmtContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRESOURCE, 0)
}

func (s *Create_resource_pool_classifier_stmtContext) POOL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPOOL, 0)
}

func (s *Create_resource_pool_classifier_stmtContext) CLASSIFIER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCLASSIFIER, 0)
}

func (s *Create_resource_pool_classifier_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Create_resource_pool_classifier_stmtContext) With_table_settings() IWith_table_settingsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_table_settingsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_table_settingsContext)
}

func (s *Create_resource_pool_classifier_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_resource_pool_classifier_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_resource_pool_classifier_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterCreate_resource_pool_classifier_stmt(s)
	}
}

func (s *Create_resource_pool_classifier_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitCreate_resource_pool_classifier_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Create_resource_pool_classifier_stmt() (localctx ICreate_resource_pool_classifier_stmtContext) {
	localctx = NewCreate_resource_pool_classifier_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 594, SQLv1Antlr4ParserRULE_create_resource_pool_classifier_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3617)
		p.Match(SQLv1Antlr4ParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3618)
		p.Match(SQLv1Antlr4ParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3619)
		p.Match(SQLv1Antlr4ParserPOOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3620)
		p.Match(SQLv1Antlr4ParserCLASSIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3621)
		p.Object_ref()
	}
	{
		p.SetState(3622)
		p.With_table_settings()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_resource_pool_classifier_stmtContext is an interface to support dynamic dispatch.
type IAlter_resource_pool_classifier_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	POOL() antlr.TerminalNode
	CLASSIFIER() antlr.TerminalNode
	Object_ref() IObject_refContext
	AllAlter_resource_pool_classifier_action() []IAlter_resource_pool_classifier_actionContext
	Alter_resource_pool_classifier_action(i int) IAlter_resource_pool_classifier_actionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlter_resource_pool_classifier_stmtContext differentiates from other interfaces.
	IsAlter_resource_pool_classifier_stmtContext()
}

type Alter_resource_pool_classifier_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_resource_pool_classifier_stmtContext() *Alter_resource_pool_classifier_stmtContext {
	var p = new(Alter_resource_pool_classifier_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_resource_pool_classifier_stmt
	return p
}

func InitEmptyAlter_resource_pool_classifier_stmtContext(p *Alter_resource_pool_classifier_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_resource_pool_classifier_stmt
}

func (*Alter_resource_pool_classifier_stmtContext) IsAlter_resource_pool_classifier_stmtContext() {}

func NewAlter_resource_pool_classifier_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_resource_pool_classifier_stmtContext {
	var p = new(Alter_resource_pool_classifier_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_resource_pool_classifier_stmt

	return p
}

func (s *Alter_resource_pool_classifier_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_resource_pool_classifier_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserALTER, 0)
}

func (s *Alter_resource_pool_classifier_stmtContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRESOURCE, 0)
}

func (s *Alter_resource_pool_classifier_stmtContext) POOL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPOOL, 0)
}

func (s *Alter_resource_pool_classifier_stmtContext) CLASSIFIER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCLASSIFIER, 0)
}

func (s *Alter_resource_pool_classifier_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Alter_resource_pool_classifier_stmtContext) AllAlter_resource_pool_classifier_action() []IAlter_resource_pool_classifier_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlter_resource_pool_classifier_actionContext); ok {
			len++
		}
	}

	tst := make([]IAlter_resource_pool_classifier_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlter_resource_pool_classifier_actionContext); ok {
			tst[i] = t.(IAlter_resource_pool_classifier_actionContext)
			i++
		}
	}

	return tst
}

func (s *Alter_resource_pool_classifier_stmtContext) Alter_resource_pool_classifier_action(i int) IAlter_resource_pool_classifier_actionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_resource_pool_classifier_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_resource_pool_classifier_actionContext)
}

func (s *Alter_resource_pool_classifier_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Alter_resource_pool_classifier_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Alter_resource_pool_classifier_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_resource_pool_classifier_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_resource_pool_classifier_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_resource_pool_classifier_stmt(s)
	}
}

func (s *Alter_resource_pool_classifier_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_resource_pool_classifier_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_resource_pool_classifier_stmt() (localctx IAlter_resource_pool_classifier_stmtContext) {
	localctx = NewAlter_resource_pool_classifier_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 596, SQLv1Antlr4ParserRULE_alter_resource_pool_classifier_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3624)
		p.Match(SQLv1Antlr4ParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3625)
		p.Match(SQLv1Antlr4ParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3626)
		p.Match(SQLv1Antlr4ParserPOOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3627)
		p.Match(SQLv1Antlr4ParserCLASSIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3628)
		p.Object_ref()
	}
	{
		p.SetState(3629)
		p.Alter_resource_pool_classifier_action()
	}
	p.SetState(3634)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(3630)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3631)
			p.Alter_resource_pool_classifier_action()
		}

		p.SetState(3636)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_resource_pool_classifier_actionContext is an interface to support dynamic dispatch.
type IAlter_resource_pool_classifier_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Alter_table_set_table_setting_compat() IAlter_table_set_table_setting_compatContext
	Alter_table_reset_table_setting() IAlter_table_reset_table_settingContext

	// IsAlter_resource_pool_classifier_actionContext differentiates from other interfaces.
	IsAlter_resource_pool_classifier_actionContext()
}

type Alter_resource_pool_classifier_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_resource_pool_classifier_actionContext() *Alter_resource_pool_classifier_actionContext {
	var p = new(Alter_resource_pool_classifier_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_resource_pool_classifier_action
	return p
}

func InitEmptyAlter_resource_pool_classifier_actionContext(p *Alter_resource_pool_classifier_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_resource_pool_classifier_action
}

func (*Alter_resource_pool_classifier_actionContext) IsAlter_resource_pool_classifier_actionContext() {
}

func NewAlter_resource_pool_classifier_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_resource_pool_classifier_actionContext {
	var p = new(Alter_resource_pool_classifier_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_resource_pool_classifier_action

	return p
}

func (s *Alter_resource_pool_classifier_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_resource_pool_classifier_actionContext) Alter_table_set_table_setting_compat() IAlter_table_set_table_setting_compatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_set_table_setting_compatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_set_table_setting_compatContext)
}

func (s *Alter_resource_pool_classifier_actionContext) Alter_table_reset_table_setting() IAlter_table_reset_table_settingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_reset_table_settingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_reset_table_settingContext)
}

func (s *Alter_resource_pool_classifier_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_resource_pool_classifier_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_resource_pool_classifier_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_resource_pool_classifier_action(s)
	}
}

func (s *Alter_resource_pool_classifier_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_resource_pool_classifier_action(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_resource_pool_classifier_action() (localctx IAlter_resource_pool_classifier_actionContext) {
	localctx = NewAlter_resource_pool_classifier_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 598, SQLv1Antlr4ParserRULE_alter_resource_pool_classifier_action)
	p.SetState(3639)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserSET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3637)
			p.Alter_table_set_table_setting_compat()
		}

	case SQLv1Antlr4ParserRESET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3638)
			p.Alter_table_reset_table_setting()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_resource_pool_classifier_stmtContext is an interface to support dynamic dispatch.
type IDrop_resource_pool_classifier_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	POOL() antlr.TerminalNode
	CLASSIFIER() antlr.TerminalNode
	Object_ref() IObject_refContext

	// IsDrop_resource_pool_classifier_stmtContext differentiates from other interfaces.
	IsDrop_resource_pool_classifier_stmtContext()
}

type Drop_resource_pool_classifier_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_resource_pool_classifier_stmtContext() *Drop_resource_pool_classifier_stmtContext {
	var p = new(Drop_resource_pool_classifier_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_resource_pool_classifier_stmt
	return p
}

func InitEmptyDrop_resource_pool_classifier_stmtContext(p *Drop_resource_pool_classifier_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_resource_pool_classifier_stmt
}

func (*Drop_resource_pool_classifier_stmtContext) IsDrop_resource_pool_classifier_stmtContext() {}

func NewDrop_resource_pool_classifier_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_resource_pool_classifier_stmtContext {
	var p = new(Drop_resource_pool_classifier_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_resource_pool_classifier_stmt

	return p
}

func (s *Drop_resource_pool_classifier_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_resource_pool_classifier_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDROP, 0)
}

func (s *Drop_resource_pool_classifier_stmtContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRESOURCE, 0)
}

func (s *Drop_resource_pool_classifier_stmtContext) POOL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPOOL, 0)
}

func (s *Drop_resource_pool_classifier_stmtContext) CLASSIFIER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCLASSIFIER, 0)
}

func (s *Drop_resource_pool_classifier_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Drop_resource_pool_classifier_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_resource_pool_classifier_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_resource_pool_classifier_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterDrop_resource_pool_classifier_stmt(s)
	}
}

func (s *Drop_resource_pool_classifier_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitDrop_resource_pool_classifier_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Drop_resource_pool_classifier_stmt() (localctx IDrop_resource_pool_classifier_stmtContext) {
	localctx = NewDrop_resource_pool_classifier_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 600, SQLv1Antlr4ParserRULE_drop_resource_pool_classifier_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3641)
		p.Match(SQLv1Antlr4ParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3642)
		p.Match(SQLv1Antlr4ParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3643)
		p.Match(SQLv1Antlr4ParserPOOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3644)
		p.Match(SQLv1Antlr4ParserCLASSIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3645)
		p.Object_ref()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_replication_stmtContext is an interface to support dynamic dispatch.
type ICreate_replication_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	ASYNC() antlr.TerminalNode
	REPLICATION() antlr.TerminalNode
	Object_ref() IObject_refContext
	FOR() antlr.TerminalNode
	AllReplication_target() []IReplication_targetContext
	Replication_target(i int) IReplication_targetContext
	WITH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Replication_settings() IReplication_settingsContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCreate_replication_stmtContext differentiates from other interfaces.
	IsCreate_replication_stmtContext()
}

type Create_replication_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_replication_stmtContext() *Create_replication_stmtContext {
	var p = new(Create_replication_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_replication_stmt
	return p
}

func InitEmptyCreate_replication_stmtContext(p *Create_replication_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_replication_stmt
}

func (*Create_replication_stmtContext) IsCreate_replication_stmtContext() {}

func NewCreate_replication_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_replication_stmtContext {
	var p = new(Create_replication_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_replication_stmt

	return p
}

func (s *Create_replication_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_replication_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCREATE, 0)
}

func (s *Create_replication_stmtContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserASYNC, 0)
}

func (s *Create_replication_stmtContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREPLICATION, 0)
}

func (s *Create_replication_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Create_replication_stmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFOR, 0)
}

func (s *Create_replication_stmtContext) AllReplication_target() []IReplication_targetContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReplication_targetContext); ok {
			len++
		}
	}

	tst := make([]IReplication_targetContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReplication_targetContext); ok {
			tst[i] = t.(IReplication_targetContext)
			i++
		}
	}

	return tst
}

func (s *Create_replication_stmtContext) Replication_target(i int) IReplication_targetContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplication_targetContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplication_targetContext)
}

func (s *Create_replication_stmtContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWITH, 0)
}

func (s *Create_replication_stmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Create_replication_stmtContext) Replication_settings() IReplication_settingsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplication_settingsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplication_settingsContext)
}

func (s *Create_replication_stmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Create_replication_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Create_replication_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Create_replication_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_replication_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_replication_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterCreate_replication_stmt(s)
	}
}

func (s *Create_replication_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitCreate_replication_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Create_replication_stmt() (localctx ICreate_replication_stmtContext) {
	localctx = NewCreate_replication_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 602, SQLv1Antlr4ParserRULE_create_replication_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3647)
		p.Match(SQLv1Antlr4ParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3648)
		p.Match(SQLv1Antlr4ParserASYNC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3649)
		p.Match(SQLv1Antlr4ParserREPLICATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3650)
		p.Object_ref()
	}
	{
		p.SetState(3651)
		p.Match(SQLv1Antlr4ParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3652)
		p.Replication_target()
	}
	p.SetState(3657)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(3653)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3654)
			p.Replication_target()
		}

		p.SetState(3659)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3660)
		p.Match(SQLv1Antlr4ParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3661)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3662)
		p.Replication_settings()
	}
	{
		p.SetState(3663)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplication_targetContext is an interface to support dynamic dispatch.
type IReplication_targetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllObject_ref() []IObject_refContext
	Object_ref(i int) IObject_refContext
	AS() antlr.TerminalNode

	// IsReplication_targetContext differentiates from other interfaces.
	IsReplication_targetContext()
}

type Replication_targetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplication_targetContext() *Replication_targetContext {
	var p = new(Replication_targetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_replication_target
	return p
}

func InitEmptyReplication_targetContext(p *Replication_targetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_replication_target
}

func (*Replication_targetContext) IsReplication_targetContext() {}

func NewReplication_targetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Replication_targetContext {
	var p = new(Replication_targetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_replication_target

	return p
}

func (s *Replication_targetContext) GetParser() antlr.Parser { return s.parser }

func (s *Replication_targetContext) AllObject_ref() []IObject_refContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IObject_refContext); ok {
			len++
		}
	}

	tst := make([]IObject_refContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IObject_refContext); ok {
			tst[i] = t.(IObject_refContext)
			i++
		}
	}

	return tst
}

func (s *Replication_targetContext) Object_ref(i int) IObject_refContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Replication_targetContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAS, 0)
}

func (s *Replication_targetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Replication_targetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Replication_targetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterReplication_target(s)
	}
}

func (s *Replication_targetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitReplication_target(s)
	}
}

func (p *SQLv1Antlr4Parser) Replication_target() (localctx IReplication_targetContext) {
	localctx = NewReplication_targetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 604, SQLv1Antlr4ParserRULE_replication_target)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3665)
		p.Object_ref()
	}
	{
		p.SetState(3666)
		p.Match(SQLv1Antlr4ParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3667)
		p.Object_ref()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplication_settingsContext is an interface to support dynamic dispatch.
type IReplication_settingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllReplication_settings_entry() []IReplication_settings_entryContext
	Replication_settings_entry(i int) IReplication_settings_entryContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsReplication_settingsContext differentiates from other interfaces.
	IsReplication_settingsContext()
}

type Replication_settingsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplication_settingsContext() *Replication_settingsContext {
	var p = new(Replication_settingsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_replication_settings
	return p
}

func InitEmptyReplication_settingsContext(p *Replication_settingsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_replication_settings
}

func (*Replication_settingsContext) IsReplication_settingsContext() {}

func NewReplication_settingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Replication_settingsContext {
	var p = new(Replication_settingsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_replication_settings

	return p
}

func (s *Replication_settingsContext) GetParser() antlr.Parser { return s.parser }

func (s *Replication_settingsContext) AllReplication_settings_entry() []IReplication_settings_entryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReplication_settings_entryContext); ok {
			len++
		}
	}

	tst := make([]IReplication_settings_entryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReplication_settings_entryContext); ok {
			tst[i] = t.(IReplication_settings_entryContext)
			i++
		}
	}

	return tst
}

func (s *Replication_settingsContext) Replication_settings_entry(i int) IReplication_settings_entryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplication_settings_entryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplication_settings_entryContext)
}

func (s *Replication_settingsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Replication_settingsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Replication_settingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Replication_settingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Replication_settingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterReplication_settings(s)
	}
}

func (s *Replication_settingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitReplication_settings(s)
	}
}

func (p *SQLv1Antlr4Parser) Replication_settings() (localctx IReplication_settingsContext) {
	localctx = NewReplication_settingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 606, SQLv1Antlr4ParserRULE_replication_settings)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3669)
		p.Replication_settings_entry()
	}
	p.SetState(3674)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(3670)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3671)
			p.Replication_settings_entry()
		}

		p.SetState(3676)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplication_settings_entryContext is an interface to support dynamic dispatch.
type IReplication_settings_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext
	EQUALS() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode

	// IsReplication_settings_entryContext differentiates from other interfaces.
	IsReplication_settings_entryContext()
}

type Replication_settings_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplication_settings_entryContext() *Replication_settings_entryContext {
	var p = new(Replication_settings_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_replication_settings_entry
	return p
}

func InitEmptyReplication_settings_entryContext(p *Replication_settings_entryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_replication_settings_entry
}

func (*Replication_settings_entryContext) IsReplication_settings_entryContext() {}

func NewReplication_settings_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Replication_settings_entryContext {
	var p = new(Replication_settings_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_replication_settings_entry

	return p
}

func (s *Replication_settings_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Replication_settings_entryContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Replication_settings_entryContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEQUALS, 0)
}

func (s *Replication_settings_entryContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRING_VALUE, 0)
}

func (s *Replication_settings_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Replication_settings_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Replication_settings_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterReplication_settings_entry(s)
	}
}

func (s *Replication_settings_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitReplication_settings_entry(s)
	}
}

func (p *SQLv1Antlr4Parser) Replication_settings_entry() (localctx IReplication_settings_entryContext) {
	localctx = NewReplication_settings_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 608, SQLv1Antlr4ParserRULE_replication_settings_entry)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3677)
		p.An_id()
	}
	{
		p.SetState(3678)
		p.Match(SQLv1Antlr4ParserEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3679)
		p.Match(SQLv1Antlr4ParserSTRING_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_replication_stmtContext is an interface to support dynamic dispatch.
type IAlter_replication_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	ASYNC() antlr.TerminalNode
	REPLICATION() antlr.TerminalNode
	Object_ref() IObject_refContext
	AllAlter_replication_action() []IAlter_replication_actionContext
	Alter_replication_action(i int) IAlter_replication_actionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlter_replication_stmtContext differentiates from other interfaces.
	IsAlter_replication_stmtContext()
}

type Alter_replication_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_replication_stmtContext() *Alter_replication_stmtContext {
	var p = new(Alter_replication_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_replication_stmt
	return p
}

func InitEmptyAlter_replication_stmtContext(p *Alter_replication_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_replication_stmt
}

func (*Alter_replication_stmtContext) IsAlter_replication_stmtContext() {}

func NewAlter_replication_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_replication_stmtContext {
	var p = new(Alter_replication_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_replication_stmt

	return p
}

func (s *Alter_replication_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_replication_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserALTER, 0)
}

func (s *Alter_replication_stmtContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserASYNC, 0)
}

func (s *Alter_replication_stmtContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREPLICATION, 0)
}

func (s *Alter_replication_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Alter_replication_stmtContext) AllAlter_replication_action() []IAlter_replication_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlter_replication_actionContext); ok {
			len++
		}
	}

	tst := make([]IAlter_replication_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlter_replication_actionContext); ok {
			tst[i] = t.(IAlter_replication_actionContext)
			i++
		}
	}

	return tst
}

func (s *Alter_replication_stmtContext) Alter_replication_action(i int) IAlter_replication_actionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_replication_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_replication_actionContext)
}

func (s *Alter_replication_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Alter_replication_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Alter_replication_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_replication_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_replication_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_replication_stmt(s)
	}
}

func (s *Alter_replication_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_replication_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_replication_stmt() (localctx IAlter_replication_stmtContext) {
	localctx = NewAlter_replication_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 610, SQLv1Antlr4ParserRULE_alter_replication_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3681)
		p.Match(SQLv1Antlr4ParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3682)
		p.Match(SQLv1Antlr4ParserASYNC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3683)
		p.Match(SQLv1Antlr4ParserREPLICATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3684)
		p.Object_ref()
	}
	{
		p.SetState(3685)
		p.Alter_replication_action()
	}
	p.SetState(3690)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(3686)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3687)
			p.Alter_replication_action()
		}

		p.SetState(3692)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_replication_actionContext is an interface to support dynamic dispatch.
type IAlter_replication_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Alter_replication_set_setting() IAlter_replication_set_settingContext

	// IsAlter_replication_actionContext differentiates from other interfaces.
	IsAlter_replication_actionContext()
}

type Alter_replication_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_replication_actionContext() *Alter_replication_actionContext {
	var p = new(Alter_replication_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_replication_action
	return p
}

func InitEmptyAlter_replication_actionContext(p *Alter_replication_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_replication_action
}

func (*Alter_replication_actionContext) IsAlter_replication_actionContext() {}

func NewAlter_replication_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_replication_actionContext {
	var p = new(Alter_replication_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_replication_action

	return p
}

func (s *Alter_replication_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_replication_actionContext) Alter_replication_set_setting() IAlter_replication_set_settingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_replication_set_settingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_replication_set_settingContext)
}

func (s *Alter_replication_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_replication_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_replication_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_replication_action(s)
	}
}

func (s *Alter_replication_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_replication_action(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_replication_action() (localctx IAlter_replication_actionContext) {
	localctx = NewAlter_replication_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 612, SQLv1Antlr4ParserRULE_alter_replication_action)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3693)
		p.Alter_replication_set_setting()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_replication_set_settingContext is an interface to support dynamic dispatch.
type IAlter_replication_set_settingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Replication_settings() IReplication_settingsContext
	RPAREN() antlr.TerminalNode

	// IsAlter_replication_set_settingContext differentiates from other interfaces.
	IsAlter_replication_set_settingContext()
}

type Alter_replication_set_settingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_replication_set_settingContext() *Alter_replication_set_settingContext {
	var p = new(Alter_replication_set_settingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_replication_set_setting
	return p
}

func InitEmptyAlter_replication_set_settingContext(p *Alter_replication_set_settingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_replication_set_setting
}

func (*Alter_replication_set_settingContext) IsAlter_replication_set_settingContext() {}

func NewAlter_replication_set_settingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_replication_set_settingContext {
	var p = new(Alter_replication_set_settingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_replication_set_setting

	return p
}

func (s *Alter_replication_set_settingContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_replication_set_settingContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSET, 0)
}

func (s *Alter_replication_set_settingContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Alter_replication_set_settingContext) Replication_settings() IReplication_settingsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplication_settingsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplication_settingsContext)
}

func (s *Alter_replication_set_settingContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Alter_replication_set_settingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_replication_set_settingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_replication_set_settingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_replication_set_setting(s)
	}
}

func (s *Alter_replication_set_settingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_replication_set_setting(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_replication_set_setting() (localctx IAlter_replication_set_settingContext) {
	localctx = NewAlter_replication_set_settingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 614, SQLv1Antlr4ParserRULE_alter_replication_set_setting)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3695)
		p.Match(SQLv1Antlr4ParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3696)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3697)
		p.Replication_settings()
	}
	{
		p.SetState(3698)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_replication_stmtContext is an interface to support dynamic dispatch.
type IDrop_replication_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	ASYNC() antlr.TerminalNode
	REPLICATION() antlr.TerminalNode
	Object_ref() IObject_refContext
	CASCADE() antlr.TerminalNode

	// IsDrop_replication_stmtContext differentiates from other interfaces.
	IsDrop_replication_stmtContext()
}

type Drop_replication_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_replication_stmtContext() *Drop_replication_stmtContext {
	var p = new(Drop_replication_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_replication_stmt
	return p
}

func InitEmptyDrop_replication_stmtContext(p *Drop_replication_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_replication_stmt
}

func (*Drop_replication_stmtContext) IsDrop_replication_stmtContext() {}

func NewDrop_replication_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_replication_stmtContext {
	var p = new(Drop_replication_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_replication_stmt

	return p
}

func (s *Drop_replication_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_replication_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDROP, 0)
}

func (s *Drop_replication_stmtContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserASYNC, 0)
}

func (s *Drop_replication_stmtContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREPLICATION, 0)
}

func (s *Drop_replication_stmtContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Drop_replication_stmtContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCASCADE, 0)
}

func (s *Drop_replication_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_replication_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_replication_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterDrop_replication_stmt(s)
	}
}

func (s *Drop_replication_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitDrop_replication_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Drop_replication_stmt() (localctx IDrop_replication_stmtContext) {
	localctx = NewDrop_replication_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 616, SQLv1Antlr4ParserRULE_drop_replication_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3700)
		p.Match(SQLv1Antlr4ParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3701)
		p.Match(SQLv1Antlr4ParserASYNC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3702)
		p.Match(SQLv1Antlr4ParserREPLICATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3703)
		p.Object_ref()
	}
	p.SetState(3705)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserCASCADE {
		{
			p.SetState(3704)
			p.Match(SQLv1Antlr4ParserCASCADE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAction_or_subquery_argsContext is an interface to support dynamic dispatch.
type IAction_or_subquery_argsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllOpt_bind_parameter() []IOpt_bind_parameterContext
	Opt_bind_parameter(i int) IOpt_bind_parameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAction_or_subquery_argsContext differentiates from other interfaces.
	IsAction_or_subquery_argsContext()
}

type Action_or_subquery_argsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAction_or_subquery_argsContext() *Action_or_subquery_argsContext {
	var p = new(Action_or_subquery_argsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_action_or_subquery_args
	return p
}

func InitEmptyAction_or_subquery_argsContext(p *Action_or_subquery_argsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_action_or_subquery_args
}

func (*Action_or_subquery_argsContext) IsAction_or_subquery_argsContext() {}

func NewAction_or_subquery_argsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Action_or_subquery_argsContext {
	var p = new(Action_or_subquery_argsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_action_or_subquery_args

	return p
}

func (s *Action_or_subquery_argsContext) GetParser() antlr.Parser { return s.parser }

func (s *Action_or_subquery_argsContext) AllOpt_bind_parameter() []IOpt_bind_parameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOpt_bind_parameterContext); ok {
			len++
		}
	}

	tst := make([]IOpt_bind_parameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOpt_bind_parameterContext); ok {
			tst[i] = t.(IOpt_bind_parameterContext)
			i++
		}
	}

	return tst
}

func (s *Action_or_subquery_argsContext) Opt_bind_parameter(i int) IOpt_bind_parameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_bind_parameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_bind_parameterContext)
}

func (s *Action_or_subquery_argsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Action_or_subquery_argsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Action_or_subquery_argsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Action_or_subquery_argsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Action_or_subquery_argsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAction_or_subquery_args(s)
	}
}

func (s *Action_or_subquery_argsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAction_or_subquery_args(s)
	}
}

func (p *SQLv1Antlr4Parser) Action_or_subquery_args() (localctx IAction_or_subquery_argsContext) {
	localctx = NewAction_or_subquery_argsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 618, SQLv1Antlr4ParserRULE_action_or_subquery_args)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3707)
		p.Opt_bind_parameter()
	}
	p.SetState(3712)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(3708)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3709)
			p.Opt_bind_parameter()
		}

		p.SetState(3714)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefine_action_or_subquery_stmtContext is an interface to support dynamic dispatch.
type IDefine_action_or_subquery_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDEFINE() []antlr.TerminalNode
	DEFINE(i int) antlr.TerminalNode
	Bind_parameter() IBind_parameterContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AS() antlr.TerminalNode
	Define_action_or_subquery_body() IDefine_action_or_subquery_bodyContext
	END() antlr.TerminalNode
	ACTION() antlr.TerminalNode
	SUBQUERY() antlr.TerminalNode
	Action_or_subquery_args() IAction_or_subquery_argsContext

	// IsDefine_action_or_subquery_stmtContext differentiates from other interfaces.
	IsDefine_action_or_subquery_stmtContext()
}

type Define_action_or_subquery_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefine_action_or_subquery_stmtContext() *Define_action_or_subquery_stmtContext {
	var p = new(Define_action_or_subquery_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_define_action_or_subquery_stmt
	return p
}

func InitEmptyDefine_action_or_subquery_stmtContext(p *Define_action_or_subquery_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_define_action_or_subquery_stmt
}

func (*Define_action_or_subquery_stmtContext) IsDefine_action_or_subquery_stmtContext() {}

func NewDefine_action_or_subquery_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Define_action_or_subquery_stmtContext {
	var p = new(Define_action_or_subquery_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_define_action_or_subquery_stmt

	return p
}

func (s *Define_action_or_subquery_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Define_action_or_subquery_stmtContext) AllDEFINE() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserDEFINE)
}

func (s *Define_action_or_subquery_stmtContext) DEFINE(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDEFINE, i)
}

func (s *Define_action_or_subquery_stmtContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Define_action_or_subquery_stmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Define_action_or_subquery_stmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Define_action_or_subquery_stmtContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAS, 0)
}

func (s *Define_action_or_subquery_stmtContext) Define_action_or_subquery_body() IDefine_action_or_subquery_bodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefine_action_or_subquery_bodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefine_action_or_subquery_bodyContext)
}

func (s *Define_action_or_subquery_stmtContext) END() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEND, 0)
}

func (s *Define_action_or_subquery_stmtContext) ACTION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserACTION, 0)
}

func (s *Define_action_or_subquery_stmtContext) SUBQUERY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSUBQUERY, 0)
}

func (s *Define_action_or_subquery_stmtContext) Action_or_subquery_args() IAction_or_subquery_argsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_or_subquery_argsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_or_subquery_argsContext)
}

func (s *Define_action_or_subquery_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Define_action_or_subquery_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Define_action_or_subquery_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterDefine_action_or_subquery_stmt(s)
	}
}

func (s *Define_action_or_subquery_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitDefine_action_or_subquery_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Define_action_or_subquery_stmt() (localctx IDefine_action_or_subquery_stmtContext) {
	localctx = NewDefine_action_or_subquery_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 620, SQLv1Antlr4ParserRULE_define_action_or_subquery_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3715)
		p.Match(SQLv1Antlr4ParserDEFINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3716)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLv1Antlr4ParserACTION || _la == SQLv1Antlr4ParserSUBQUERY) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3717)
		p.Bind_parameter()
	}
	{
		p.SetState(3718)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3720)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserDOLLAR {
		{
			p.SetState(3719)
			p.Action_or_subquery_args()
		}

	}
	{
		p.SetState(3722)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3723)
		p.Match(SQLv1Antlr4ParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3724)
		p.Define_action_or_subquery_body()
	}
	{
		p.SetState(3725)
		p.Match(SQLv1Antlr4ParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3726)
		p.Match(SQLv1Antlr4ParserDEFINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefine_action_or_subquery_bodyContext is an interface to support dynamic dispatch.
type IDefine_action_or_subquery_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode
	AllSql_stmt_core() []ISql_stmt_coreContext
	Sql_stmt_core(i int) ISql_stmt_coreContext

	// IsDefine_action_or_subquery_bodyContext differentiates from other interfaces.
	IsDefine_action_or_subquery_bodyContext()
}

type Define_action_or_subquery_bodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefine_action_or_subquery_bodyContext() *Define_action_or_subquery_bodyContext {
	var p = new(Define_action_or_subquery_bodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_define_action_or_subquery_body
	return p
}

func InitEmptyDefine_action_or_subquery_bodyContext(p *Define_action_or_subquery_bodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_define_action_or_subquery_body
}

func (*Define_action_or_subquery_bodyContext) IsDefine_action_or_subquery_bodyContext() {}

func NewDefine_action_or_subquery_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Define_action_or_subquery_bodyContext {
	var p = new(Define_action_or_subquery_bodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_define_action_or_subquery_body

	return p
}

func (s *Define_action_or_subquery_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Define_action_or_subquery_bodyContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserSEMICOLON)
}

func (s *Define_action_or_subquery_bodyContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSEMICOLON, i)
}

func (s *Define_action_or_subquery_bodyContext) AllSql_stmt_core() []ISql_stmt_coreContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_stmt_coreContext); ok {
			len++
		}
	}

	tst := make([]ISql_stmt_coreContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_stmt_coreContext); ok {
			tst[i] = t.(ISql_stmt_coreContext)
			i++
		}
	}

	return tst
}

func (s *Define_action_or_subquery_bodyContext) Sql_stmt_core(i int) ISql_stmt_coreContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_stmt_coreContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_stmt_coreContext)
}

func (s *Define_action_or_subquery_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Define_action_or_subquery_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Define_action_or_subquery_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterDefine_action_or_subquery_body(s)
	}
}

func (s *Define_action_or_subquery_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitDefine_action_or_subquery_body(s)
	}
}

func (p *SQLv1Antlr4Parser) Define_action_or_subquery_body() (localctx IDefine_action_or_subquery_bodyContext) {
	localctx = NewDefine_action_or_subquery_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 622, SQLv1Antlr4ParserRULE_define_action_or_subquery_body)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3731)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserSEMICOLON {
		{
			p.SetState(3728)
			p.Match(SQLv1Antlr4ParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(3733)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3752)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&844429292208128) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4615348560446357505) != 0) || ((int64((_la-133)) & ^0x3f) == 0 && ((int64(1)<<(_la-133))&137724302337) != 0) || ((int64((_la-218)) & ^0x3f) == 0 && ((int64(1)<<(_la-218))&1128378237748225) != 0) || ((int64((_la-305)) & ^0x3f) == 0 && ((int64(1)<<(_la-305))&71) != 0) {
		{
			p.SetState(3734)
			p.Sql_stmt_core()
		}
		p.SetState(3743)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 382, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(3736)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for ok := true; ok; ok = _la == SQLv1Antlr4ParserSEMICOLON {
					{
						p.SetState(3735)
						p.Match(SQLv1Antlr4ParserSEMICOLON)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

					p.SetState(3738)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(3740)
					p.Sql_stmt_core()
				}

			}
			p.SetState(3745)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 382, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(3749)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SQLv1Antlr4ParserSEMICOLON {
			{
				p.SetState(3746)
				p.Match(SQLv1Antlr4ParserSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(3751)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIf_stmtContext is an interface to support dynamic dispatch.
type IIf_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	Expr() IExprContext
	AllDo_stmt() []IDo_stmtContext
	Do_stmt(i int) IDo_stmtContext
	EVALUATE() antlr.TerminalNode
	ELSE() antlr.TerminalNode

	// IsIf_stmtContext differentiates from other interfaces.
	IsIf_stmtContext()
}

type If_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_stmtContext() *If_stmtContext {
	var p = new(If_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_if_stmt
	return p
}

func InitEmptyIf_stmtContext(p *If_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_if_stmt
}

func (*If_stmtContext) IsIf_stmtContext() {}

func NewIf_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_stmtContext {
	var p = new(If_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_if_stmt

	return p
}

func (s *If_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *If_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIF, 0)
}

func (s *If_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *If_stmtContext) AllDo_stmt() []IDo_stmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDo_stmtContext); ok {
			len++
		}
	}

	tst := make([]IDo_stmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDo_stmtContext); ok {
			tst[i] = t.(IDo_stmtContext)
			i++
		}
	}

	return tst
}

func (s *If_stmtContext) Do_stmt(i int) IDo_stmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDo_stmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDo_stmtContext)
}

func (s *If_stmtContext) EVALUATE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEVALUATE, 0)
}

func (s *If_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserELSE, 0)
}

func (s *If_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterIf_stmt(s)
	}
}

func (s *If_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitIf_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) If_stmt() (localctx IIf_stmtContext) {
	localctx = NewIf_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 624, SQLv1Antlr4ParserRULE_if_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3755)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserEVALUATE {
		{
			p.SetState(3754)
			p.Match(SQLv1Antlr4ParserEVALUATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3757)
		p.Match(SQLv1Antlr4ParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3758)
		p.Expr()
	}
	{
		p.SetState(3759)
		p.Do_stmt()
	}
	p.SetState(3762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserELSE {
		{
			p.SetState(3760)
			p.Match(SQLv1Antlr4ParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3761)
			p.Do_stmt()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFor_stmtContext is an interface to support dynamic dispatch.
type IFor_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	Bind_parameter() IBind_parameterContext
	IN() antlr.TerminalNode
	Expr() IExprContext
	AllDo_stmt() []IDo_stmtContext
	Do_stmt(i int) IDo_stmtContext
	EVALUATE() antlr.TerminalNode
	PARALLEL() antlr.TerminalNode
	ELSE() antlr.TerminalNode

	// IsFor_stmtContext differentiates from other interfaces.
	IsFor_stmtContext()
}

type For_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_stmtContext() *For_stmtContext {
	var p = new(For_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_for_stmt
	return p
}

func InitEmptyFor_stmtContext(p *For_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_for_stmt
}

func (*For_stmtContext) IsFor_stmtContext() {}

func NewFor_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_stmtContext {
	var p = new(For_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_for_stmt

	return p
}

func (s *For_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *For_stmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFOR, 0)
}

func (s *For_stmtContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *For_stmtContext) IN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIN, 0)
}

func (s *For_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *For_stmtContext) AllDo_stmt() []IDo_stmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDo_stmtContext); ok {
			len++
		}
	}

	tst := make([]IDo_stmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDo_stmtContext); ok {
			tst[i] = t.(IDo_stmtContext)
			i++
		}
	}

	return tst
}

func (s *For_stmtContext) Do_stmt(i int) IDo_stmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDo_stmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDo_stmtContext)
}

func (s *For_stmtContext) EVALUATE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEVALUATE, 0)
}

func (s *For_stmtContext) PARALLEL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPARALLEL, 0)
}

func (s *For_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserELSE, 0)
}

func (s *For_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterFor_stmt(s)
	}
}

func (s *For_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitFor_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) For_stmt() (localctx IFor_stmtContext) {
	localctx = NewFor_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 626, SQLv1Antlr4ParserRULE_for_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3765)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserEVALUATE {
		{
			p.SetState(3764)
			p.Match(SQLv1Antlr4ParserEVALUATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3768)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserPARALLEL {
		{
			p.SetState(3767)
			p.Match(SQLv1Antlr4ParserPARALLEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3770)
		p.Match(SQLv1Antlr4ParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3771)
		p.Bind_parameter()
	}
	{
		p.SetState(3772)
		p.Match(SQLv1Antlr4ParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3773)
		p.Expr()
	}
	{
		p.SetState(3774)
		p.Do_stmt()
	}
	p.SetState(3777)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserELSE {
		{
			p.SetState(3775)
			p.Match(SQLv1Antlr4ParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3776)
			p.Do_stmt()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_refContext is an interface to support dynamic dispatch.
type ITable_refContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_key() ITable_keyContext
	An_id_expr() IAn_id_exprContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Bind_parameter() IBind_parameterContext
	Cluster_expr() ICluster_exprContext
	DOT() antlr.TerminalNode
	COMMAT() antlr.TerminalNode
	Table_hints() ITable_hintsContext
	AllTable_arg() []ITable_argContext
	Table_arg(i int) ITable_argContext
	VIEW() antlr.TerminalNode
	View_name() IView_nameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	Expr_list() IExpr_listContext

	// IsTable_refContext differentiates from other interfaces.
	IsTable_refContext()
}

type Table_refContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_refContext() *Table_refContext {
	var p = new(Table_refContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_ref
	return p
}

func InitEmptyTable_refContext(p *Table_refContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_ref
}

func (*Table_refContext) IsTable_refContext() {}

func NewTable_refContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_refContext {
	var p = new(Table_refContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_ref

	return p
}

func (s *Table_refContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_refContext) Table_key() ITable_keyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_keyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_keyContext)
}

func (s *Table_refContext) An_id_expr() IAn_id_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_exprContext)
}

func (s *Table_refContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Table_refContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Table_refContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Table_refContext) Cluster_expr() ICluster_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICluster_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICluster_exprContext)
}

func (s *Table_refContext) DOT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDOT, 0)
}

func (s *Table_refContext) COMMAT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMAT, 0)
}

func (s *Table_refContext) Table_hints() ITable_hintsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_hintsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_hintsContext)
}

func (s *Table_refContext) AllTable_arg() []ITable_argContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITable_argContext); ok {
			len++
		}
	}

	tst := make([]ITable_argContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITable_argContext); ok {
			tst[i] = t.(ITable_argContext)
			i++
		}
	}

	return tst
}

func (s *Table_refContext) Table_arg(i int) ITable_argContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_argContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_argContext)
}

func (s *Table_refContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserVIEW, 0)
}

func (s *Table_refContext) View_name() IView_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IView_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IView_nameContext)
}

func (s *Table_refContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Table_refContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Table_refContext) Expr_list() IExpr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_listContext)
}

func (s *Table_refContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_refContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_refContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterTable_ref(s)
	}
}

func (s *Table_refContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitTable_ref(s)
	}
}

func (p *SQLv1Antlr4Parser) Table_ref() (localctx ITable_refContext) {
	localctx = NewTable_refContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 628, SQLv1Antlr4ParserRULE_table_ref)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3782)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 390, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3779)
			p.Cluster_expr()
		}
		{
			p.SetState(3780)
			p.Match(SQLv1Antlr4ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3785)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserCOMMAT {
		{
			p.SetState(3784)
			p.Match(SQLv1Antlr4ParserCOMMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3817)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 398, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3787)
			p.Table_key()
		}

	case 2:
		{
			p.SetState(3788)
			p.An_id_expr()
		}
		{
			p.SetState(3789)
			p.Match(SQLv1Antlr4ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3801)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-14)) & ^0x3f) == 0 && ((int64(1)<<(_la-14))&-562950217330659) != 0) || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&-1) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&-129) != 0) || ((int64((_la-206)) & ^0x3f) == 0 && ((int64(1)<<(_la-206))&-274877906945) != 0) || ((int64((_la-270)) & ^0x3f) == 0 && ((int64(1)<<(_la-270))&576460752303423487) != 0) {
			{
				p.SetState(3790)
				p.Table_arg()
			}
			p.SetState(3795)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 392, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(3791)
						p.Match(SQLv1Antlr4ParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(3792)
						p.Table_arg()
					}

				}
				p.SetState(3797)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 392, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			p.SetState(3799)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SQLv1Antlr4ParserCOMMA {
				{
					p.SetState(3798)
					p.Match(SQLv1Antlr4ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		}
		{
			p.SetState(3803)
			p.Match(SQLv1Antlr4ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(3805)
			p.Bind_parameter()
		}
		p.SetState(3811)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserLPAREN {
			{
				p.SetState(3806)
				p.Match(SQLv1Antlr4ParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3808)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64((_la-14)) & ^0x3f) == 0 && ((int64(1)<<(_la-14))&-562950217396195) != 0) || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&-1) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&-129) != 0) || ((int64((_la-206)) & ^0x3f) == 0 && ((int64(1)<<(_la-206))&-274877906945) != 0) || ((int64((_la-270)) & ^0x3f) == 0 && ((int64(1)<<(_la-270))&576460752303423487) != 0) {
				{
					p.SetState(3807)
					p.Expr_list()
				}

			}
			{
				p.SetState(3810)
				p.Match(SQLv1Antlr4ParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3815)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserVIEW {
			{
				p.SetState(3813)
				p.Match(SQLv1Antlr4ParserVIEW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3814)
				p.View_name()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(3820)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserWITH {
		{
			p.SetState(3819)
			p.Table_hints()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_keyContext is an interface to support dynamic dispatch.
type ITable_keyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_table_or_type() IId_table_or_typeContext
	VIEW() antlr.TerminalNode
	View_name() IView_nameContext

	// IsTable_keyContext differentiates from other interfaces.
	IsTable_keyContext()
}

type Table_keyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_keyContext() *Table_keyContext {
	var p = new(Table_keyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_key
	return p
}

func InitEmptyTable_keyContext(p *Table_keyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_key
}

func (*Table_keyContext) IsTable_keyContext() {}

func NewTable_keyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_keyContext {
	var p = new(Table_keyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_key

	return p
}

func (s *Table_keyContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_keyContext) Id_table_or_type() IId_table_or_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_table_or_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_table_or_typeContext)
}

func (s *Table_keyContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserVIEW, 0)
}

func (s *Table_keyContext) View_name() IView_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IView_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IView_nameContext)
}

func (s *Table_keyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_keyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_keyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterTable_key(s)
	}
}

func (s *Table_keyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitTable_key(s)
	}
}

func (p *SQLv1Antlr4Parser) Table_key() (localctx ITable_keyContext) {
	localctx = NewTable_keyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 630, SQLv1Antlr4ParserRULE_table_key)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3822)
		p.Id_table_or_type()
	}
	p.SetState(3825)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserVIEW {
		{
			p.SetState(3823)
			p.Match(SQLv1Antlr4ParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3824)
			p.View_name()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_argContext is an interface to support dynamic dispatch.
type ITable_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Named_expr() INamed_exprContext
	COMMAT() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	View_name() IView_nameContext

	// IsTable_argContext differentiates from other interfaces.
	IsTable_argContext()
}

type Table_argContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_argContext() *Table_argContext {
	var p = new(Table_argContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_arg
	return p
}

func InitEmptyTable_argContext(p *Table_argContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_arg
}

func (*Table_argContext) IsTable_argContext() {}

func NewTable_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_argContext {
	var p = new(Table_argContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_arg

	return p
}

func (s *Table_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_argContext) Named_expr() INamed_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_exprContext)
}

func (s *Table_argContext) COMMAT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMAT, 0)
}

func (s *Table_argContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserVIEW, 0)
}

func (s *Table_argContext) View_name() IView_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IView_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IView_nameContext)
}

func (s *Table_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterTable_arg(s)
	}
}

func (s *Table_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitTable_arg(s)
	}
}

func (p *SQLv1Antlr4Parser) Table_arg() (localctx ITable_argContext) {
	localctx = NewTable_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 632, SQLv1Antlr4ParserRULE_table_arg)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3828)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserCOMMAT {
		{
			p.SetState(3827)
			p.Match(SQLv1Antlr4ParserCOMMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3830)
		p.Named_expr()
	}
	p.SetState(3833)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserVIEW {
		{
			p.SetState(3831)
			p.Match(SQLv1Antlr4ParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3832)
			p.View_name()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_hintsContext is an interface to support dynamic dispatch.
type ITable_hintsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	AllTable_hint() []ITable_hintContext
	Table_hint(i int) ITable_hintContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTable_hintsContext differentiates from other interfaces.
	IsTable_hintsContext()
}

type Table_hintsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_hintsContext() *Table_hintsContext {
	var p = new(Table_hintsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_hints
	return p
}

func InitEmptyTable_hintsContext(p *Table_hintsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_hints
}

func (*Table_hintsContext) IsTable_hintsContext() {}

func NewTable_hintsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_hintsContext {
	var p = new(Table_hintsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_hints

	return p
}

func (s *Table_hintsContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_hintsContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWITH, 0)
}

func (s *Table_hintsContext) AllTable_hint() []ITable_hintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITable_hintContext); ok {
			len++
		}
	}

	tst := make([]ITable_hintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITable_hintContext); ok {
			tst[i] = t.(ITable_hintContext)
			i++
		}
	}

	return tst
}

func (s *Table_hintsContext) Table_hint(i int) ITable_hintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_hintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_hintContext)
}

func (s *Table_hintsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Table_hintsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Table_hintsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Table_hintsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Table_hintsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_hintsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_hintsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterTable_hints(s)
	}
}

func (s *Table_hintsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitTable_hints(s)
	}
}

func (p *SQLv1Antlr4Parser) Table_hints() (localctx ITable_hintsContext) {
	localctx = NewTable_hintsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 634, SQLv1Antlr4ParserRULE_table_hints)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3835)
		p.Match(SQLv1Antlr4ParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3848)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALL, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserANY, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSTREAM, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWITHOUT, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserSTRING_VALUE, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		{
			p.SetState(3836)
			p.Table_hint()
		}

	case SQLv1Antlr4ParserLPAREN:
		{
			p.SetState(3837)
			p.Match(SQLv1Antlr4ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3838)
			p.Table_hint()
		}
		p.SetState(3843)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SQLv1Antlr4ParserCOMMA {
			{
				p.SetState(3839)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3840)
				p.Table_hint()
			}

			p.SetState(3845)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3846)
			p.Match(SQLv1Antlr4ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_hintContext is an interface to support dynamic dispatch.
type ITable_hintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id_hint() IAn_id_hintContext
	EQUALS() antlr.TerminalNode
	AllType_name_tag() []IType_name_tagContext
	Type_name_tag(i int) IType_name_tagContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	Type_name_or_bind() IType_name_or_bindContext
	SCHEMA() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	AllStruct_arg_positional() []IStruct_arg_positionalContext
	Struct_arg_positional(i int) IStruct_arg_positionalContext

	// IsTable_hintContext differentiates from other interfaces.
	IsTable_hintContext()
}

type Table_hintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_hintContext() *Table_hintContext {
	var p = new(Table_hintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_hint
	return p
}

func InitEmptyTable_hintContext(p *Table_hintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_hint
}

func (*Table_hintContext) IsTable_hintContext() {}

func NewTable_hintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_hintContext {
	var p = new(Table_hintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_table_hint

	return p
}

func (s *Table_hintContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_hintContext) An_id_hint() IAn_id_hintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_hintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_hintContext)
}

func (s *Table_hintContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEQUALS, 0)
}

func (s *Table_hintContext) AllType_name_tag() []IType_name_tagContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IType_name_tagContext); ok {
			len++
		}
	}

	tst := make([]IType_name_tagContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IType_name_tagContext); ok {
			tst[i] = t.(IType_name_tagContext)
			i++
		}
	}

	return tst
}

func (s *Table_hintContext) Type_name_tag(i int) IType_name_tagContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_tagContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_tagContext)
}

func (s *Table_hintContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Table_hintContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Table_hintContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Table_hintContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Table_hintContext) Type_name_or_bind() IType_name_or_bindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_name_or_bindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_name_or_bindContext)
}

func (s *Table_hintContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSCHEMA, 0)
}

func (s *Table_hintContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOLUMNS, 0)
}

func (s *Table_hintContext) AllStruct_arg_positional() []IStruct_arg_positionalContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStruct_arg_positionalContext); ok {
			len++
		}
	}

	tst := make([]IStruct_arg_positionalContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStruct_arg_positionalContext); ok {
			tst[i] = t.(IStruct_arg_positionalContext)
			i++
		}
	}

	return tst
}

func (s *Table_hintContext) Struct_arg_positional(i int) IStruct_arg_positionalContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStruct_arg_positionalContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStruct_arg_positionalContext)
}

func (s *Table_hintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_hintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_hintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterTable_hint(s)
	}
}

func (s *Table_hintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitTable_hint(s)
	}
}

func (p *SQLv1Antlr4Parser) Table_hint() (localctx ITable_hintContext) {
	localctx = NewTable_hintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 636, SQLv1Antlr4ParserRULE_table_hint)
	var _la int

	var _alt int

	p.SetState(3895)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 414, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3850)
			p.An_id_hint()
		}
		p.SetState(3869)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserEQUALS {
			{
				p.SetState(3851)
				p.Match(SQLv1Antlr4ParserEQUALS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3867)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case SQLv1Antlr4ParserDOLLAR, SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALL, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserANY, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSTREAM, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWITHOUT, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserSTRING_VALUE, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
				{
					p.SetState(3852)
					p.Type_name_tag()
				}

			case SQLv1Antlr4ParserLPAREN:
				{
					p.SetState(3853)
					p.Match(SQLv1Antlr4ParserLPAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3854)
					p.Type_name_tag()
				}
				p.SetState(3859)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 405, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(3855)
							p.Match(SQLv1Antlr4ParserCOMMA)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}
						{
							p.SetState(3856)
							p.Type_name_tag()
						}

					}
					p.SetState(3861)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 405, p.GetParserRuleContext())
					if p.HasError() {
						goto errorExit
					}
				}
				p.SetState(3863)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == SQLv1Antlr4ParserCOMMA {
					{
						p.SetState(3862)
						p.Match(SQLv1Antlr4ParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(3865)
					p.Match(SQLv1Antlr4ParserRPAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3871)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLv1Antlr4ParserCOLUMNS || _la == SQLv1Antlr4ParserSCHEMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(3873)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserEQUALS {
			{
				p.SetState(3872)
				p.Match(SQLv1Antlr4ParserEQUALS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3875)
			p.Type_name_or_bind()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3876)
			p.Match(SQLv1Antlr4ParserSCHEMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3878)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserEQUALS {
			{
				p.SetState(3877)
				p.Match(SQLv1Antlr4ParserEQUALS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3880)
			p.Match(SQLv1Antlr4ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3889)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-32)) & ^0x3f) == 0 && ((int64(1)<<(_la-32))&-2147485695) != 0) || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&-9008298766368769) != 0) || ((int64((_la-160)) & ^0x3f) == 0 && ((int64(1)<<(_la-160))&-1) != 0) || ((int64((_la-224)) & ^0x3f) == 0 && ((int64(1)<<(_la-224))&-1048577) != 0) || ((int64((_la-288)) & ^0x3f) == 0 && ((int64(1)<<(_la-288))&137438953215) != 0) {
			{
				p.SetState(3881)
				p.Struct_arg_positional()
			}
			p.SetState(3886)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 411, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(3882)
						p.Match(SQLv1Antlr4ParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(3883)
						p.Struct_arg_positional()
					}

				}
				p.SetState(3888)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 411, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}

		}
		p.SetState(3892)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserCOMMA {
			{
				p.SetState(3891)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3894)
			p.Match(SQLv1Antlr4ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObject_refContext is an interface to support dynamic dispatch.
type IObject_refContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_or_at() IId_or_atContext
	Cluster_expr() ICluster_exprContext
	DOT() antlr.TerminalNode

	// IsObject_refContext differentiates from other interfaces.
	IsObject_refContext()
}

type Object_refContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObject_refContext() *Object_refContext {
	var p = new(Object_refContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_object_ref
	return p
}

func InitEmptyObject_refContext(p *Object_refContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_object_ref
}

func (*Object_refContext) IsObject_refContext() {}

func NewObject_refContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Object_refContext {
	var p = new(Object_refContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_object_ref

	return p
}

func (s *Object_refContext) GetParser() antlr.Parser { return s.parser }

func (s *Object_refContext) Id_or_at() IId_or_atContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_or_atContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_or_atContext)
}

func (s *Object_refContext) Cluster_expr() ICluster_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICluster_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICluster_exprContext)
}

func (s *Object_refContext) DOT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDOT, 0)
}

func (s *Object_refContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_refContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Object_refContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterObject_ref(s)
	}
}

func (s *Object_refContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitObject_ref(s)
	}
}

func (p *SQLv1Antlr4Parser) Object_ref() (localctx IObject_refContext) {
	localctx = NewObject_refContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 638, SQLv1Antlr4ParserRULE_object_ref)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(3900)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 415, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3897)
			p.Cluster_expr()
		}
		{
			p.SetState(3898)
			p.Match(SQLv1Antlr4ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3902)
		p.Id_or_at()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimple_table_ref_coreContext is an interface to support dynamic dispatch.
type ISimple_table_ref_coreContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Object_ref() IObject_refContext
	Bind_parameter() IBind_parameterContext
	COMMAT() antlr.TerminalNode

	// IsSimple_table_ref_coreContext differentiates from other interfaces.
	IsSimple_table_ref_coreContext()
}

type Simple_table_ref_coreContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_table_ref_coreContext() *Simple_table_ref_coreContext {
	var p = new(Simple_table_ref_coreContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_simple_table_ref_core
	return p
}

func InitEmptySimple_table_ref_coreContext(p *Simple_table_ref_coreContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_simple_table_ref_core
}

func (*Simple_table_ref_coreContext) IsSimple_table_ref_coreContext() {}

func NewSimple_table_ref_coreContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_table_ref_coreContext {
	var p = new(Simple_table_ref_coreContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_simple_table_ref_core

	return p
}

func (s *Simple_table_ref_coreContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_table_ref_coreContext) Object_ref() IObject_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObject_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObject_refContext)
}

func (s *Simple_table_ref_coreContext) Bind_parameter() IBind_parameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameterContext)
}

func (s *Simple_table_ref_coreContext) COMMAT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMAT, 0)
}

func (s *Simple_table_ref_coreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_table_ref_coreContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_table_ref_coreContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSimple_table_ref_core(s)
	}
}

func (s *Simple_table_ref_coreContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSimple_table_ref_core(s)
	}
}

func (p *SQLv1Antlr4Parser) Simple_table_ref_core() (localctx ISimple_table_ref_coreContext) {
	localctx = NewSimple_table_ref_coreContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 640, SQLv1Antlr4ParserRULE_simple_table_ref_core)
	var _la int

	p.SetState(3909)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 417, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3904)
			p.Object_ref()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3906)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserCOMMAT {
			{
				p.SetState(3905)
				p.Match(SQLv1Antlr4ParserCOMMAT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3908)
			p.Bind_parameter()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimple_table_refContext is an interface to support dynamic dispatch.
type ISimple_table_refContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Simple_table_ref_core() ISimple_table_ref_coreContext
	Table_hints() ITable_hintsContext

	// IsSimple_table_refContext differentiates from other interfaces.
	IsSimple_table_refContext()
}

type Simple_table_refContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_table_refContext() *Simple_table_refContext {
	var p = new(Simple_table_refContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_simple_table_ref
	return p
}

func InitEmptySimple_table_refContext(p *Simple_table_refContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_simple_table_ref
}

func (*Simple_table_refContext) IsSimple_table_refContext() {}

func NewSimple_table_refContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_table_refContext {
	var p = new(Simple_table_refContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_simple_table_ref

	return p
}

func (s *Simple_table_refContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_table_refContext) Simple_table_ref_core() ISimple_table_ref_coreContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_table_ref_coreContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_table_ref_coreContext)
}

func (s *Simple_table_refContext) Table_hints() ITable_hintsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_hintsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_hintsContext)
}

func (s *Simple_table_refContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_table_refContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_table_refContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSimple_table_ref(s)
	}
}

func (s *Simple_table_refContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSimple_table_ref(s)
	}
}

func (p *SQLv1Antlr4Parser) Simple_table_ref() (localctx ISimple_table_refContext) {
	localctx = NewSimple_table_refContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 642, SQLv1Antlr4ParserRULE_simple_table_ref)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3911)
		p.Simple_table_ref_core()
	}
	p.SetState(3913)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserWITH {
		{
			p.SetState(3912)
			p.Table_hints()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInto_simple_table_refContext is an interface to support dynamic dispatch.
type IInto_simple_table_refContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Simple_table_ref() ISimple_table_refContext
	ERASE() antlr.TerminalNode
	BY() antlr.TerminalNode
	Pure_column_list() IPure_column_listContext

	// IsInto_simple_table_refContext differentiates from other interfaces.
	IsInto_simple_table_refContext()
}

type Into_simple_table_refContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInto_simple_table_refContext() *Into_simple_table_refContext {
	var p = new(Into_simple_table_refContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_into_simple_table_ref
	return p
}

func InitEmptyInto_simple_table_refContext(p *Into_simple_table_refContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_into_simple_table_ref
}

func (*Into_simple_table_refContext) IsInto_simple_table_refContext() {}

func NewInto_simple_table_refContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Into_simple_table_refContext {
	var p = new(Into_simple_table_refContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_into_simple_table_ref

	return p
}

func (s *Into_simple_table_refContext) GetParser() antlr.Parser { return s.parser }

func (s *Into_simple_table_refContext) Simple_table_ref() ISimple_table_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_table_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_table_refContext)
}

func (s *Into_simple_table_refContext) ERASE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserERASE, 0)
}

func (s *Into_simple_table_refContext) BY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserBY, 0)
}

func (s *Into_simple_table_refContext) Pure_column_list() IPure_column_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPure_column_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPure_column_listContext)
}

func (s *Into_simple_table_refContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Into_simple_table_refContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Into_simple_table_refContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterInto_simple_table_ref(s)
	}
}

func (s *Into_simple_table_refContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitInto_simple_table_ref(s)
	}
}

func (p *SQLv1Antlr4Parser) Into_simple_table_ref() (localctx IInto_simple_table_refContext) {
	localctx = NewInto_simple_table_refContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 644, SQLv1Antlr4ParserRULE_into_simple_table_ref)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3915)
		p.Simple_table_ref()
	}
	p.SetState(3919)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserERASE {
		{
			p.SetState(3916)
			p.Match(SQLv1Antlr4ParserERASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3917)
			p.Match(SQLv1Antlr4ParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3918)
			p.Pure_column_list()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDelete_stmtContext is an interface to support dynamic dispatch.
type IDelete_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	Simple_table_ref() ISimple_table_refContext
	WHERE() antlr.TerminalNode
	Expr() IExprContext
	ON() antlr.TerminalNode
	Into_values_source() IInto_values_sourceContext
	Returning_columns_list() IReturning_columns_listContext

	// IsDelete_stmtContext differentiates from other interfaces.
	IsDelete_stmtContext()
}

type Delete_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelete_stmtContext() *Delete_stmtContext {
	var p = new(Delete_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_delete_stmt
	return p
}

func InitEmptyDelete_stmtContext(p *Delete_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_delete_stmt
}

func (*Delete_stmtContext) IsDelete_stmtContext() {}

func NewDelete_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delete_stmtContext {
	var p = new(Delete_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_delete_stmt

	return p
}

func (s *Delete_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Delete_stmtContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDELETE, 0)
}

func (s *Delete_stmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFROM, 0)
}

func (s *Delete_stmtContext) Simple_table_ref() ISimple_table_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_table_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_table_refContext)
}

func (s *Delete_stmtContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWHERE, 0)
}

func (s *Delete_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Delete_stmtContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserON, 0)
}

func (s *Delete_stmtContext) Into_values_source() IInto_values_sourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInto_values_sourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInto_values_sourceContext)
}

func (s *Delete_stmtContext) Returning_columns_list() IReturning_columns_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturning_columns_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturning_columns_listContext)
}

func (s *Delete_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delete_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delete_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterDelete_stmt(s)
	}
}

func (s *Delete_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitDelete_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Delete_stmt() (localctx IDelete_stmtContext) {
	localctx = NewDelete_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 646, SQLv1Antlr4ParserRULE_delete_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3921)
		p.Match(SQLv1Antlr4ParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3922)
		p.Match(SQLv1Antlr4ParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3923)
		p.Simple_table_ref()
	}
	p.SetState(3928)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserWHERE:
		{
			p.SetState(3924)
			p.Match(SQLv1Antlr4ParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3925)
			p.Expr()
		}

	case SQLv1Antlr4ParserON:
		{
			p.SetState(3926)
			p.Match(SQLv1Antlr4ParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3927)
			p.Into_values_source()
		}

	case SQLv1Antlr4ParserEOF, SQLv1Antlr4ParserSEMICOLON, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserRETURNING:

	default:
	}
	p.SetState(3931)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserRETURNING {
		{
			p.SetState(3930)
			p.Returning_columns_list()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdate_stmtContext is an interface to support dynamic dispatch.
type IUpdate_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UPDATE() antlr.TerminalNode
	Simple_table_ref() ISimple_table_refContext
	SET() antlr.TerminalNode
	Set_clause_choice() ISet_clause_choiceContext
	ON() antlr.TerminalNode
	Into_values_source() IInto_values_sourceContext
	Returning_columns_list() IReturning_columns_listContext
	WHERE() antlr.TerminalNode
	Expr() IExprContext

	// IsUpdate_stmtContext differentiates from other interfaces.
	IsUpdate_stmtContext()
}

type Update_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdate_stmtContext() *Update_stmtContext {
	var p = new(Update_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_update_stmt
	return p
}

func InitEmptyUpdate_stmtContext(p *Update_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_update_stmt
}

func (*Update_stmtContext) IsUpdate_stmtContext() {}

func NewUpdate_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Update_stmtContext {
	var p = new(Update_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_update_stmt

	return p
}

func (s *Update_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Update_stmtContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUPDATE, 0)
}

func (s *Update_stmtContext) Simple_table_ref() ISimple_table_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_table_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_table_refContext)
}

func (s *Update_stmtContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSET, 0)
}

func (s *Update_stmtContext) Set_clause_choice() ISet_clause_choiceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_clause_choiceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_clause_choiceContext)
}

func (s *Update_stmtContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserON, 0)
}

func (s *Update_stmtContext) Into_values_source() IInto_values_sourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInto_values_sourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInto_values_sourceContext)
}

func (s *Update_stmtContext) Returning_columns_list() IReturning_columns_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturning_columns_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturning_columns_listContext)
}

func (s *Update_stmtContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWHERE, 0)
}

func (s *Update_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Update_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Update_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Update_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterUpdate_stmt(s)
	}
}

func (s *Update_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitUpdate_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Update_stmt() (localctx IUpdate_stmtContext) {
	localctx = NewUpdate_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 648, SQLv1Antlr4ParserRULE_update_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3933)
		p.Match(SQLv1Antlr4ParserUPDATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3934)
		p.Simple_table_ref()
	}
	p.SetState(3943)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserSET:
		{
			p.SetState(3935)
			p.Match(SQLv1Antlr4ParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3936)
			p.Set_clause_choice()
		}
		p.SetState(3939)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLv1Antlr4ParserWHERE {
			{
				p.SetState(3937)
				p.Match(SQLv1Antlr4ParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3938)
				p.Expr()
			}

		}

	case SQLv1Antlr4ParserON:
		{
			p.SetState(3941)
			p.Match(SQLv1Antlr4ParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3942)
			p.Into_values_source()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(3946)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserRETURNING {
		{
			p.SetState(3945)
			p.Returning_columns_list()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_clause_choiceContext is an interface to support dynamic dispatch.
type ISet_clause_choiceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Set_clause_list() ISet_clause_listContext
	Multiple_column_assignment() IMultiple_column_assignmentContext

	// IsSet_clause_choiceContext differentiates from other interfaces.
	IsSet_clause_choiceContext()
}

type Set_clause_choiceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_clause_choiceContext() *Set_clause_choiceContext {
	var p = new(Set_clause_choiceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_set_clause_choice
	return p
}

func InitEmptySet_clause_choiceContext(p *Set_clause_choiceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_set_clause_choice
}

func (*Set_clause_choiceContext) IsSet_clause_choiceContext() {}

func NewSet_clause_choiceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_clause_choiceContext {
	var p = new(Set_clause_choiceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_set_clause_choice

	return p
}

func (s *Set_clause_choiceContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_clause_choiceContext) Set_clause_list() ISet_clause_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_clause_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_clause_listContext)
}

func (s *Set_clause_choiceContext) Multiple_column_assignment() IMultiple_column_assignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiple_column_assignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiple_column_assignmentContext)
}

func (s *Set_clause_choiceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_clause_choiceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_clause_choiceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSet_clause_choice(s)
	}
}

func (s *Set_clause_choiceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSet_clause_choice(s)
	}
}

func (p *SQLv1Antlr4Parser) Set_clause_choice() (localctx ISet_clause_choiceContext) {
	localctx = NewSet_clause_choiceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 650, SQLv1Antlr4ParserRULE_set_clause_choice)
	p.SetState(3950)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALL, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserANY, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSTREAM, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWITHOUT, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserSTRING_VALUE, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3948)
			p.Set_clause_list()
		}

	case SQLv1Antlr4ParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3949)
			p.Multiple_column_assignment()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_clause_listContext is an interface to support dynamic dispatch.
type ISet_clause_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSet_clause() []ISet_clauseContext
	Set_clause(i int) ISet_clauseContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSet_clause_listContext differentiates from other interfaces.
	IsSet_clause_listContext()
}

type Set_clause_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_clause_listContext() *Set_clause_listContext {
	var p = new(Set_clause_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_set_clause_list
	return p
}

func InitEmptySet_clause_listContext(p *Set_clause_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_set_clause_list
}

func (*Set_clause_listContext) IsSet_clause_listContext() {}

func NewSet_clause_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_clause_listContext {
	var p = new(Set_clause_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_set_clause_list

	return p
}

func (s *Set_clause_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_clause_listContext) AllSet_clause() []ISet_clauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISet_clauseContext); ok {
			len++
		}
	}

	tst := make([]ISet_clauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISet_clauseContext); ok {
			tst[i] = t.(ISet_clauseContext)
			i++
		}
	}

	return tst
}

func (s *Set_clause_listContext) Set_clause(i int) ISet_clauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_clauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_clauseContext)
}

func (s *Set_clause_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Set_clause_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Set_clause_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_clause_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_clause_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSet_clause_list(s)
	}
}

func (s *Set_clause_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSet_clause_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Set_clause_list() (localctx ISet_clause_listContext) {
	localctx = NewSet_clause_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 652, SQLv1Antlr4ParserRULE_set_clause_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3952)
		p.Set_clause()
	}
	p.SetState(3957)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(3953)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3954)
			p.Set_clause()
		}

		p.SetState(3959)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_clauseContext is an interface to support dynamic dispatch.
type ISet_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Set_target() ISet_targetContext
	EQUALS() antlr.TerminalNode
	Expr() IExprContext

	// IsSet_clauseContext differentiates from other interfaces.
	IsSet_clauseContext()
}

type Set_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_clauseContext() *Set_clauseContext {
	var p = new(Set_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_set_clause
	return p
}

func InitEmptySet_clauseContext(p *Set_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_set_clause
}

func (*Set_clauseContext) IsSet_clauseContext() {}

func NewSet_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_clauseContext {
	var p = new(Set_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_set_clause

	return p
}

func (s *Set_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_clauseContext) Set_target() ISet_targetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_targetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_targetContext)
}

func (s *Set_clauseContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEQUALS, 0)
}

func (s *Set_clauseContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Set_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSet_clause(s)
	}
}

func (s *Set_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSet_clause(s)
	}
}

func (p *SQLv1Antlr4Parser) Set_clause() (localctx ISet_clauseContext) {
	localctx = NewSet_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 654, SQLv1Antlr4ParserRULE_set_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3960)
		p.Set_target()
	}
	{
		p.SetState(3961)
		p.Match(SQLv1Antlr4ParserEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3962)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_targetContext is an interface to support dynamic dispatch.
type ISet_targetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column_name() IColumn_nameContext

	// IsSet_targetContext differentiates from other interfaces.
	IsSet_targetContext()
}

type Set_targetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_targetContext() *Set_targetContext {
	var p = new(Set_targetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_set_target
	return p
}

func InitEmptySet_targetContext(p *Set_targetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_set_target
}

func (*Set_targetContext) IsSet_targetContext() {}

func NewSet_targetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_targetContext {
	var p = new(Set_targetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_set_target

	return p
}

func (s *Set_targetContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_targetContext) Column_name() IColumn_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Set_targetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_targetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_targetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSet_target(s)
	}
}

func (s *Set_targetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSet_target(s)
	}
}

func (p *SQLv1Antlr4Parser) Set_target() (localctx ISet_targetContext) {
	localctx = NewSet_targetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 656, SQLv1Antlr4ParserRULE_set_target)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3964)
		p.Column_name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiple_column_assignmentContext is an interface to support dynamic dispatch.
type IMultiple_column_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Set_target_list() ISet_target_listContext
	EQUALS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Simple_values_source() ISimple_values_sourceContext
	RPAREN() antlr.TerminalNode

	// IsMultiple_column_assignmentContext differentiates from other interfaces.
	IsMultiple_column_assignmentContext()
}

type Multiple_column_assignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiple_column_assignmentContext() *Multiple_column_assignmentContext {
	var p = new(Multiple_column_assignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_multiple_column_assignment
	return p
}

func InitEmptyMultiple_column_assignmentContext(p *Multiple_column_assignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_multiple_column_assignment
}

func (*Multiple_column_assignmentContext) IsMultiple_column_assignmentContext() {}

func NewMultiple_column_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multiple_column_assignmentContext {
	var p = new(Multiple_column_assignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_multiple_column_assignment

	return p
}

func (s *Multiple_column_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Multiple_column_assignmentContext) Set_target_list() ISet_target_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_target_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_target_listContext)
}

func (s *Multiple_column_assignmentContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEQUALS, 0)
}

func (s *Multiple_column_assignmentContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Multiple_column_assignmentContext) Simple_values_source() ISimple_values_sourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_values_sourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_values_sourceContext)
}

func (s *Multiple_column_assignmentContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Multiple_column_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multiple_column_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multiple_column_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterMultiple_column_assignment(s)
	}
}

func (s *Multiple_column_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitMultiple_column_assignment(s)
	}
}

func (p *SQLv1Antlr4Parser) Multiple_column_assignment() (localctx IMultiple_column_assignmentContext) {
	localctx = NewMultiple_column_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 658, SQLv1Antlr4ParserRULE_multiple_column_assignment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3966)
		p.Set_target_list()
	}
	{
		p.SetState(3967)
		p.Match(SQLv1Antlr4ParserEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3968)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3969)
		p.Simple_values_source()
	}
	{
		p.SetState(3970)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_target_listContext is an interface to support dynamic dispatch.
type ISet_target_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllSet_target() []ISet_targetContext
	Set_target(i int) ISet_targetContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSet_target_listContext differentiates from other interfaces.
	IsSet_target_listContext()
}

type Set_target_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_target_listContext() *Set_target_listContext {
	var p = new(Set_target_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_set_target_list
	return p
}

func InitEmptySet_target_listContext(p *Set_target_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_set_target_list
}

func (*Set_target_listContext) IsSet_target_listContext() {}

func NewSet_target_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_target_listContext {
	var p = new(Set_target_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_set_target_list

	return p
}

func (s *Set_target_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_target_listContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Set_target_listContext) AllSet_target() []ISet_targetContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISet_targetContext); ok {
			len++
		}
	}

	tst := make([]ISet_targetContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISet_targetContext); ok {
			tst[i] = t.(ISet_targetContext)
			i++
		}
	}

	return tst
}

func (s *Set_target_listContext) Set_target(i int) ISet_targetContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_targetContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_targetContext)
}

func (s *Set_target_listContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Set_target_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Set_target_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Set_target_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_target_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_target_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSet_target_list(s)
	}
}

func (s *Set_target_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSet_target_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Set_target_list() (localctx ISet_target_listContext) {
	localctx = NewSet_target_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 660, SQLv1Antlr4ParserRULE_set_target_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3972)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3973)
		p.Set_target()
	}
	p.SetState(3978)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(3974)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3975)
			p.Set_target()
		}

		p.SetState(3980)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3981)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_topic_stmtContext is an interface to support dynamic dispatch.
type ICreate_topic_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	TOPIC() antlr.TerminalNode
	Topic_ref() ITopic_refContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	Create_topic_entries() ICreate_topic_entriesContext
	With_topic_settings() IWith_topic_settingsContext

	// IsCreate_topic_stmtContext differentiates from other interfaces.
	IsCreate_topic_stmtContext()
}

type Create_topic_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_topic_stmtContext() *Create_topic_stmtContext {
	var p = new(Create_topic_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_topic_stmt
	return p
}

func InitEmptyCreate_topic_stmtContext(p *Create_topic_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_topic_stmt
}

func (*Create_topic_stmtContext) IsCreate_topic_stmtContext() {}

func NewCreate_topic_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_topic_stmtContext {
	var p = new(Create_topic_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_topic_stmt

	return p
}

func (s *Create_topic_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_topic_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCREATE, 0)
}

func (s *Create_topic_stmtContext) TOPIC() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTOPIC, 0)
}

func (s *Create_topic_stmtContext) Topic_ref() ITopic_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_refContext)
}

func (s *Create_topic_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIF, 0)
}

func (s *Create_topic_stmtContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNOT, 0)
}

func (s *Create_topic_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXISTS, 0)
}

func (s *Create_topic_stmtContext) Create_topic_entries() ICreate_topic_entriesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_topic_entriesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_topic_entriesContext)
}

func (s *Create_topic_stmtContext) With_topic_settings() IWith_topic_settingsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_topic_settingsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_topic_settingsContext)
}

func (s *Create_topic_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_topic_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_topic_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterCreate_topic_stmt(s)
	}
}

func (s *Create_topic_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitCreate_topic_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Create_topic_stmt() (localctx ICreate_topic_stmtContext) {
	localctx = NewCreate_topic_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 662, SQLv1Antlr4ParserRULE_create_topic_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3983)
		p.Match(SQLv1Antlr4ParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3984)
		p.Match(SQLv1Antlr4ParserTOPIC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3988)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 428, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3985)
			p.Match(SQLv1Antlr4ParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3986)
			p.Match(SQLv1Antlr4ParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3987)
			p.Match(SQLv1Antlr4ParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3990)
		p.Topic_ref()
	}
	p.SetState(3992)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserLPAREN {
		{
			p.SetState(3991)
			p.Create_topic_entries()
		}

	}
	p.SetState(3995)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserWITH {
		{
			p.SetState(3994)
			p.With_topic_settings()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_topic_entriesContext is an interface to support dynamic dispatch.
type ICreate_topic_entriesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllCreate_topic_entry() []ICreate_topic_entryContext
	Create_topic_entry(i int) ICreate_topic_entryContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCreate_topic_entriesContext differentiates from other interfaces.
	IsCreate_topic_entriesContext()
}

type Create_topic_entriesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_topic_entriesContext() *Create_topic_entriesContext {
	var p = new(Create_topic_entriesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_topic_entries
	return p
}

func InitEmptyCreate_topic_entriesContext(p *Create_topic_entriesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_topic_entries
}

func (*Create_topic_entriesContext) IsCreate_topic_entriesContext() {}

func NewCreate_topic_entriesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_topic_entriesContext {
	var p = new(Create_topic_entriesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_topic_entries

	return p
}

func (s *Create_topic_entriesContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_topic_entriesContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Create_topic_entriesContext) AllCreate_topic_entry() []ICreate_topic_entryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_topic_entryContext); ok {
			len++
		}
	}

	tst := make([]ICreate_topic_entryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_topic_entryContext); ok {
			tst[i] = t.(ICreate_topic_entryContext)
			i++
		}
	}

	return tst
}

func (s *Create_topic_entriesContext) Create_topic_entry(i int) ICreate_topic_entryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_topic_entryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_topic_entryContext)
}

func (s *Create_topic_entriesContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Create_topic_entriesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Create_topic_entriesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Create_topic_entriesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_topic_entriesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_topic_entriesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterCreate_topic_entries(s)
	}
}

func (s *Create_topic_entriesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitCreate_topic_entries(s)
	}
}

func (p *SQLv1Antlr4Parser) Create_topic_entries() (localctx ICreate_topic_entriesContext) {
	localctx = NewCreate_topic_entriesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 664, SQLv1Antlr4ParserRULE_create_topic_entries)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3997)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3998)
		p.Create_topic_entry()
	}
	p.SetState(4003)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(3999)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4000)
			p.Create_topic_entry()
		}

		p.SetState(4005)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4006)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_topic_entryContext is an interface to support dynamic dispatch.
type ICreate_topic_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Topic_create_consumer_entry() ITopic_create_consumer_entryContext

	// IsCreate_topic_entryContext differentiates from other interfaces.
	IsCreate_topic_entryContext()
}

type Create_topic_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_topic_entryContext() *Create_topic_entryContext {
	var p = new(Create_topic_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_topic_entry
	return p
}

func InitEmptyCreate_topic_entryContext(p *Create_topic_entryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_topic_entry
}

func (*Create_topic_entryContext) IsCreate_topic_entryContext() {}

func NewCreate_topic_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_topic_entryContext {
	var p = new(Create_topic_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_create_topic_entry

	return p
}

func (s *Create_topic_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_topic_entryContext) Topic_create_consumer_entry() ITopic_create_consumer_entryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_create_consumer_entryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_create_consumer_entryContext)
}

func (s *Create_topic_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_topic_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_topic_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterCreate_topic_entry(s)
	}
}

func (s *Create_topic_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitCreate_topic_entry(s)
	}
}

func (p *SQLv1Antlr4Parser) Create_topic_entry() (localctx ICreate_topic_entryContext) {
	localctx = NewCreate_topic_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 666, SQLv1Antlr4ParserRULE_create_topic_entry)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4008)
		p.Topic_create_consumer_entry()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWith_topic_settingsContext is an interface to support dynamic dispatch.
type IWith_topic_settingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Topic_settings() ITopic_settingsContext
	RPAREN() antlr.TerminalNode

	// IsWith_topic_settingsContext differentiates from other interfaces.
	IsWith_topic_settingsContext()
}

type With_topic_settingsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_topic_settingsContext() *With_topic_settingsContext {
	var p = new(With_topic_settingsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_with_topic_settings
	return p
}

func InitEmptyWith_topic_settingsContext(p *With_topic_settingsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_with_topic_settings
}

func (*With_topic_settingsContext) IsWith_topic_settingsContext() {}

func NewWith_topic_settingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_topic_settingsContext {
	var p = new(With_topic_settingsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_with_topic_settings

	return p
}

func (s *With_topic_settingsContext) GetParser() antlr.Parser { return s.parser }

func (s *With_topic_settingsContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWITH, 0)
}

func (s *With_topic_settingsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *With_topic_settingsContext) Topic_settings() ITopic_settingsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_settingsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_settingsContext)
}

func (s *With_topic_settingsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *With_topic_settingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_topic_settingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *With_topic_settingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterWith_topic_settings(s)
	}
}

func (s *With_topic_settingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitWith_topic_settings(s)
	}
}

func (p *SQLv1Antlr4Parser) With_topic_settings() (localctx IWith_topic_settingsContext) {
	localctx = NewWith_topic_settingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 668, SQLv1Antlr4ParserRULE_with_topic_settings)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4010)
		p.Match(SQLv1Antlr4ParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4011)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4012)
		p.Topic_settings()
	}
	{
		p.SetState(4013)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_topic_stmtContext is an interface to support dynamic dispatch.
type IAlter_topic_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	TOPIC() antlr.TerminalNode
	Topic_ref() ITopic_refContext
	AllAlter_topic_action() []IAlter_topic_actionContext
	Alter_topic_action(i int) IAlter_topic_actionContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlter_topic_stmtContext differentiates from other interfaces.
	IsAlter_topic_stmtContext()
}

type Alter_topic_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_topic_stmtContext() *Alter_topic_stmtContext {
	var p = new(Alter_topic_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_topic_stmt
	return p
}

func InitEmptyAlter_topic_stmtContext(p *Alter_topic_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_topic_stmt
}

func (*Alter_topic_stmtContext) IsAlter_topic_stmtContext() {}

func NewAlter_topic_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_topic_stmtContext {
	var p = new(Alter_topic_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_topic_stmt

	return p
}

func (s *Alter_topic_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_topic_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserALTER, 0)
}

func (s *Alter_topic_stmtContext) TOPIC() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTOPIC, 0)
}

func (s *Alter_topic_stmtContext) Topic_ref() ITopic_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_refContext)
}

func (s *Alter_topic_stmtContext) AllAlter_topic_action() []IAlter_topic_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlter_topic_actionContext); ok {
			len++
		}
	}

	tst := make([]IAlter_topic_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlter_topic_actionContext); ok {
			tst[i] = t.(IAlter_topic_actionContext)
			i++
		}
	}

	return tst
}

func (s *Alter_topic_stmtContext) Alter_topic_action(i int) IAlter_topic_actionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_topic_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_topic_actionContext)
}

func (s *Alter_topic_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIF, 0)
}

func (s *Alter_topic_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXISTS, 0)
}

func (s *Alter_topic_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Alter_topic_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Alter_topic_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_topic_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_topic_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_topic_stmt(s)
	}
}

func (s *Alter_topic_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_topic_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_topic_stmt() (localctx IAlter_topic_stmtContext) {
	localctx = NewAlter_topic_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 670, SQLv1Antlr4ParserRULE_alter_topic_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4015)
		p.Match(SQLv1Antlr4ParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4016)
		p.Match(SQLv1Antlr4ParserTOPIC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4019)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 432, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4017)
			p.Match(SQLv1Antlr4ParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4018)
			p.Match(SQLv1Antlr4ParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(4021)
		p.Topic_ref()
	}
	{
		p.SetState(4022)
		p.Alter_topic_action()
	}
	p.SetState(4027)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(4023)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4024)
			p.Alter_topic_action()
		}

		p.SetState(4029)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_topic_actionContext is an interface to support dynamic dispatch.
type IAlter_topic_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Alter_topic_add_consumer() IAlter_topic_add_consumerContext
	Alter_topic_alter_consumer() IAlter_topic_alter_consumerContext
	Alter_topic_drop_consumer() IAlter_topic_drop_consumerContext
	Alter_topic_set_settings() IAlter_topic_set_settingsContext
	Alter_topic_reset_settings() IAlter_topic_reset_settingsContext

	// IsAlter_topic_actionContext differentiates from other interfaces.
	IsAlter_topic_actionContext()
}

type Alter_topic_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_topic_actionContext() *Alter_topic_actionContext {
	var p = new(Alter_topic_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_topic_action
	return p
}

func InitEmptyAlter_topic_actionContext(p *Alter_topic_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_topic_action
}

func (*Alter_topic_actionContext) IsAlter_topic_actionContext() {}

func NewAlter_topic_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_topic_actionContext {
	var p = new(Alter_topic_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_topic_action

	return p
}

func (s *Alter_topic_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_topic_actionContext) Alter_topic_add_consumer() IAlter_topic_add_consumerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_topic_add_consumerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_topic_add_consumerContext)
}

func (s *Alter_topic_actionContext) Alter_topic_alter_consumer() IAlter_topic_alter_consumerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_topic_alter_consumerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_topic_alter_consumerContext)
}

func (s *Alter_topic_actionContext) Alter_topic_drop_consumer() IAlter_topic_drop_consumerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_topic_drop_consumerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_topic_drop_consumerContext)
}

func (s *Alter_topic_actionContext) Alter_topic_set_settings() IAlter_topic_set_settingsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_topic_set_settingsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_topic_set_settingsContext)
}

func (s *Alter_topic_actionContext) Alter_topic_reset_settings() IAlter_topic_reset_settingsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_topic_reset_settingsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_topic_reset_settingsContext)
}

func (s *Alter_topic_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_topic_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_topic_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_topic_action(s)
	}
}

func (s *Alter_topic_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_topic_action(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_topic_action() (localctx IAlter_topic_actionContext) {
	localctx = NewAlter_topic_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 672, SQLv1Antlr4ParserRULE_alter_topic_action)
	p.SetState(4035)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserADD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4030)
			p.Alter_topic_add_consumer()
		}

	case SQLv1Antlr4ParserALTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4031)
			p.Alter_topic_alter_consumer()
		}

	case SQLv1Antlr4ParserDROP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4032)
			p.Alter_topic_drop_consumer()
		}

	case SQLv1Antlr4ParserSET:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4033)
			p.Alter_topic_set_settings()
		}

	case SQLv1Antlr4ParserRESET:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4034)
			p.Alter_topic_reset_settings()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_topic_add_consumerContext is an interface to support dynamic dispatch.
type IAlter_topic_add_consumerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	Topic_create_consumer_entry() ITopic_create_consumer_entryContext

	// IsAlter_topic_add_consumerContext differentiates from other interfaces.
	IsAlter_topic_add_consumerContext()
}

type Alter_topic_add_consumerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_topic_add_consumerContext() *Alter_topic_add_consumerContext {
	var p = new(Alter_topic_add_consumerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_topic_add_consumer
	return p
}

func InitEmptyAlter_topic_add_consumerContext(p *Alter_topic_add_consumerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_topic_add_consumer
}

func (*Alter_topic_add_consumerContext) IsAlter_topic_add_consumerContext() {}

func NewAlter_topic_add_consumerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_topic_add_consumerContext {
	var p = new(Alter_topic_add_consumerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_topic_add_consumer

	return p
}

func (s *Alter_topic_add_consumerContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_topic_add_consumerContext) ADD() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserADD, 0)
}

func (s *Alter_topic_add_consumerContext) Topic_create_consumer_entry() ITopic_create_consumer_entryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_create_consumer_entryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_create_consumer_entryContext)
}

func (s *Alter_topic_add_consumerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_topic_add_consumerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_topic_add_consumerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_topic_add_consumer(s)
	}
}

func (s *Alter_topic_add_consumerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_topic_add_consumer(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_topic_add_consumer() (localctx IAlter_topic_add_consumerContext) {
	localctx = NewAlter_topic_add_consumerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 674, SQLv1Antlr4ParserRULE_alter_topic_add_consumer)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4037)
		p.Match(SQLv1Antlr4ParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4038)
		p.Topic_create_consumer_entry()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITopic_create_consumer_entryContext is an interface to support dynamic dispatch.
type ITopic_create_consumer_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONSUMER() antlr.TerminalNode
	An_id() IAn_idContext
	Topic_consumer_with_settings() ITopic_consumer_with_settingsContext

	// IsTopic_create_consumer_entryContext differentiates from other interfaces.
	IsTopic_create_consumer_entryContext()
}

type Topic_create_consumer_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopic_create_consumer_entryContext() *Topic_create_consumer_entryContext {
	var p = new(Topic_create_consumer_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_create_consumer_entry
	return p
}

func InitEmptyTopic_create_consumer_entryContext(p *Topic_create_consumer_entryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_create_consumer_entry
}

func (*Topic_create_consumer_entryContext) IsTopic_create_consumer_entryContext() {}

func NewTopic_create_consumer_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Topic_create_consumer_entryContext {
	var p = new(Topic_create_consumer_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_create_consumer_entry

	return p
}

func (s *Topic_create_consumer_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Topic_create_consumer_entryContext) CONSUMER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCONSUMER, 0)
}

func (s *Topic_create_consumer_entryContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Topic_create_consumer_entryContext) Topic_consumer_with_settings() ITopic_consumer_with_settingsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_consumer_with_settingsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_consumer_with_settingsContext)
}

func (s *Topic_create_consumer_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Topic_create_consumer_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Topic_create_consumer_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterTopic_create_consumer_entry(s)
	}
}

func (s *Topic_create_consumer_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitTopic_create_consumer_entry(s)
	}
}

func (p *SQLv1Antlr4Parser) Topic_create_consumer_entry() (localctx ITopic_create_consumer_entryContext) {
	localctx = NewTopic_create_consumer_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 676, SQLv1Antlr4ParserRULE_topic_create_consumer_entry)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4040)
		p.Match(SQLv1Antlr4ParserCONSUMER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4041)
		p.An_id()
	}
	p.SetState(4043)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserWITH {
		{
			p.SetState(4042)
			p.Topic_consumer_with_settings()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_topic_alter_consumerContext is an interface to support dynamic dispatch.
type IAlter_topic_alter_consumerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	CONSUMER() antlr.TerminalNode
	Topic_consumer_ref() ITopic_consumer_refContext
	Alter_topic_alter_consumer_entry() IAlter_topic_alter_consumer_entryContext

	// IsAlter_topic_alter_consumerContext differentiates from other interfaces.
	IsAlter_topic_alter_consumerContext()
}

type Alter_topic_alter_consumerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_topic_alter_consumerContext() *Alter_topic_alter_consumerContext {
	var p = new(Alter_topic_alter_consumerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_topic_alter_consumer
	return p
}

func InitEmptyAlter_topic_alter_consumerContext(p *Alter_topic_alter_consumerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_topic_alter_consumer
}

func (*Alter_topic_alter_consumerContext) IsAlter_topic_alter_consumerContext() {}

func NewAlter_topic_alter_consumerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_topic_alter_consumerContext {
	var p = new(Alter_topic_alter_consumerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_topic_alter_consumer

	return p
}

func (s *Alter_topic_alter_consumerContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_topic_alter_consumerContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserALTER, 0)
}

func (s *Alter_topic_alter_consumerContext) CONSUMER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCONSUMER, 0)
}

func (s *Alter_topic_alter_consumerContext) Topic_consumer_ref() ITopic_consumer_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_consumer_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_consumer_refContext)
}

func (s *Alter_topic_alter_consumerContext) Alter_topic_alter_consumer_entry() IAlter_topic_alter_consumer_entryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_topic_alter_consumer_entryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_topic_alter_consumer_entryContext)
}

func (s *Alter_topic_alter_consumerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_topic_alter_consumerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_topic_alter_consumerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_topic_alter_consumer(s)
	}
}

func (s *Alter_topic_alter_consumerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_topic_alter_consumer(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_topic_alter_consumer() (localctx IAlter_topic_alter_consumerContext) {
	localctx = NewAlter_topic_alter_consumerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 678, SQLv1Antlr4ParserRULE_alter_topic_alter_consumer)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4045)
		p.Match(SQLv1Antlr4ParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4046)
		p.Match(SQLv1Antlr4ParserCONSUMER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4047)
		p.Topic_consumer_ref()
	}
	{
		p.SetState(4048)
		p.Alter_topic_alter_consumer_entry()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_topic_alter_consumer_entryContext is an interface to support dynamic dispatch.
type IAlter_topic_alter_consumer_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Topic_alter_consumer_set() ITopic_alter_consumer_setContext
	Topic_alter_consumer_reset() ITopic_alter_consumer_resetContext

	// IsAlter_topic_alter_consumer_entryContext differentiates from other interfaces.
	IsAlter_topic_alter_consumer_entryContext()
}

type Alter_topic_alter_consumer_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_topic_alter_consumer_entryContext() *Alter_topic_alter_consumer_entryContext {
	var p = new(Alter_topic_alter_consumer_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_topic_alter_consumer_entry
	return p
}

func InitEmptyAlter_topic_alter_consumer_entryContext(p *Alter_topic_alter_consumer_entryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_topic_alter_consumer_entry
}

func (*Alter_topic_alter_consumer_entryContext) IsAlter_topic_alter_consumer_entryContext() {}

func NewAlter_topic_alter_consumer_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_topic_alter_consumer_entryContext {
	var p = new(Alter_topic_alter_consumer_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_topic_alter_consumer_entry

	return p
}

func (s *Alter_topic_alter_consumer_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_topic_alter_consumer_entryContext) Topic_alter_consumer_set() ITopic_alter_consumer_setContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_alter_consumer_setContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_alter_consumer_setContext)
}

func (s *Alter_topic_alter_consumer_entryContext) Topic_alter_consumer_reset() ITopic_alter_consumer_resetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_alter_consumer_resetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_alter_consumer_resetContext)
}

func (s *Alter_topic_alter_consumer_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_topic_alter_consumer_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_topic_alter_consumer_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_topic_alter_consumer_entry(s)
	}
}

func (s *Alter_topic_alter_consumer_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_topic_alter_consumer_entry(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_topic_alter_consumer_entry() (localctx IAlter_topic_alter_consumer_entryContext) {
	localctx = NewAlter_topic_alter_consumer_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 680, SQLv1Antlr4ParserRULE_alter_topic_alter_consumer_entry)
	p.SetState(4052)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserSET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4050)
			p.Topic_alter_consumer_set()
		}

	case SQLv1Antlr4ParserRESET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4051)
			p.Topic_alter_consumer_reset()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_topic_drop_consumerContext is an interface to support dynamic dispatch.
type IAlter_topic_drop_consumerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	CONSUMER() antlr.TerminalNode
	Topic_consumer_ref() ITopic_consumer_refContext

	// IsAlter_topic_drop_consumerContext differentiates from other interfaces.
	IsAlter_topic_drop_consumerContext()
}

type Alter_topic_drop_consumerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_topic_drop_consumerContext() *Alter_topic_drop_consumerContext {
	var p = new(Alter_topic_drop_consumerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_topic_drop_consumer
	return p
}

func InitEmptyAlter_topic_drop_consumerContext(p *Alter_topic_drop_consumerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_topic_drop_consumer
}

func (*Alter_topic_drop_consumerContext) IsAlter_topic_drop_consumerContext() {}

func NewAlter_topic_drop_consumerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_topic_drop_consumerContext {
	var p = new(Alter_topic_drop_consumerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_topic_drop_consumer

	return p
}

func (s *Alter_topic_drop_consumerContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_topic_drop_consumerContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDROP, 0)
}

func (s *Alter_topic_drop_consumerContext) CONSUMER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCONSUMER, 0)
}

func (s *Alter_topic_drop_consumerContext) Topic_consumer_ref() ITopic_consumer_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_consumer_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_consumer_refContext)
}

func (s *Alter_topic_drop_consumerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_topic_drop_consumerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_topic_drop_consumerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_topic_drop_consumer(s)
	}
}

func (s *Alter_topic_drop_consumerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_topic_drop_consumer(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_topic_drop_consumer() (localctx IAlter_topic_drop_consumerContext) {
	localctx = NewAlter_topic_drop_consumerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 682, SQLv1Antlr4ParserRULE_alter_topic_drop_consumer)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4054)
		p.Match(SQLv1Antlr4ParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4055)
		p.Match(SQLv1Antlr4ParserCONSUMER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4056)
		p.Topic_consumer_ref()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITopic_alter_consumer_setContext is an interface to support dynamic dispatch.
type ITopic_alter_consumer_setContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Topic_consumer_settings() ITopic_consumer_settingsContext
	RPAREN() antlr.TerminalNode

	// IsTopic_alter_consumer_setContext differentiates from other interfaces.
	IsTopic_alter_consumer_setContext()
}

type Topic_alter_consumer_setContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopic_alter_consumer_setContext() *Topic_alter_consumer_setContext {
	var p = new(Topic_alter_consumer_setContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_alter_consumer_set
	return p
}

func InitEmptyTopic_alter_consumer_setContext(p *Topic_alter_consumer_setContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_alter_consumer_set
}

func (*Topic_alter_consumer_setContext) IsTopic_alter_consumer_setContext() {}

func NewTopic_alter_consumer_setContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Topic_alter_consumer_setContext {
	var p = new(Topic_alter_consumer_setContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_alter_consumer_set

	return p
}

func (s *Topic_alter_consumer_setContext) GetParser() antlr.Parser { return s.parser }

func (s *Topic_alter_consumer_setContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSET, 0)
}

func (s *Topic_alter_consumer_setContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Topic_alter_consumer_setContext) Topic_consumer_settings() ITopic_consumer_settingsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_consumer_settingsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_consumer_settingsContext)
}

func (s *Topic_alter_consumer_setContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Topic_alter_consumer_setContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Topic_alter_consumer_setContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Topic_alter_consumer_setContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterTopic_alter_consumer_set(s)
	}
}

func (s *Topic_alter_consumer_setContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitTopic_alter_consumer_set(s)
	}
}

func (p *SQLv1Antlr4Parser) Topic_alter_consumer_set() (localctx ITopic_alter_consumer_setContext) {
	localctx = NewTopic_alter_consumer_setContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 684, SQLv1Antlr4ParserRULE_topic_alter_consumer_set)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4058)
		p.Match(SQLv1Antlr4ParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4059)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4060)
		p.Topic_consumer_settings()
	}
	{
		p.SetState(4061)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITopic_alter_consumer_resetContext is an interface to support dynamic dispatch.
type ITopic_alter_consumer_resetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESET() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllAn_id() []IAn_idContext
	An_id(i int) IAn_idContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTopic_alter_consumer_resetContext differentiates from other interfaces.
	IsTopic_alter_consumer_resetContext()
}

type Topic_alter_consumer_resetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopic_alter_consumer_resetContext() *Topic_alter_consumer_resetContext {
	var p = new(Topic_alter_consumer_resetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_alter_consumer_reset
	return p
}

func InitEmptyTopic_alter_consumer_resetContext(p *Topic_alter_consumer_resetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_alter_consumer_reset
}

func (*Topic_alter_consumer_resetContext) IsTopic_alter_consumer_resetContext() {}

func NewTopic_alter_consumer_resetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Topic_alter_consumer_resetContext {
	var p = new(Topic_alter_consumer_resetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_alter_consumer_reset

	return p
}

func (s *Topic_alter_consumer_resetContext) GetParser() antlr.Parser { return s.parser }

func (s *Topic_alter_consumer_resetContext) RESET() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRESET, 0)
}

func (s *Topic_alter_consumer_resetContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Topic_alter_consumer_resetContext) AllAn_id() []IAn_idContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_idContext); ok {
			len++
		}
	}

	tst := make([]IAn_idContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_idContext); ok {
			tst[i] = t.(IAn_idContext)
			i++
		}
	}

	return tst
}

func (s *Topic_alter_consumer_resetContext) An_id(i int) IAn_idContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Topic_alter_consumer_resetContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Topic_alter_consumer_resetContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Topic_alter_consumer_resetContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Topic_alter_consumer_resetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Topic_alter_consumer_resetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Topic_alter_consumer_resetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterTopic_alter_consumer_reset(s)
	}
}

func (s *Topic_alter_consumer_resetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitTopic_alter_consumer_reset(s)
	}
}

func (p *SQLv1Antlr4Parser) Topic_alter_consumer_reset() (localctx ITopic_alter_consumer_resetContext) {
	localctx = NewTopic_alter_consumer_resetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 686, SQLv1Antlr4ParserRULE_topic_alter_consumer_reset)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4063)
		p.Match(SQLv1Antlr4ParserRESET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4064)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4065)
		p.An_id()
	}
	p.SetState(4070)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(4066)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4067)
			p.An_id()
		}

		p.SetState(4072)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4073)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_topic_set_settingsContext is an interface to support dynamic dispatch.
type IAlter_topic_set_settingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Topic_settings() ITopic_settingsContext
	RPAREN() antlr.TerminalNode

	// IsAlter_topic_set_settingsContext differentiates from other interfaces.
	IsAlter_topic_set_settingsContext()
}

type Alter_topic_set_settingsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_topic_set_settingsContext() *Alter_topic_set_settingsContext {
	var p = new(Alter_topic_set_settingsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_topic_set_settings
	return p
}

func InitEmptyAlter_topic_set_settingsContext(p *Alter_topic_set_settingsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_topic_set_settings
}

func (*Alter_topic_set_settingsContext) IsAlter_topic_set_settingsContext() {}

func NewAlter_topic_set_settingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_topic_set_settingsContext {
	var p = new(Alter_topic_set_settingsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_topic_set_settings

	return p
}

func (s *Alter_topic_set_settingsContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_topic_set_settingsContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSET, 0)
}

func (s *Alter_topic_set_settingsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Alter_topic_set_settingsContext) Topic_settings() ITopic_settingsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_settingsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_settingsContext)
}

func (s *Alter_topic_set_settingsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Alter_topic_set_settingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_topic_set_settingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_topic_set_settingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_topic_set_settings(s)
	}
}

func (s *Alter_topic_set_settingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_topic_set_settings(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_topic_set_settings() (localctx IAlter_topic_set_settingsContext) {
	localctx = NewAlter_topic_set_settingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 688, SQLv1Antlr4ParserRULE_alter_topic_set_settings)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4075)
		p.Match(SQLv1Antlr4ParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4076)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4077)
		p.Topic_settings()
	}
	{
		p.SetState(4078)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_topic_reset_settingsContext is an interface to support dynamic dispatch.
type IAlter_topic_reset_settingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESET() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	An_id() IAn_idContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllAn_id_pure() []IAn_id_pureContext
	An_id_pure(i int) IAn_id_pureContext

	// IsAlter_topic_reset_settingsContext differentiates from other interfaces.
	IsAlter_topic_reset_settingsContext()
}

type Alter_topic_reset_settingsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_topic_reset_settingsContext() *Alter_topic_reset_settingsContext {
	var p = new(Alter_topic_reset_settingsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_topic_reset_settings
	return p
}

func InitEmptyAlter_topic_reset_settingsContext(p *Alter_topic_reset_settingsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_topic_reset_settings
}

func (*Alter_topic_reset_settingsContext) IsAlter_topic_reset_settingsContext() {}

func NewAlter_topic_reset_settingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_topic_reset_settingsContext {
	var p = new(Alter_topic_reset_settingsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_alter_topic_reset_settings

	return p
}

func (s *Alter_topic_reset_settingsContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_topic_reset_settingsContext) RESET() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRESET, 0)
}

func (s *Alter_topic_reset_settingsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Alter_topic_reset_settingsContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Alter_topic_reset_settingsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Alter_topic_reset_settingsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Alter_topic_reset_settingsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Alter_topic_reset_settingsContext) AllAn_id_pure() []IAn_id_pureContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAn_id_pureContext); ok {
			len++
		}
	}

	tst := make([]IAn_id_pureContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAn_id_pureContext); ok {
			tst[i] = t.(IAn_id_pureContext)
			i++
		}
	}

	return tst
}

func (s *Alter_topic_reset_settingsContext) An_id_pure(i int) IAn_id_pureContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_pureContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_pureContext)
}

func (s *Alter_topic_reset_settingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_topic_reset_settingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_topic_reset_settingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAlter_topic_reset_settings(s)
	}
}

func (s *Alter_topic_reset_settingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAlter_topic_reset_settings(s)
	}
}

func (p *SQLv1Antlr4Parser) Alter_topic_reset_settings() (localctx IAlter_topic_reset_settingsContext) {
	localctx = NewAlter_topic_reset_settingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 690, SQLv1Antlr4ParserRULE_alter_topic_reset_settings)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4080)
		p.Match(SQLv1Antlr4ParserRESET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4081)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4082)
		p.An_id()
	}
	p.SetState(4087)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(4083)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4084)
			p.An_id_pure()
		}

		p.SetState(4089)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4090)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_topic_stmtContext is an interface to support dynamic dispatch.
type IDrop_topic_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	TOPIC() antlr.TerminalNode
	Topic_ref() ITopic_refContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDrop_topic_stmtContext differentiates from other interfaces.
	IsDrop_topic_stmtContext()
}

type Drop_topic_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_topic_stmtContext() *Drop_topic_stmtContext {
	var p = new(Drop_topic_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_topic_stmt
	return p
}

func InitEmptyDrop_topic_stmtContext(p *Drop_topic_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_topic_stmt
}

func (*Drop_topic_stmtContext) IsDrop_topic_stmtContext() {}

func NewDrop_topic_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_topic_stmtContext {
	var p = new(Drop_topic_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_drop_topic_stmt

	return p
}

func (s *Drop_topic_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_topic_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDROP, 0)
}

func (s *Drop_topic_stmtContext) TOPIC() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTOPIC, 0)
}

func (s *Drop_topic_stmtContext) Topic_ref() ITopic_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_refContext)
}

func (s *Drop_topic_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIF, 0)
}

func (s *Drop_topic_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXISTS, 0)
}

func (s *Drop_topic_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_topic_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_topic_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterDrop_topic_stmt(s)
	}
}

func (s *Drop_topic_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitDrop_topic_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Drop_topic_stmt() (localctx IDrop_topic_stmtContext) {
	localctx = NewDrop_topic_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 692, SQLv1Antlr4ParserRULE_drop_topic_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4092)
		p.Match(SQLv1Antlr4ParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4093)
		p.Match(SQLv1Antlr4ParserTOPIC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4096)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 439, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4094)
			p.Match(SQLv1Antlr4ParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4095)
			p.Match(SQLv1Antlr4ParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(4098)
		p.Topic_ref()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITopic_settingsContext is an interface to support dynamic dispatch.
type ITopic_settingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTopic_settings_entry() []ITopic_settings_entryContext
	Topic_settings_entry(i int) ITopic_settings_entryContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTopic_settingsContext differentiates from other interfaces.
	IsTopic_settingsContext()
}

type Topic_settingsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopic_settingsContext() *Topic_settingsContext {
	var p = new(Topic_settingsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_settings
	return p
}

func InitEmptyTopic_settingsContext(p *Topic_settingsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_settings
}

func (*Topic_settingsContext) IsTopic_settingsContext() {}

func NewTopic_settingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Topic_settingsContext {
	var p = new(Topic_settingsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_settings

	return p
}

func (s *Topic_settingsContext) GetParser() antlr.Parser { return s.parser }

func (s *Topic_settingsContext) AllTopic_settings_entry() []ITopic_settings_entryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITopic_settings_entryContext); ok {
			len++
		}
	}

	tst := make([]ITopic_settings_entryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITopic_settings_entryContext); ok {
			tst[i] = t.(ITopic_settings_entryContext)
			i++
		}
	}

	return tst
}

func (s *Topic_settingsContext) Topic_settings_entry(i int) ITopic_settings_entryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_settings_entryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_settings_entryContext)
}

func (s *Topic_settingsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Topic_settingsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Topic_settingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Topic_settingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Topic_settingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterTopic_settings(s)
	}
}

func (s *Topic_settingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitTopic_settings(s)
	}
}

func (p *SQLv1Antlr4Parser) Topic_settings() (localctx ITopic_settingsContext) {
	localctx = NewTopic_settingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 694, SQLv1Antlr4ParserRULE_topic_settings)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4100)
		p.Topic_settings_entry()
	}
	p.SetState(4105)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(4101)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4102)
			p.Topic_settings_entry()
		}

		p.SetState(4107)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITopic_settings_entryContext is an interface to support dynamic dispatch.
type ITopic_settings_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext
	EQUALS() antlr.TerminalNode
	Topic_setting_value() ITopic_setting_valueContext

	// IsTopic_settings_entryContext differentiates from other interfaces.
	IsTopic_settings_entryContext()
}

type Topic_settings_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopic_settings_entryContext() *Topic_settings_entryContext {
	var p = new(Topic_settings_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_settings_entry
	return p
}

func InitEmptyTopic_settings_entryContext(p *Topic_settings_entryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_settings_entry
}

func (*Topic_settings_entryContext) IsTopic_settings_entryContext() {}

func NewTopic_settings_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Topic_settings_entryContext {
	var p = new(Topic_settings_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_settings_entry

	return p
}

func (s *Topic_settings_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Topic_settings_entryContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Topic_settings_entryContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEQUALS, 0)
}

func (s *Topic_settings_entryContext) Topic_setting_value() ITopic_setting_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_setting_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_setting_valueContext)
}

func (s *Topic_settings_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Topic_settings_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Topic_settings_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterTopic_settings_entry(s)
	}
}

func (s *Topic_settings_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitTopic_settings_entry(s)
	}
}

func (p *SQLv1Antlr4Parser) Topic_settings_entry() (localctx ITopic_settings_entryContext) {
	localctx = NewTopic_settings_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 696, SQLv1Antlr4ParserRULE_topic_settings_entry)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4108)
		p.An_id()
	}
	{
		p.SetState(4109)
		p.Match(SQLv1Antlr4ParserEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4110)
		p.Topic_setting_value()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITopic_setting_valueContext is an interface to support dynamic dispatch.
type ITopic_setting_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext

	// IsTopic_setting_valueContext differentiates from other interfaces.
	IsTopic_setting_valueContext()
}

type Topic_setting_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopic_setting_valueContext() *Topic_setting_valueContext {
	var p = new(Topic_setting_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_setting_value
	return p
}

func InitEmptyTopic_setting_valueContext(p *Topic_setting_valueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_setting_value
}

func (*Topic_setting_valueContext) IsTopic_setting_valueContext() {}

func NewTopic_setting_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Topic_setting_valueContext {
	var p = new(Topic_setting_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_setting_value

	return p
}

func (s *Topic_setting_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Topic_setting_valueContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Topic_setting_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Topic_setting_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Topic_setting_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterTopic_setting_value(s)
	}
}

func (s *Topic_setting_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitTopic_setting_value(s)
	}
}

func (p *SQLv1Antlr4Parser) Topic_setting_value() (localctx ITopic_setting_valueContext) {
	localctx = NewTopic_setting_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 698, SQLv1Antlr4ParserRULE_topic_setting_value)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4112)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITopic_consumer_with_settingsContext is an interface to support dynamic dispatch.
type ITopic_consumer_with_settingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Topic_consumer_settings() ITopic_consumer_settingsContext
	RPAREN() antlr.TerminalNode

	// IsTopic_consumer_with_settingsContext differentiates from other interfaces.
	IsTopic_consumer_with_settingsContext()
}

type Topic_consumer_with_settingsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopic_consumer_with_settingsContext() *Topic_consumer_with_settingsContext {
	var p = new(Topic_consumer_with_settingsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_consumer_with_settings
	return p
}

func InitEmptyTopic_consumer_with_settingsContext(p *Topic_consumer_with_settingsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_consumer_with_settings
}

func (*Topic_consumer_with_settingsContext) IsTopic_consumer_with_settingsContext() {}

func NewTopic_consumer_with_settingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Topic_consumer_with_settingsContext {
	var p = new(Topic_consumer_with_settingsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_consumer_with_settings

	return p
}

func (s *Topic_consumer_with_settingsContext) GetParser() antlr.Parser { return s.parser }

func (s *Topic_consumer_with_settingsContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWITH, 0)
}

func (s *Topic_consumer_with_settingsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Topic_consumer_with_settingsContext) Topic_consumer_settings() ITopic_consumer_settingsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_consumer_settingsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_consumer_settingsContext)
}

func (s *Topic_consumer_with_settingsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Topic_consumer_with_settingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Topic_consumer_with_settingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Topic_consumer_with_settingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterTopic_consumer_with_settings(s)
	}
}

func (s *Topic_consumer_with_settingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitTopic_consumer_with_settings(s)
	}
}

func (p *SQLv1Antlr4Parser) Topic_consumer_with_settings() (localctx ITopic_consumer_with_settingsContext) {
	localctx = NewTopic_consumer_with_settingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 700, SQLv1Antlr4ParserRULE_topic_consumer_with_settings)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4114)
		p.Match(SQLv1Antlr4ParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4115)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4116)
		p.Topic_consumer_settings()
	}
	{
		p.SetState(4117)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITopic_consumer_settingsContext is an interface to support dynamic dispatch.
type ITopic_consumer_settingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTopic_consumer_settings_entry() []ITopic_consumer_settings_entryContext
	Topic_consumer_settings_entry(i int) ITopic_consumer_settings_entryContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTopic_consumer_settingsContext differentiates from other interfaces.
	IsTopic_consumer_settingsContext()
}

type Topic_consumer_settingsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopic_consumer_settingsContext() *Topic_consumer_settingsContext {
	var p = new(Topic_consumer_settingsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_consumer_settings
	return p
}

func InitEmptyTopic_consumer_settingsContext(p *Topic_consumer_settingsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_consumer_settings
}

func (*Topic_consumer_settingsContext) IsTopic_consumer_settingsContext() {}

func NewTopic_consumer_settingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Topic_consumer_settingsContext {
	var p = new(Topic_consumer_settingsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_consumer_settings

	return p
}

func (s *Topic_consumer_settingsContext) GetParser() antlr.Parser { return s.parser }

func (s *Topic_consumer_settingsContext) AllTopic_consumer_settings_entry() []ITopic_consumer_settings_entryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITopic_consumer_settings_entryContext); ok {
			len++
		}
	}

	tst := make([]ITopic_consumer_settings_entryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITopic_consumer_settings_entryContext); ok {
			tst[i] = t.(ITopic_consumer_settings_entryContext)
			i++
		}
	}

	return tst
}

func (s *Topic_consumer_settingsContext) Topic_consumer_settings_entry(i int) ITopic_consumer_settings_entryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_consumer_settings_entryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_consumer_settings_entryContext)
}

func (s *Topic_consumer_settingsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Topic_consumer_settingsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Topic_consumer_settingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Topic_consumer_settingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Topic_consumer_settingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterTopic_consumer_settings(s)
	}
}

func (s *Topic_consumer_settingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitTopic_consumer_settings(s)
	}
}

func (p *SQLv1Antlr4Parser) Topic_consumer_settings() (localctx ITopic_consumer_settingsContext) {
	localctx = NewTopic_consumer_settingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 702, SQLv1Antlr4ParserRULE_topic_consumer_settings)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4119)
		p.Topic_consumer_settings_entry()
	}
	p.SetState(4124)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(4120)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4121)
			p.Topic_consumer_settings_entry()
		}

		p.SetState(4126)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITopic_consumer_settings_entryContext is an interface to support dynamic dispatch.
type ITopic_consumer_settings_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext
	EQUALS() antlr.TerminalNode
	Topic_consumer_setting_value() ITopic_consumer_setting_valueContext

	// IsTopic_consumer_settings_entryContext differentiates from other interfaces.
	IsTopic_consumer_settings_entryContext()
}

type Topic_consumer_settings_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopic_consumer_settings_entryContext() *Topic_consumer_settings_entryContext {
	var p = new(Topic_consumer_settings_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_consumer_settings_entry
	return p
}

func InitEmptyTopic_consumer_settings_entryContext(p *Topic_consumer_settings_entryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_consumer_settings_entry
}

func (*Topic_consumer_settings_entryContext) IsTopic_consumer_settings_entryContext() {}

func NewTopic_consumer_settings_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Topic_consumer_settings_entryContext {
	var p = new(Topic_consumer_settings_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_consumer_settings_entry

	return p
}

func (s *Topic_consumer_settings_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Topic_consumer_settings_entryContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Topic_consumer_settings_entryContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEQUALS, 0)
}

func (s *Topic_consumer_settings_entryContext) Topic_consumer_setting_value() ITopic_consumer_setting_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopic_consumer_setting_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopic_consumer_setting_valueContext)
}

func (s *Topic_consumer_settings_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Topic_consumer_settings_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Topic_consumer_settings_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterTopic_consumer_settings_entry(s)
	}
}

func (s *Topic_consumer_settings_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitTopic_consumer_settings_entry(s)
	}
}

func (p *SQLv1Antlr4Parser) Topic_consumer_settings_entry() (localctx ITopic_consumer_settings_entryContext) {
	localctx = NewTopic_consumer_settings_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 704, SQLv1Antlr4ParserRULE_topic_consumer_settings_entry)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4127)
		p.An_id()
	}
	{
		p.SetState(4128)
		p.Match(SQLv1Antlr4ParserEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4129)
		p.Topic_consumer_setting_value()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITopic_consumer_setting_valueContext is an interface to support dynamic dispatch.
type ITopic_consumer_setting_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext

	// IsTopic_consumer_setting_valueContext differentiates from other interfaces.
	IsTopic_consumer_setting_valueContext()
}

type Topic_consumer_setting_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopic_consumer_setting_valueContext() *Topic_consumer_setting_valueContext {
	var p = new(Topic_consumer_setting_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_consumer_setting_value
	return p
}

func InitEmptyTopic_consumer_setting_valueContext(p *Topic_consumer_setting_valueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_consumer_setting_value
}

func (*Topic_consumer_setting_valueContext) IsTopic_consumer_setting_valueContext() {}

func NewTopic_consumer_setting_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Topic_consumer_setting_valueContext {
	var p = new(Topic_consumer_setting_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_consumer_setting_value

	return p
}

func (s *Topic_consumer_setting_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Topic_consumer_setting_valueContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Topic_consumer_setting_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Topic_consumer_setting_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Topic_consumer_setting_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterTopic_consumer_setting_value(s)
	}
}

func (s *Topic_consumer_setting_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitTopic_consumer_setting_value(s)
	}
}

func (p *SQLv1Antlr4Parser) Topic_consumer_setting_value() (localctx ITopic_consumer_setting_valueContext) {
	localctx = NewTopic_consumer_setting_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 706, SQLv1Antlr4ParserRULE_topic_consumer_setting_value)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4131)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITopic_refContext is an interface to support dynamic dispatch.
type ITopic_refContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext
	Cluster_expr() ICluster_exprContext
	DOT() antlr.TerminalNode

	// IsTopic_refContext differentiates from other interfaces.
	IsTopic_refContext()
}

type Topic_refContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopic_refContext() *Topic_refContext {
	var p = new(Topic_refContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_ref
	return p
}

func InitEmptyTopic_refContext(p *Topic_refContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_ref
}

func (*Topic_refContext) IsTopic_refContext() {}

func NewTopic_refContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Topic_refContext {
	var p = new(Topic_refContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_ref

	return p
}

func (s *Topic_refContext) GetParser() antlr.Parser { return s.parser }

func (s *Topic_refContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Topic_refContext) Cluster_expr() ICluster_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICluster_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICluster_exprContext)
}

func (s *Topic_refContext) DOT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDOT, 0)
}

func (s *Topic_refContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Topic_refContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Topic_refContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterTopic_ref(s)
	}
}

func (s *Topic_refContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitTopic_ref(s)
	}
}

func (p *SQLv1Antlr4Parser) Topic_ref() (localctx ITopic_refContext) {
	localctx = NewTopic_refContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 708, SQLv1Antlr4ParserRULE_topic_ref)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4136)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 442, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4133)
			p.Cluster_expr()
		}
		{
			p.SetState(4134)
			p.Match(SQLv1Antlr4ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(4138)
		p.An_id()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITopic_consumer_refContext is an interface to support dynamic dispatch.
type ITopic_consumer_refContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id_pure() IAn_id_pureContext

	// IsTopic_consumer_refContext differentiates from other interfaces.
	IsTopic_consumer_refContext()
}

type Topic_consumer_refContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopic_consumer_refContext() *Topic_consumer_refContext {
	var p = new(Topic_consumer_refContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_consumer_ref
	return p
}

func InitEmptyTopic_consumer_refContext(p *Topic_consumer_refContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_consumer_ref
}

func (*Topic_consumer_refContext) IsTopic_consumer_refContext() {}

func NewTopic_consumer_refContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Topic_consumer_refContext {
	var p = new(Topic_consumer_refContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_topic_consumer_ref

	return p
}

func (s *Topic_consumer_refContext) GetParser() antlr.Parser { return s.parser }

func (s *Topic_consumer_refContext) An_id_pure() IAn_id_pureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_pureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_pureContext)
}

func (s *Topic_consumer_refContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Topic_consumer_refContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Topic_consumer_refContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterTopic_consumer_ref(s)
	}
}

func (s *Topic_consumer_refContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitTopic_consumer_ref(s)
	}
}

func (p *SQLv1Antlr4Parser) Topic_consumer_ref() (localctx ITopic_consumer_refContext) {
	localctx = NewTopic_consumer_refContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 710, SQLv1Antlr4ParserRULE_topic_consumer_ref)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4140)
		p.An_id_pure()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INull_treatmentContext is an interface to support dynamic dispatch.
type INull_treatmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESPECT() antlr.TerminalNode
	NULLS() antlr.TerminalNode
	IGNORE() antlr.TerminalNode

	// IsNull_treatmentContext differentiates from other interfaces.
	IsNull_treatmentContext()
}

type Null_treatmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNull_treatmentContext() *Null_treatmentContext {
	var p = new(Null_treatmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_null_treatment
	return p
}

func InitEmptyNull_treatmentContext(p *Null_treatmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_null_treatment
}

func (*Null_treatmentContext) IsNull_treatmentContext() {}

func NewNull_treatmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Null_treatmentContext {
	var p = new(Null_treatmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_null_treatment

	return p
}

func (s *Null_treatmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Null_treatmentContext) RESPECT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRESPECT, 0)
}

func (s *Null_treatmentContext) NULLS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNULLS, 0)
}

func (s *Null_treatmentContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIGNORE, 0)
}

func (s *Null_treatmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Null_treatmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Null_treatmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterNull_treatment(s)
	}
}

func (s *Null_treatmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitNull_treatment(s)
	}
}

func (p *SQLv1Antlr4Parser) Null_treatment() (localctx INull_treatmentContext) {
	localctx = NewNull_treatmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 712, SQLv1Antlr4ParserRULE_null_treatment)
	p.SetState(4146)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserRESPECT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4142)
			p.Match(SQLv1Antlr4ParserRESPECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4143)
			p.Match(SQLv1Antlr4ParserNULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserIGNORE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4144)
			p.Match(SQLv1Antlr4ParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4145)
			p.Match(SQLv1Antlr4ParserNULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFilter_clauseContext is an interface to support dynamic dispatch.
type IFilter_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FILTER() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expr() IExprContext
	RPAREN() antlr.TerminalNode

	// IsFilter_clauseContext differentiates from other interfaces.
	IsFilter_clauseContext()
}

type Filter_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilter_clauseContext() *Filter_clauseContext {
	var p = new(Filter_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_filter_clause
	return p
}

func InitEmptyFilter_clauseContext(p *Filter_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_filter_clause
}

func (*Filter_clauseContext) IsFilter_clauseContext() {}

func NewFilter_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Filter_clauseContext {
	var p = new(Filter_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_filter_clause

	return p
}

func (s *Filter_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Filter_clauseContext) FILTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFILTER, 0)
}

func (s *Filter_clauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Filter_clauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWHERE, 0)
}

func (s *Filter_clauseContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Filter_clauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Filter_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Filter_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Filter_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterFilter_clause(s)
	}
}

func (s *Filter_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitFilter_clause(s)
	}
}

func (p *SQLv1Antlr4Parser) Filter_clause() (localctx IFilter_clauseContext) {
	localctx = NewFilter_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 714, SQLv1Antlr4ParserRULE_filter_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4148)
		p.Match(SQLv1Antlr4ParserFILTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4149)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4150)
		p.Match(SQLv1Antlr4ParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4151)
		p.Expr()
	}
	{
		p.SetState(4152)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindow_name_or_specificationContext is an interface to support dynamic dispatch.
type IWindow_name_or_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Window_name() IWindow_nameContext
	Window_specification() IWindow_specificationContext

	// IsWindow_name_or_specificationContext differentiates from other interfaces.
	IsWindow_name_or_specificationContext()
}

type Window_name_or_specificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_name_or_specificationContext() *Window_name_or_specificationContext {
	var p = new(Window_name_or_specificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_name_or_specification
	return p
}

func InitEmptyWindow_name_or_specificationContext(p *Window_name_or_specificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_name_or_specification
}

func (*Window_name_or_specificationContext) IsWindow_name_or_specificationContext() {}

func NewWindow_name_or_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_name_or_specificationContext {
	var p = new(Window_name_or_specificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_name_or_specification

	return p
}

func (s *Window_name_or_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_name_or_specificationContext) Window_name() IWindow_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_nameContext)
}

func (s *Window_name_or_specificationContext) Window_specification() IWindow_specificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_specificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_specificationContext)
}

func (s *Window_name_or_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_name_or_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Window_name_or_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterWindow_name_or_specification(s)
	}
}

func (s *Window_name_or_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitWindow_name_or_specification(s)
	}
}

func (p *SQLv1Antlr4Parser) Window_name_or_specification() (localctx IWindow_name_or_specificationContext) {
	localctx = NewWindow_name_or_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 716, SQLv1Antlr4ParserRULE_window_name_or_specification)
	p.SetState(4156)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALL, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserANY, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSTREAM, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWITHOUT, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserSTRING_VALUE, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4154)
			p.Window_name()
		}

	case SQLv1Antlr4ParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4155)
			p.Window_specification()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindow_nameContext is an interface to support dynamic dispatch.
type IWindow_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id_window() IAn_id_windowContext

	// IsWindow_nameContext differentiates from other interfaces.
	IsWindow_nameContext()
}

type Window_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_nameContext() *Window_nameContext {
	var p = new(Window_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_name
	return p
}

func InitEmptyWindow_nameContext(p *Window_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_name
}

func (*Window_nameContext) IsWindow_nameContext() {}

func NewWindow_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_nameContext {
	var p = new(Window_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_name

	return p
}

func (s *Window_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_nameContext) An_id_window() IAn_id_windowContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_windowContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_windowContext)
}

func (s *Window_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Window_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterWindow_name(s)
	}
}

func (s *Window_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitWindow_name(s)
	}
}

func (p *SQLv1Antlr4Parser) Window_name() (localctx IWindow_nameContext) {
	localctx = NewWindow_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 718, SQLv1Antlr4ParserRULE_window_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4158)
		p.An_id_window()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindow_clauseContext is an interface to support dynamic dispatch.
type IWindow_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WINDOW() antlr.TerminalNode
	Window_definition_list() IWindow_definition_listContext

	// IsWindow_clauseContext differentiates from other interfaces.
	IsWindow_clauseContext()
}

type Window_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_clauseContext() *Window_clauseContext {
	var p = new(Window_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_clause
	return p
}

func InitEmptyWindow_clauseContext(p *Window_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_clause
}

func (*Window_clauseContext) IsWindow_clauseContext() {}

func NewWindow_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_clauseContext {
	var p = new(Window_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_clause

	return p
}

func (s *Window_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_clauseContext) WINDOW() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWINDOW, 0)
}

func (s *Window_clauseContext) Window_definition_list() IWindow_definition_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_definition_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_definition_listContext)
}

func (s *Window_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Window_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterWindow_clause(s)
	}
}

func (s *Window_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitWindow_clause(s)
	}
}

func (p *SQLv1Antlr4Parser) Window_clause() (localctx IWindow_clauseContext) {
	localctx = NewWindow_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 720, SQLv1Antlr4ParserRULE_window_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4160)
		p.Match(SQLv1Antlr4ParserWINDOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4161)
		p.Window_definition_list()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindow_definition_listContext is an interface to support dynamic dispatch.
type IWindow_definition_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllWindow_definition() []IWindow_definitionContext
	Window_definition(i int) IWindow_definitionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWindow_definition_listContext differentiates from other interfaces.
	IsWindow_definition_listContext()
}

type Window_definition_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_definition_listContext() *Window_definition_listContext {
	var p = new(Window_definition_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_definition_list
	return p
}

func InitEmptyWindow_definition_listContext(p *Window_definition_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_definition_list
}

func (*Window_definition_listContext) IsWindow_definition_listContext() {}

func NewWindow_definition_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_definition_listContext {
	var p = new(Window_definition_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_definition_list

	return p
}

func (s *Window_definition_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_definition_listContext) AllWindow_definition() []IWindow_definitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWindow_definitionContext); ok {
			len++
		}
	}

	tst := make([]IWindow_definitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWindow_definitionContext); ok {
			tst[i] = t.(IWindow_definitionContext)
			i++
		}
	}

	return tst
}

func (s *Window_definition_listContext) Window_definition(i int) IWindow_definitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_definitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_definitionContext)
}

func (s *Window_definition_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Window_definition_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Window_definition_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_definition_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Window_definition_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterWindow_definition_list(s)
	}
}

func (s *Window_definition_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitWindow_definition_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Window_definition_list() (localctx IWindow_definition_listContext) {
	localctx = NewWindow_definition_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 722, SQLv1Antlr4ParserRULE_window_definition_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4163)
		p.Window_definition()
	}
	p.SetState(4168)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(4164)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4165)
			p.Window_definition()
		}

		p.SetState(4170)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindow_definitionContext is an interface to support dynamic dispatch.
type IWindow_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	New_window_name() INew_window_nameContext
	AS() antlr.TerminalNode
	Window_specification() IWindow_specificationContext

	// IsWindow_definitionContext differentiates from other interfaces.
	IsWindow_definitionContext()
}

type Window_definitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_definitionContext() *Window_definitionContext {
	var p = new(Window_definitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_definition
	return p
}

func InitEmptyWindow_definitionContext(p *Window_definitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_definition
}

func (*Window_definitionContext) IsWindow_definitionContext() {}

func NewWindow_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_definitionContext {
	var p = new(Window_definitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_definition

	return p
}

func (s *Window_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_definitionContext) New_window_name() INew_window_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INew_window_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INew_window_nameContext)
}

func (s *Window_definitionContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAS, 0)
}

func (s *Window_definitionContext) Window_specification() IWindow_specificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_specificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_specificationContext)
}

func (s *Window_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Window_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterWindow_definition(s)
	}
}

func (s *Window_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitWindow_definition(s)
	}
}

func (p *SQLv1Antlr4Parser) Window_definition() (localctx IWindow_definitionContext) {
	localctx = NewWindow_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 724, SQLv1Antlr4ParserRULE_window_definition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4171)
		p.New_window_name()
	}
	{
		p.SetState(4172)
		p.Match(SQLv1Antlr4ParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4173)
		p.Window_specification()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INew_window_nameContext is an interface to support dynamic dispatch.
type INew_window_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Window_name() IWindow_nameContext

	// IsNew_window_nameContext differentiates from other interfaces.
	IsNew_window_nameContext()
}

type New_window_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNew_window_nameContext() *New_window_nameContext {
	var p = new(New_window_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_new_window_name
	return p
}

func InitEmptyNew_window_nameContext(p *New_window_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_new_window_name
}

func (*New_window_nameContext) IsNew_window_nameContext() {}

func NewNew_window_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *New_window_nameContext {
	var p = new(New_window_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_new_window_name

	return p
}

func (s *New_window_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *New_window_nameContext) Window_name() IWindow_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_nameContext)
}

func (s *New_window_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *New_window_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *New_window_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterNew_window_name(s)
	}
}

func (s *New_window_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitNew_window_name(s)
	}
}

func (p *SQLv1Antlr4Parser) New_window_name() (localctx INew_window_nameContext) {
	localctx = NewNew_window_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 726, SQLv1Antlr4ParserRULE_new_window_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4175)
		p.Window_name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindow_specificationContext is an interface to support dynamic dispatch.
type IWindow_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Window_specification_details() IWindow_specification_detailsContext
	RPAREN() antlr.TerminalNode

	// IsWindow_specificationContext differentiates from other interfaces.
	IsWindow_specificationContext()
}

type Window_specificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_specificationContext() *Window_specificationContext {
	var p = new(Window_specificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_specification
	return p
}

func InitEmptyWindow_specificationContext(p *Window_specificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_specification
}

func (*Window_specificationContext) IsWindow_specificationContext() {}

func NewWindow_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_specificationContext {
	var p = new(Window_specificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_specification

	return p
}

func (s *Window_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_specificationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Window_specificationContext) Window_specification_details() IWindow_specification_detailsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_specification_detailsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_specification_detailsContext)
}

func (s *Window_specificationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Window_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Window_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterWindow_specification(s)
	}
}

func (s *Window_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitWindow_specification(s)
	}
}

func (p *SQLv1Antlr4Parser) Window_specification() (localctx IWindow_specificationContext) {
	localctx = NewWindow_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 728, SQLv1Antlr4ParserRULE_window_specification)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4177)
		p.Match(SQLv1Antlr4ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4178)
		p.Window_specification_details()
	}
	{
		p.SetState(4179)
		p.Match(SQLv1Antlr4ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindow_specification_detailsContext is an interface to support dynamic dispatch.
type IWindow_specification_detailsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Existing_window_name() IExisting_window_nameContext
	Window_partition_clause() IWindow_partition_clauseContext
	Window_order_clause() IWindow_order_clauseContext
	Window_frame_clause() IWindow_frame_clauseContext

	// IsWindow_specification_detailsContext differentiates from other interfaces.
	IsWindow_specification_detailsContext()
}

type Window_specification_detailsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_specification_detailsContext() *Window_specification_detailsContext {
	var p = new(Window_specification_detailsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_specification_details
	return p
}

func InitEmptyWindow_specification_detailsContext(p *Window_specification_detailsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_specification_details
}

func (*Window_specification_detailsContext) IsWindow_specification_detailsContext() {}

func NewWindow_specification_detailsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_specification_detailsContext {
	var p = new(Window_specification_detailsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_specification_details

	return p
}

func (s *Window_specification_detailsContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_specification_detailsContext) Existing_window_name() IExisting_window_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExisting_window_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExisting_window_nameContext)
}

func (s *Window_specification_detailsContext) Window_partition_clause() IWindow_partition_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_partition_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_partition_clauseContext)
}

func (s *Window_specification_detailsContext) Window_order_clause() IWindow_order_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_order_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_order_clauseContext)
}

func (s *Window_specification_detailsContext) Window_frame_clause() IWindow_frame_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_frame_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_frame_clauseContext)
}

func (s *Window_specification_detailsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_specification_detailsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Window_specification_detailsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterWindow_specification_details(s)
	}
}

func (s *Window_specification_detailsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitWindow_specification_details(s)
	}
}

func (p *SQLv1Antlr4Parser) Window_specification_details() (localctx IWindow_specification_detailsContext) {
	localctx = NewWindow_specification_detailsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 730, SQLv1Antlr4ParserRULE_window_specification_details)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4182)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 446, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4181)
			p.Existing_window_name()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4185)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserPARTITION {
		{
			p.SetState(4184)
			p.Window_partition_clause()
		}

	}
	p.SetState(4188)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserORDER {
		{
			p.SetState(4187)
			p.Window_order_clause()
		}

	}
	p.SetState(4191)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserGROUPS || _la == SQLv1Antlr4ParserRANGE || _la == SQLv1Antlr4ParserROWS {
		{
			p.SetState(4190)
			p.Window_frame_clause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExisting_window_nameContext is an interface to support dynamic dispatch.
type IExisting_window_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Window_name() IWindow_nameContext

	// IsExisting_window_nameContext differentiates from other interfaces.
	IsExisting_window_nameContext()
}

type Existing_window_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExisting_window_nameContext() *Existing_window_nameContext {
	var p = new(Existing_window_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_existing_window_name
	return p
}

func InitEmptyExisting_window_nameContext(p *Existing_window_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_existing_window_name
}

func (*Existing_window_nameContext) IsExisting_window_nameContext() {}

func NewExisting_window_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Existing_window_nameContext {
	var p = new(Existing_window_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_existing_window_name

	return p
}

func (s *Existing_window_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Existing_window_nameContext) Window_name() IWindow_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_nameContext)
}

func (s *Existing_window_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Existing_window_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Existing_window_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterExisting_window_name(s)
	}
}

func (s *Existing_window_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitExisting_window_name(s)
	}
}

func (p *SQLv1Antlr4Parser) Existing_window_name() (localctx IExisting_window_nameContext) {
	localctx = NewExisting_window_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 732, SQLv1Antlr4ParserRULE_existing_window_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4193)
		p.Window_name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindow_partition_clauseContext is an interface to support dynamic dispatch.
type IWindow_partition_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	Named_expr_list() INamed_expr_listContext
	COMPACT() antlr.TerminalNode

	// IsWindow_partition_clauseContext differentiates from other interfaces.
	IsWindow_partition_clauseContext()
}

type Window_partition_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_partition_clauseContext() *Window_partition_clauseContext {
	var p = new(Window_partition_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_partition_clause
	return p
}

func InitEmptyWindow_partition_clauseContext(p *Window_partition_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_partition_clause
}

func (*Window_partition_clauseContext) IsWindow_partition_clauseContext() {}

func NewWindow_partition_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_partition_clauseContext {
	var p = new(Window_partition_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_partition_clause

	return p
}

func (s *Window_partition_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_partition_clauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPARTITION, 0)
}

func (s *Window_partition_clauseContext) BY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserBY, 0)
}

func (s *Window_partition_clauseContext) Named_expr_list() INamed_expr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_expr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_expr_listContext)
}

func (s *Window_partition_clauseContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMPACT, 0)
}

func (s *Window_partition_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_partition_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Window_partition_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterWindow_partition_clause(s)
	}
}

func (s *Window_partition_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitWindow_partition_clause(s)
	}
}

func (p *SQLv1Antlr4Parser) Window_partition_clause() (localctx IWindow_partition_clauseContext) {
	localctx = NewWindow_partition_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 734, SQLv1Antlr4ParserRULE_window_partition_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4195)
		p.Match(SQLv1Antlr4ParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4197)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserCOMPACT {
		{
			p.SetState(4196)
			p.Match(SQLv1Antlr4ParserCOMPACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4199)
		p.Match(SQLv1Antlr4ParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4200)
		p.Named_expr_list()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindow_order_clauseContext is an interface to support dynamic dispatch.
type IWindow_order_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Order_by_clause() IOrder_by_clauseContext

	// IsWindow_order_clauseContext differentiates from other interfaces.
	IsWindow_order_clauseContext()
}

type Window_order_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_order_clauseContext() *Window_order_clauseContext {
	var p = new(Window_order_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_order_clause
	return p
}

func InitEmptyWindow_order_clauseContext(p *Window_order_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_order_clause
}

func (*Window_order_clauseContext) IsWindow_order_clauseContext() {}

func NewWindow_order_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_order_clauseContext {
	var p = new(Window_order_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_order_clause

	return p
}

func (s *Window_order_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_order_clauseContext) Order_by_clause() IOrder_by_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_by_clauseContext)
}

func (s *Window_order_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_order_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Window_order_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterWindow_order_clause(s)
	}
}

func (s *Window_order_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitWindow_order_clause(s)
	}
}

func (p *SQLv1Antlr4Parser) Window_order_clause() (localctx IWindow_order_clauseContext) {
	localctx = NewWindow_order_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 736, SQLv1Antlr4ParserRULE_window_order_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4202)
		p.Order_by_clause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindow_frame_clauseContext is an interface to support dynamic dispatch.
type IWindow_frame_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Window_frame_units() IWindow_frame_unitsContext
	Window_frame_extent() IWindow_frame_extentContext
	Window_frame_exclusion() IWindow_frame_exclusionContext

	// IsWindow_frame_clauseContext differentiates from other interfaces.
	IsWindow_frame_clauseContext()
}

type Window_frame_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_frame_clauseContext() *Window_frame_clauseContext {
	var p = new(Window_frame_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_frame_clause
	return p
}

func InitEmptyWindow_frame_clauseContext(p *Window_frame_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_frame_clause
}

func (*Window_frame_clauseContext) IsWindow_frame_clauseContext() {}

func NewWindow_frame_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_frame_clauseContext {
	var p = new(Window_frame_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_frame_clause

	return p
}

func (s *Window_frame_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_frame_clauseContext) Window_frame_units() IWindow_frame_unitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_frame_unitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_frame_unitsContext)
}

func (s *Window_frame_clauseContext) Window_frame_extent() IWindow_frame_extentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_frame_extentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_frame_extentContext)
}

func (s *Window_frame_clauseContext) Window_frame_exclusion() IWindow_frame_exclusionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_frame_exclusionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_frame_exclusionContext)
}

func (s *Window_frame_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_frame_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Window_frame_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterWindow_frame_clause(s)
	}
}

func (s *Window_frame_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitWindow_frame_clause(s)
	}
}

func (p *SQLv1Antlr4Parser) Window_frame_clause() (localctx IWindow_frame_clauseContext) {
	localctx = NewWindow_frame_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 738, SQLv1Antlr4ParserRULE_window_frame_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4204)
		p.Window_frame_units()
	}
	{
		p.SetState(4205)
		p.Window_frame_extent()
	}
	p.SetState(4207)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserEXCLUDE {
		{
			p.SetState(4206)
			p.Window_frame_exclusion()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindow_frame_unitsContext is an interface to support dynamic dispatch.
type IWindow_frame_unitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROWS() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	GROUPS() antlr.TerminalNode

	// IsWindow_frame_unitsContext differentiates from other interfaces.
	IsWindow_frame_unitsContext()
}

type Window_frame_unitsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_frame_unitsContext() *Window_frame_unitsContext {
	var p = new(Window_frame_unitsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_frame_units
	return p
}

func InitEmptyWindow_frame_unitsContext(p *Window_frame_unitsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_frame_units
}

func (*Window_frame_unitsContext) IsWindow_frame_unitsContext() {}

func NewWindow_frame_unitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_frame_unitsContext {
	var p = new(Window_frame_unitsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_frame_units

	return p
}

func (s *Window_frame_unitsContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_frame_unitsContext) ROWS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserROWS, 0)
}

func (s *Window_frame_unitsContext) RANGE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRANGE, 0)
}

func (s *Window_frame_unitsContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGROUPS, 0)
}

func (s *Window_frame_unitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_frame_unitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Window_frame_unitsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterWindow_frame_units(s)
	}
}

func (s *Window_frame_unitsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitWindow_frame_units(s)
	}
}

func (p *SQLv1Antlr4Parser) Window_frame_units() (localctx IWindow_frame_unitsContext) {
	localctx = NewWindow_frame_unitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 740, SQLv1Antlr4ParserRULE_window_frame_units)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4209)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLv1Antlr4ParserGROUPS || _la == SQLv1Antlr4ParserRANGE || _la == SQLv1Antlr4ParserROWS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindow_frame_extentContext is an interface to support dynamic dispatch.
type IWindow_frame_extentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Window_frame_bound() IWindow_frame_boundContext
	Window_frame_between() IWindow_frame_betweenContext

	// IsWindow_frame_extentContext differentiates from other interfaces.
	IsWindow_frame_extentContext()
}

type Window_frame_extentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_frame_extentContext() *Window_frame_extentContext {
	var p = new(Window_frame_extentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_frame_extent
	return p
}

func InitEmptyWindow_frame_extentContext(p *Window_frame_extentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_frame_extent
}

func (*Window_frame_extentContext) IsWindow_frame_extentContext() {}

func NewWindow_frame_extentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_frame_extentContext {
	var p = new(Window_frame_extentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_frame_extent

	return p
}

func (s *Window_frame_extentContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_frame_extentContext) Window_frame_bound() IWindow_frame_boundContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_frame_boundContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_frame_boundContext)
}

func (s *Window_frame_extentContext) Window_frame_between() IWindow_frame_betweenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_frame_betweenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_frame_betweenContext)
}

func (s *Window_frame_extentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_frame_extentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Window_frame_extentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterWindow_frame_extent(s)
	}
}

func (s *Window_frame_extentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitWindow_frame_extent(s)
	}
}

func (p *SQLv1Antlr4Parser) Window_frame_extent() (localctx IWindow_frame_extentContext) {
	localctx = NewWindow_frame_extentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 742, SQLv1Antlr4ParserRULE_window_frame_extent)
	p.SetState(4213)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 452, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4211)
			p.Window_frame_bound()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4212)
			p.Window_frame_between()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindow_frame_betweenContext is an interface to support dynamic dispatch.
type IWindow_frame_betweenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BETWEEN() antlr.TerminalNode
	AllWindow_frame_bound() []IWindow_frame_boundContext
	Window_frame_bound(i int) IWindow_frame_boundContext
	AND() antlr.TerminalNode

	// IsWindow_frame_betweenContext differentiates from other interfaces.
	IsWindow_frame_betweenContext()
}

type Window_frame_betweenContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_frame_betweenContext() *Window_frame_betweenContext {
	var p = new(Window_frame_betweenContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_frame_between
	return p
}

func InitEmptyWindow_frame_betweenContext(p *Window_frame_betweenContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_frame_between
}

func (*Window_frame_betweenContext) IsWindow_frame_betweenContext() {}

func NewWindow_frame_betweenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_frame_betweenContext {
	var p = new(Window_frame_betweenContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_frame_between

	return p
}

func (s *Window_frame_betweenContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_frame_betweenContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserBETWEEN, 0)
}

func (s *Window_frame_betweenContext) AllWindow_frame_bound() []IWindow_frame_boundContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWindow_frame_boundContext); ok {
			len++
		}
	}

	tst := make([]IWindow_frame_boundContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWindow_frame_boundContext); ok {
			tst[i] = t.(IWindow_frame_boundContext)
			i++
		}
	}

	return tst
}

func (s *Window_frame_betweenContext) Window_frame_bound(i int) IWindow_frame_boundContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_frame_boundContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_frame_boundContext)
}

func (s *Window_frame_betweenContext) AND() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAND, 0)
}

func (s *Window_frame_betweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_frame_betweenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Window_frame_betweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterWindow_frame_between(s)
	}
}

func (s *Window_frame_betweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitWindow_frame_between(s)
	}
}

func (p *SQLv1Antlr4Parser) Window_frame_between() (localctx IWindow_frame_betweenContext) {
	localctx = NewWindow_frame_betweenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 744, SQLv1Antlr4ParserRULE_window_frame_between)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4215)
		p.Match(SQLv1Antlr4ParserBETWEEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4216)
		p.Window_frame_bound()
	}
	{
		p.SetState(4217)
		p.Match(SQLv1Antlr4ParserAND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4218)
		p.Window_frame_bound()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindow_frame_boundContext is an interface to support dynamic dispatch.
type IWindow_frame_boundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CURRENT() antlr.TerminalNode
	ROW() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	Expr() IExprContext
	UNBOUNDED() antlr.TerminalNode

	// IsWindow_frame_boundContext differentiates from other interfaces.
	IsWindow_frame_boundContext()
}

type Window_frame_boundContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_frame_boundContext() *Window_frame_boundContext {
	var p = new(Window_frame_boundContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_frame_bound
	return p
}

func InitEmptyWindow_frame_boundContext(p *Window_frame_boundContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_frame_bound
}

func (*Window_frame_boundContext) IsWindow_frame_boundContext() {}

func NewWindow_frame_boundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_frame_boundContext {
	var p = new(Window_frame_boundContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_frame_bound

	return p
}

func (s *Window_frame_boundContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_frame_boundContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCURRENT, 0)
}

func (s *Window_frame_boundContext) ROW() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserROW, 0)
}

func (s *Window_frame_boundContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPRECEDING, 0)
}

func (s *Window_frame_boundContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFOLLOWING, 0)
}

func (s *Window_frame_boundContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Window_frame_boundContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUNBOUNDED, 0)
}

func (s *Window_frame_boundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_frame_boundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Window_frame_boundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterWindow_frame_bound(s)
	}
}

func (s *Window_frame_boundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitWindow_frame_bound(s)
	}
}

func (p *SQLv1Antlr4Parser) Window_frame_bound() (localctx IWindow_frame_boundContext) {
	localctx = NewWindow_frame_boundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 746, SQLv1Antlr4ParserRULE_window_frame_bound)
	var _la int

	p.SetState(4227)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 454, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4220)
			p.Match(SQLv1Antlr4ParserCURRENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4221)
			p.Match(SQLv1Antlr4ParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4224)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 453, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4222)
				p.Expr()
			}

		case 2:
			{
				p.SetState(4223)
				p.Match(SQLv1Antlr4ParserUNBOUNDED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(4226)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLv1Antlr4ParserFOLLOWING || _la == SQLv1Antlr4ParserPRECEDING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindow_frame_exclusionContext is an interface to support dynamic dispatch.
type IWindow_frame_exclusionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXCLUDE() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	ROW() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	TIES() antlr.TerminalNode
	NO() antlr.TerminalNode
	OTHERS() antlr.TerminalNode

	// IsWindow_frame_exclusionContext differentiates from other interfaces.
	IsWindow_frame_exclusionContext()
}

type Window_frame_exclusionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_frame_exclusionContext() *Window_frame_exclusionContext {
	var p = new(Window_frame_exclusionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_frame_exclusion
	return p
}

func InitEmptyWindow_frame_exclusionContext(p *Window_frame_exclusionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_frame_exclusion
}

func (*Window_frame_exclusionContext) IsWindow_frame_exclusionContext() {}

func NewWindow_frame_exclusionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_frame_exclusionContext {
	var p = new(Window_frame_exclusionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_window_frame_exclusion

	return p
}

func (s *Window_frame_exclusionContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_frame_exclusionContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXCLUDE, 0)
}

func (s *Window_frame_exclusionContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCURRENT, 0)
}

func (s *Window_frame_exclusionContext) ROW() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserROW, 0)
}

func (s *Window_frame_exclusionContext) GROUP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGROUP, 0)
}

func (s *Window_frame_exclusionContext) TIES() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTIES, 0)
}

func (s *Window_frame_exclusionContext) NO() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNO, 0)
}

func (s *Window_frame_exclusionContext) OTHERS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOTHERS, 0)
}

func (s *Window_frame_exclusionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_frame_exclusionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Window_frame_exclusionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterWindow_frame_exclusion(s)
	}
}

func (s *Window_frame_exclusionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitWindow_frame_exclusion(s)
	}
}

func (p *SQLv1Antlr4Parser) Window_frame_exclusion() (localctx IWindow_frame_exclusionContext) {
	localctx = NewWindow_frame_exclusionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 748, SQLv1Antlr4ParserRULE_window_frame_exclusion)
	p.SetState(4239)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 455, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4229)
			p.Match(SQLv1Antlr4ParserEXCLUDE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4230)
			p.Match(SQLv1Antlr4ParserCURRENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4231)
			p.Match(SQLv1Antlr4ParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4232)
			p.Match(SQLv1Antlr4ParserEXCLUDE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4233)
			p.Match(SQLv1Antlr4ParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4234)
			p.Match(SQLv1Antlr4ParserEXCLUDE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4235)
			p.Match(SQLv1Antlr4ParserTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4236)
			p.Match(SQLv1Antlr4ParserEXCLUDE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4237)
			p.Match(SQLv1Antlr4ParserNO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4238)
			p.Match(SQLv1Antlr4ParserOTHERS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUse_stmtContext is an interface to support dynamic dispatch.
type IUse_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USE() antlr.TerminalNode
	Cluster_expr() ICluster_exprContext

	// IsUse_stmtContext differentiates from other interfaces.
	IsUse_stmtContext()
}

type Use_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUse_stmtContext() *Use_stmtContext {
	var p = new(Use_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_use_stmt
	return p
}

func InitEmptyUse_stmtContext(p *Use_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_use_stmt
}

func (*Use_stmtContext) IsUse_stmtContext() {}

func NewUse_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Use_stmtContext {
	var p = new(Use_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_use_stmt

	return p
}

func (s *Use_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Use_stmtContext) USE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUSE, 0)
}

func (s *Use_stmtContext) Cluster_expr() ICluster_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICluster_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICluster_exprContext)
}

func (s *Use_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Use_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Use_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterUse_stmt(s)
	}
}

func (s *Use_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitUse_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Use_stmt() (localctx IUse_stmtContext) {
	localctx = NewUse_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 750, SQLv1Antlr4ParserRULE_use_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4241)
		p.Match(SQLv1Antlr4ParserUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4242)
		p.Cluster_expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubselect_stmtContext is an interface to support dynamic dispatch.
type ISubselect_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	RPAREN() antlr.TerminalNode
	Select_unparenthesized_stmt() ISelect_unparenthesized_stmtContext

	// IsSubselect_stmtContext differentiates from other interfaces.
	IsSubselect_stmtContext()
}

type Subselect_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubselect_stmtContext() *Subselect_stmtContext {
	var p = new(Subselect_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_subselect_stmt
	return p
}

func InitEmptySubselect_stmtContext(p *Subselect_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_subselect_stmt
}

func (*Subselect_stmtContext) IsSubselect_stmtContext() {}

func NewSubselect_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subselect_stmtContext {
	var p = new(Subselect_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_subselect_stmt

	return p
}

func (s *Subselect_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Subselect_stmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Subselect_stmtContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Subselect_stmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Subselect_stmtContext) Select_unparenthesized_stmt() ISelect_unparenthesized_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_unparenthesized_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_unparenthesized_stmtContext)
}

func (s *Subselect_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subselect_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subselect_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterSubselect_stmt(s)
	}
}

func (s *Subselect_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitSubselect_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Subselect_stmt() (localctx ISubselect_stmtContext) {
	localctx = NewSubselect_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 752, SQLv1Antlr4ParserRULE_subselect_stmt)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4249)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserLPAREN:
		{
			p.SetState(4244)
			p.Match(SQLv1Antlr4ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4245)
			p.Select_stmt()
		}
		{
			p.SetState(4246)
			p.Match(SQLv1Antlr4ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserSELECT:
		{
			p.SetState(4248)
			p.Select_unparenthesized_stmt()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamed_nodes_stmtContext is an interface to support dynamic dispatch.
type INamed_nodes_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Bind_parameter_list() IBind_parameter_listContext
	EQUALS() antlr.TerminalNode
	Expr() IExprContext
	Subselect_stmt() ISubselect_stmtContext

	// IsNamed_nodes_stmtContext differentiates from other interfaces.
	IsNamed_nodes_stmtContext()
}

type Named_nodes_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_nodes_stmtContext() *Named_nodes_stmtContext {
	var p = new(Named_nodes_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_named_nodes_stmt
	return p
}

func InitEmptyNamed_nodes_stmtContext(p *Named_nodes_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_named_nodes_stmt
}

func (*Named_nodes_stmtContext) IsNamed_nodes_stmtContext() {}

func NewNamed_nodes_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_nodes_stmtContext {
	var p = new(Named_nodes_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_named_nodes_stmt

	return p
}

func (s *Named_nodes_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_nodes_stmtContext) Bind_parameter_list() IBind_parameter_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBind_parameter_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBind_parameter_listContext)
}

func (s *Named_nodes_stmtContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEQUALS, 0)
}

func (s *Named_nodes_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Named_nodes_stmtContext) Subselect_stmt() ISubselect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubselect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubselect_stmtContext)
}

func (s *Named_nodes_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_nodes_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Named_nodes_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterNamed_nodes_stmt(s)
	}
}

func (s *Named_nodes_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitNamed_nodes_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Named_nodes_stmt() (localctx INamed_nodes_stmtContext) {
	localctx = NewNamed_nodes_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 754, SQLv1Antlr4ParserRULE_named_nodes_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4251)
		p.Bind_parameter_list()
	}
	{
		p.SetState(4252)
		p.Match(SQLv1Antlr4ParserEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4255)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 457, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4253)
			p.Expr()
		}

	case 2:
		{
			p.SetState(4254)
			p.Subselect_stmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommit_stmtContext is an interface to support dynamic dispatch.
type ICommit_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMIT() antlr.TerminalNode

	// IsCommit_stmtContext differentiates from other interfaces.
	IsCommit_stmtContext()
}

type Commit_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommit_stmtContext() *Commit_stmtContext {
	var p = new(Commit_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_commit_stmt
	return p
}

func InitEmptyCommit_stmtContext(p *Commit_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_commit_stmt
}

func (*Commit_stmtContext) IsCommit_stmtContext() {}

func NewCommit_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Commit_stmtContext {
	var p = new(Commit_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_commit_stmt

	return p
}

func (s *Commit_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Commit_stmtContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMIT, 0)
}

func (s *Commit_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Commit_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Commit_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterCommit_stmt(s)
	}
}

func (s *Commit_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitCommit_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Commit_stmt() (localctx ICommit_stmtContext) {
	localctx = NewCommit_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 756, SQLv1Antlr4ParserRULE_commit_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4257)
		p.Match(SQLv1Antlr4ParserCOMMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollback_stmtContext is an interface to support dynamic dispatch.
type IRollback_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROLLBACK() antlr.TerminalNode

	// IsRollback_stmtContext differentiates from other interfaces.
	IsRollback_stmtContext()
}

type Rollback_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollback_stmtContext() *Rollback_stmtContext {
	var p = new(Rollback_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_rollback_stmt
	return p
}

func InitEmptyRollback_stmtContext(p *Rollback_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_rollback_stmt
}

func (*Rollback_stmtContext) IsRollback_stmtContext() {}

func NewRollback_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rollback_stmtContext {
	var p = new(Rollback_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_rollback_stmt

	return p
}

func (s *Rollback_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Rollback_stmtContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserROLLBACK, 0)
}

func (s *Rollback_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rollback_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rollback_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterRollback_stmt(s)
	}
}

func (s *Rollback_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitRollback_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Rollback_stmt() (localctx IRollback_stmtContext) {
	localctx = NewRollback_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 758, SQLv1Antlr4ParserRULE_rollback_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4259)
		p.Match(SQLv1Antlr4ParserROLLBACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnalyze_tableContext is an interface to support dynamic dispatch.
type IAnalyze_tableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Simple_table_ref() ISimple_table_refContext
	LPAREN() antlr.TerminalNode
	Column_list() IColumn_listContext
	RPAREN() antlr.TerminalNode

	// IsAnalyze_tableContext differentiates from other interfaces.
	IsAnalyze_tableContext()
}

type Analyze_tableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnalyze_tableContext() *Analyze_tableContext {
	var p = new(Analyze_tableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_analyze_table
	return p
}

func InitEmptyAnalyze_tableContext(p *Analyze_tableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_analyze_table
}

func (*Analyze_tableContext) IsAnalyze_tableContext() {}

func NewAnalyze_tableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Analyze_tableContext {
	var p = new(Analyze_tableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_analyze_table

	return p
}

func (s *Analyze_tableContext) GetParser() antlr.Parser { return s.parser }

func (s *Analyze_tableContext) Simple_table_ref() ISimple_table_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_table_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_table_refContext)
}

func (s *Analyze_tableContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLPAREN, 0)
}

func (s *Analyze_tableContext) Column_list() IColumn_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_listContext)
}

func (s *Analyze_tableContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRPAREN, 0)
}

func (s *Analyze_tableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Analyze_tableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Analyze_tableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAnalyze_table(s)
	}
}

func (s *Analyze_tableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAnalyze_table(s)
	}
}

func (p *SQLv1Antlr4Parser) Analyze_table() (localctx IAnalyze_tableContext) {
	localctx = NewAnalyze_tableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 760, SQLv1Antlr4ParserRULE_analyze_table)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4261)
		p.Simple_table_ref()
	}
	p.SetState(4266)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserLPAREN {
		{
			p.SetState(4262)
			p.Match(SQLv1Antlr4ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4263)
			p.Column_list()
		}
		{
			p.SetState(4264)
			p.Match(SQLv1Antlr4ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnalyze_table_listContext is an interface to support dynamic dispatch.
type IAnalyze_table_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAnalyze_table() []IAnalyze_tableContext
	Analyze_table(i int) IAnalyze_tableContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAnalyze_table_listContext differentiates from other interfaces.
	IsAnalyze_table_listContext()
}

type Analyze_table_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnalyze_table_listContext() *Analyze_table_listContext {
	var p = new(Analyze_table_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_analyze_table_list
	return p
}

func InitEmptyAnalyze_table_listContext(p *Analyze_table_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_analyze_table_list
}

func (*Analyze_table_listContext) IsAnalyze_table_listContext() {}

func NewAnalyze_table_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Analyze_table_listContext {
	var p = new(Analyze_table_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_analyze_table_list

	return p
}

func (s *Analyze_table_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Analyze_table_listContext) AllAnalyze_table() []IAnalyze_tableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnalyze_tableContext); ok {
			len++
		}
	}

	tst := make([]IAnalyze_tableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnalyze_tableContext); ok {
			tst[i] = t.(IAnalyze_tableContext)
			i++
		}
	}

	return tst
}

func (s *Analyze_table_listContext) Analyze_table(i int) IAnalyze_tableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyze_tableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyze_tableContext)
}

func (s *Analyze_table_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLv1Antlr4ParserCOMMA)
}

func (s *Analyze_table_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMA, i)
}

func (s *Analyze_table_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Analyze_table_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Analyze_table_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAnalyze_table_list(s)
	}
}

func (s *Analyze_table_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAnalyze_table_list(s)
	}
}

func (p *SQLv1Antlr4Parser) Analyze_table_list() (localctx IAnalyze_table_listContext) {
	localctx = NewAnalyze_table_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 762, SQLv1Antlr4ParserRULE_analyze_table_list)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4268)
		p.Analyze_table()
	}
	p.SetState(4273)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 459, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4269)
				p.Match(SQLv1Antlr4ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4270)
				p.Analyze_table()
			}

		}
		p.SetState(4275)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 459, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(4277)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserCOMMA {
		{
			p.SetState(4276)
			p.Match(SQLv1Antlr4ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnalyze_stmtContext is an interface to support dynamic dispatch.
type IAnalyze_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ANALYZE() antlr.TerminalNode
	Analyze_table_list() IAnalyze_table_listContext

	// IsAnalyze_stmtContext differentiates from other interfaces.
	IsAnalyze_stmtContext()
}

type Analyze_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnalyze_stmtContext() *Analyze_stmtContext {
	var p = new(Analyze_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_analyze_stmt
	return p
}

func InitEmptyAnalyze_stmtContext(p *Analyze_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_analyze_stmt
}

func (*Analyze_stmtContext) IsAnalyze_stmtContext() {}

func NewAnalyze_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Analyze_stmtContext {
	var p = new(Analyze_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_analyze_stmt

	return p
}

func (s *Analyze_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Analyze_stmtContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserANALYZE, 0)
}

func (s *Analyze_stmtContext) Analyze_table_list() IAnalyze_table_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyze_table_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyze_table_listContext)
}

func (s *Analyze_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Analyze_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Analyze_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAnalyze_stmt(s)
	}
}

func (s *Analyze_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAnalyze_stmt(s)
	}
}

func (p *SQLv1Antlr4Parser) Analyze_stmt() (localctx IAnalyze_stmtContext) {
	localctx = NewAnalyze_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 764, SQLv1Antlr4ParserRULE_analyze_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4279)
		p.Match(SQLv1Antlr4ParserANALYZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4280)
		p.Analyze_table_list()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID_PLAIN() antlr.TerminalNode
	ID_QUOTED() antlr.TerminalNode

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) ID_PLAIN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserID_PLAIN, 0)
}

func (s *IdentifierContext) ID_QUOTED() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserID_QUOTED, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *SQLv1Antlr4Parser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 766, SQLv1Antlr4ParserRULE_identifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4282)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLv1Antlr4ParserID_PLAIN || _la == SQLv1Antlr4ParserID_QUOTED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdContext is an interface to support dynamic dispatch.
type IIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Keyword() IKeywordContext

	// IsIdContext differentiates from other interfaces.
	IsIdContext()
}

type IdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdContext() *IdContext {
	var p = new(IdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_id
	return p
}

func InitEmptyIdContext(p *IdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_id
}

func (*IdContext) IsIdContext() {}

func NewIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdContext {
	var p = new(IdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_id

	return p
}

func (s *IdContext) GetParser() antlr.Parser { return s.parser }

func (s *IdContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdContext) Keyword() IKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordContext)
}

func (s *IdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterId(s)
	}
}

func (s *IdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitId(s)
	}
}

func (p *SQLv1Antlr4Parser) Id() (localctx IIdContext) {
	localctx = NewIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 768, SQLv1Antlr4ParserRULE_id)
	p.SetState(4286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4284)
			p.Identifier()
		}

	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALL, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserANY, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSTREAM, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWITHOUT, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4285)
			p.Keyword()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IId_schemaContext is an interface to support dynamic dispatch.
type IId_schemaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Keyword_compat() IKeyword_compatContext
	Keyword_expr_uncompat() IKeyword_expr_uncompatContext
	Keyword_select_uncompat() IKeyword_select_uncompatContext
	Keyword_in_uncompat() IKeyword_in_uncompatContext
	Keyword_window_uncompat() IKeyword_window_uncompatContext
	Keyword_hint_uncompat() IKeyword_hint_uncompatContext

	// IsId_schemaContext differentiates from other interfaces.
	IsId_schemaContext()
}

type Id_schemaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_schemaContext() *Id_schemaContext {
	var p = new(Id_schemaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_schema
	return p
}

func InitEmptyId_schemaContext(p *Id_schemaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_schema
}

func (*Id_schemaContext) IsId_schemaContext() {}

func NewId_schemaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_schemaContext {
	var p = new(Id_schemaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_schema

	return p
}

func (s *Id_schemaContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_schemaContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Id_schemaContext) Keyword_compat() IKeyword_compatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_compatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_compatContext)
}

func (s *Id_schemaContext) Keyword_expr_uncompat() IKeyword_expr_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_expr_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_expr_uncompatContext)
}

func (s *Id_schemaContext) Keyword_select_uncompat() IKeyword_select_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_select_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_select_uncompatContext)
}

func (s *Id_schemaContext) Keyword_in_uncompat() IKeyword_in_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_in_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_in_uncompatContext)
}

func (s *Id_schemaContext) Keyword_window_uncompat() IKeyword_window_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_window_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_window_uncompatContext)
}

func (s *Id_schemaContext) Keyword_hint_uncompat() IKeyword_hint_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_hint_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_hint_uncompatContext)
}

func (s *Id_schemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_schemaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Id_schemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterId_schema(s)
	}
}

func (s *Id_schemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitId_schema(s)
	}
}

func (p *SQLv1Antlr4Parser) Id_schema() (localctx IId_schemaContext) {
	localctx = NewId_schemaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 770, SQLv1Antlr4ParserRULE_id_schema)
	p.SetState(4295)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4288)
			p.Identifier()
		}

	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4289)
			p.Keyword_compat()
		}

	case SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4290)
			p.Keyword_expr_uncompat()
		}

	case SQLv1Antlr4ParserALL, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITHOUT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4291)
			p.Keyword_select_uncompat()
		}

	case SQLv1Antlr4ParserCOMPACT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4292)
			p.Keyword_in_uncompat()
		}

	case SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserROWS:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4293)
			p.Keyword_window_uncompat()
		}

	case SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserSCHEMA:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4294)
			p.Keyword_hint_uncompat()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IId_exprContext is an interface to support dynamic dispatch.
type IId_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Keyword_compat() IKeyword_compatContext
	Keyword_alter_uncompat() IKeyword_alter_uncompatContext
	Keyword_in_uncompat() IKeyword_in_uncompatContext
	Keyword_window_uncompat() IKeyword_window_uncompatContext
	Keyword_hint_uncompat() IKeyword_hint_uncompatContext

	// IsId_exprContext differentiates from other interfaces.
	IsId_exprContext()
}

type Id_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_exprContext() *Id_exprContext {
	var p = new(Id_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_expr
	return p
}

func InitEmptyId_exprContext(p *Id_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_expr
}

func (*Id_exprContext) IsId_exprContext() {}

func NewId_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_exprContext {
	var p = new(Id_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_expr

	return p
}

func (s *Id_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_exprContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Id_exprContext) Keyword_compat() IKeyword_compatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_compatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_compatContext)
}

func (s *Id_exprContext) Keyword_alter_uncompat() IKeyword_alter_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_alter_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_alter_uncompatContext)
}

func (s *Id_exprContext) Keyword_in_uncompat() IKeyword_in_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_in_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_in_uncompatContext)
}

func (s *Id_exprContext) Keyword_window_uncompat() IKeyword_window_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_window_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_window_uncompatContext)
}

func (s *Id_exprContext) Keyword_hint_uncompat() IKeyword_hint_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_hint_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_hint_uncompatContext)
}

func (s *Id_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Id_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterId_expr(s)
	}
}

func (s *Id_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitId_expr(s)
	}
}

func (p *SQLv1Antlr4Parser) Id_expr() (localctx IId_exprContext) {
	localctx = NewId_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 772, SQLv1Antlr4ParserRULE_id_expr)
	p.SetState(4303)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4297)
			p.Identifier()
		}

	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4298)
			p.Keyword_compat()
		}

	case SQLv1Antlr4ParserCOLUMN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4299)
			p.Keyword_alter_uncompat()
		}

	case SQLv1Antlr4ParserCOMPACT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4300)
			p.Keyword_in_uncompat()
		}

	case SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserROWS:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4301)
			p.Keyword_window_uncompat()
		}

	case SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserSCHEMA:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4302)
			p.Keyword_hint_uncompat()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IId_expr_inContext is an interface to support dynamic dispatch.
type IId_expr_inContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Keyword_compat() IKeyword_compatContext
	Keyword_alter_uncompat() IKeyword_alter_uncompatContext
	Keyword_window_uncompat() IKeyword_window_uncompatContext
	Keyword_hint_uncompat() IKeyword_hint_uncompatContext

	// IsId_expr_inContext differentiates from other interfaces.
	IsId_expr_inContext()
}

type Id_expr_inContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_expr_inContext() *Id_expr_inContext {
	var p = new(Id_expr_inContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_expr_in
	return p
}

func InitEmptyId_expr_inContext(p *Id_expr_inContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_expr_in
}

func (*Id_expr_inContext) IsId_expr_inContext() {}

func NewId_expr_inContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_expr_inContext {
	var p = new(Id_expr_inContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_expr_in

	return p
}

func (s *Id_expr_inContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_expr_inContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Id_expr_inContext) Keyword_compat() IKeyword_compatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_compatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_compatContext)
}

func (s *Id_expr_inContext) Keyword_alter_uncompat() IKeyword_alter_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_alter_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_alter_uncompatContext)
}

func (s *Id_expr_inContext) Keyword_window_uncompat() IKeyword_window_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_window_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_window_uncompatContext)
}

func (s *Id_expr_inContext) Keyword_hint_uncompat() IKeyword_hint_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_hint_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_hint_uncompatContext)
}

func (s *Id_expr_inContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_expr_inContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Id_expr_inContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterId_expr_in(s)
	}
}

func (s *Id_expr_inContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitId_expr_in(s)
	}
}

func (p *SQLv1Antlr4Parser) Id_expr_in() (localctx IId_expr_inContext) {
	localctx = NewId_expr_inContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 774, SQLv1Antlr4ParserRULE_id_expr_in)
	p.SetState(4310)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4305)
			p.Identifier()
		}

	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4306)
			p.Keyword_compat()
		}

	case SQLv1Antlr4ParserCOLUMN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4307)
			p.Keyword_alter_uncompat()
		}

	case SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserROWS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4308)
			p.Keyword_window_uncompat()
		}

	case SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserSCHEMA:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4309)
			p.Keyword_hint_uncompat()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IId_windowContext is an interface to support dynamic dispatch.
type IId_windowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Keyword_compat() IKeyword_compatContext
	Keyword_expr_uncompat() IKeyword_expr_uncompatContext
	Keyword_table_uncompat() IKeyword_table_uncompatContext
	Keyword_select_uncompat() IKeyword_select_uncompatContext
	Keyword_alter_uncompat() IKeyword_alter_uncompatContext
	Keyword_in_uncompat() IKeyword_in_uncompatContext
	Keyword_hint_uncompat() IKeyword_hint_uncompatContext

	// IsId_windowContext differentiates from other interfaces.
	IsId_windowContext()
}

type Id_windowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_windowContext() *Id_windowContext {
	var p = new(Id_windowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_window
	return p
}

func InitEmptyId_windowContext(p *Id_windowContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_window
}

func (*Id_windowContext) IsId_windowContext() {}

func NewId_windowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_windowContext {
	var p = new(Id_windowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_window

	return p
}

func (s *Id_windowContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_windowContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Id_windowContext) Keyword_compat() IKeyword_compatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_compatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_compatContext)
}

func (s *Id_windowContext) Keyword_expr_uncompat() IKeyword_expr_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_expr_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_expr_uncompatContext)
}

func (s *Id_windowContext) Keyword_table_uncompat() IKeyword_table_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_table_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_table_uncompatContext)
}

func (s *Id_windowContext) Keyword_select_uncompat() IKeyword_select_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_select_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_select_uncompatContext)
}

func (s *Id_windowContext) Keyword_alter_uncompat() IKeyword_alter_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_alter_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_alter_uncompatContext)
}

func (s *Id_windowContext) Keyword_in_uncompat() IKeyword_in_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_in_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_in_uncompatContext)
}

func (s *Id_windowContext) Keyword_hint_uncompat() IKeyword_hint_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_hint_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_hint_uncompatContext)
}

func (s *Id_windowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_windowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Id_windowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterId_window(s)
	}
}

func (s *Id_windowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitId_window(s)
	}
}

func (p *SQLv1Antlr4Parser) Id_window() (localctx IId_windowContext) {
	localctx = NewId_windowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 776, SQLv1Antlr4ParserRULE_id_window)
	p.SetState(4320)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4312)
			p.Identifier()
		}

	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4313)
			p.Keyword_compat()
		}

	case SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4314)
			p.Keyword_expr_uncompat()
		}

	case SQLv1Antlr4ParserANY, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserSTREAM:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4315)
			p.Keyword_table_uncompat()
		}

	case SQLv1Antlr4ParserALL, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITHOUT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4316)
			p.Keyword_select_uncompat()
		}

	case SQLv1Antlr4ParserCOLUMN:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4317)
			p.Keyword_alter_uncompat()
		}

	case SQLv1Antlr4ParserCOMPACT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4318)
			p.Keyword_in_uncompat()
		}

	case SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserSCHEMA:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4319)
			p.Keyword_hint_uncompat()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IId_tableContext is an interface to support dynamic dispatch.
type IId_tableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Keyword_compat() IKeyword_compatContext
	Keyword_expr_uncompat() IKeyword_expr_uncompatContext
	Keyword_select_uncompat() IKeyword_select_uncompatContext
	Keyword_in_uncompat() IKeyword_in_uncompatContext
	Keyword_window_uncompat() IKeyword_window_uncompatContext
	Keyword_hint_uncompat() IKeyword_hint_uncompatContext

	// IsId_tableContext differentiates from other interfaces.
	IsId_tableContext()
}

type Id_tableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_tableContext() *Id_tableContext {
	var p = new(Id_tableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_table
	return p
}

func InitEmptyId_tableContext(p *Id_tableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_table
}

func (*Id_tableContext) IsId_tableContext() {}

func NewId_tableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_tableContext {
	var p = new(Id_tableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_table

	return p
}

func (s *Id_tableContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_tableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Id_tableContext) Keyword_compat() IKeyword_compatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_compatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_compatContext)
}

func (s *Id_tableContext) Keyword_expr_uncompat() IKeyword_expr_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_expr_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_expr_uncompatContext)
}

func (s *Id_tableContext) Keyword_select_uncompat() IKeyword_select_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_select_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_select_uncompatContext)
}

func (s *Id_tableContext) Keyword_in_uncompat() IKeyword_in_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_in_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_in_uncompatContext)
}

func (s *Id_tableContext) Keyword_window_uncompat() IKeyword_window_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_window_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_window_uncompatContext)
}

func (s *Id_tableContext) Keyword_hint_uncompat() IKeyword_hint_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_hint_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_hint_uncompatContext)
}

func (s *Id_tableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_tableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Id_tableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterId_table(s)
	}
}

func (s *Id_tableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitId_table(s)
	}
}

func (p *SQLv1Antlr4Parser) Id_table() (localctx IId_tableContext) {
	localctx = NewId_tableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 778, SQLv1Antlr4ParserRULE_id_table)
	p.SetState(4329)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4322)
			p.Identifier()
		}

	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4323)
			p.Keyword_compat()
		}

	case SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4324)
			p.Keyword_expr_uncompat()
		}

	case SQLv1Antlr4ParserALL, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITHOUT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4325)
			p.Keyword_select_uncompat()
		}

	case SQLv1Antlr4ParserCOMPACT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4326)
			p.Keyword_in_uncompat()
		}

	case SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserROWS:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4327)
			p.Keyword_window_uncompat()
		}

	case SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserSCHEMA:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4328)
			p.Keyword_hint_uncompat()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IId_withoutContext is an interface to support dynamic dispatch.
type IId_withoutContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Keyword_compat() IKeyword_compatContext
	Keyword_table_uncompat() IKeyword_table_uncompatContext
	Keyword_alter_uncompat() IKeyword_alter_uncompatContext
	Keyword_in_uncompat() IKeyword_in_uncompatContext
	Keyword_window_uncompat() IKeyword_window_uncompatContext
	Keyword_hint_uncompat() IKeyword_hint_uncompatContext

	// IsId_withoutContext differentiates from other interfaces.
	IsId_withoutContext()
}

type Id_withoutContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_withoutContext() *Id_withoutContext {
	var p = new(Id_withoutContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_without
	return p
}

func InitEmptyId_withoutContext(p *Id_withoutContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_without
}

func (*Id_withoutContext) IsId_withoutContext() {}

func NewId_withoutContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_withoutContext {
	var p = new(Id_withoutContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_without

	return p
}

func (s *Id_withoutContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_withoutContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Id_withoutContext) Keyword_compat() IKeyword_compatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_compatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_compatContext)
}

func (s *Id_withoutContext) Keyword_table_uncompat() IKeyword_table_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_table_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_table_uncompatContext)
}

func (s *Id_withoutContext) Keyword_alter_uncompat() IKeyword_alter_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_alter_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_alter_uncompatContext)
}

func (s *Id_withoutContext) Keyword_in_uncompat() IKeyword_in_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_in_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_in_uncompatContext)
}

func (s *Id_withoutContext) Keyword_window_uncompat() IKeyword_window_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_window_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_window_uncompatContext)
}

func (s *Id_withoutContext) Keyword_hint_uncompat() IKeyword_hint_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_hint_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_hint_uncompatContext)
}

func (s *Id_withoutContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_withoutContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Id_withoutContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterId_without(s)
	}
}

func (s *Id_withoutContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitId_without(s)
	}
}

func (p *SQLv1Antlr4Parser) Id_without() (localctx IId_withoutContext) {
	localctx = NewId_withoutContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 780, SQLv1Antlr4ParserRULE_id_without)
	p.SetState(4338)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4331)
			p.Identifier()
		}

	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4332)
			p.Keyword_compat()
		}

	case SQLv1Antlr4ParserANY, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserSTREAM:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4333)
			p.Keyword_table_uncompat()
		}

	case SQLv1Antlr4ParserCOLUMN:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4334)
			p.Keyword_alter_uncompat()
		}

	case SQLv1Antlr4ParserCOMPACT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4335)
			p.Keyword_in_uncompat()
		}

	case SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserROWS:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4336)
			p.Keyword_window_uncompat()
		}

	case SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserSCHEMA:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4337)
			p.Keyword_hint_uncompat()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IId_hintContext is an interface to support dynamic dispatch.
type IId_hintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Keyword_compat() IKeyword_compatContext
	Keyword_expr_uncompat() IKeyword_expr_uncompatContext
	Keyword_table_uncompat() IKeyword_table_uncompatContext
	Keyword_select_uncompat() IKeyword_select_uncompatContext
	Keyword_alter_uncompat() IKeyword_alter_uncompatContext
	Keyword_in_uncompat() IKeyword_in_uncompatContext
	Keyword_window_uncompat() IKeyword_window_uncompatContext

	// IsId_hintContext differentiates from other interfaces.
	IsId_hintContext()
}

type Id_hintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_hintContext() *Id_hintContext {
	var p = new(Id_hintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_hint
	return p
}

func InitEmptyId_hintContext(p *Id_hintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_hint
}

func (*Id_hintContext) IsId_hintContext() {}

func NewId_hintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_hintContext {
	var p = new(Id_hintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_hint

	return p
}

func (s *Id_hintContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_hintContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Id_hintContext) Keyword_compat() IKeyword_compatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_compatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_compatContext)
}

func (s *Id_hintContext) Keyword_expr_uncompat() IKeyword_expr_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_expr_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_expr_uncompatContext)
}

func (s *Id_hintContext) Keyword_table_uncompat() IKeyword_table_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_table_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_table_uncompatContext)
}

func (s *Id_hintContext) Keyword_select_uncompat() IKeyword_select_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_select_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_select_uncompatContext)
}

func (s *Id_hintContext) Keyword_alter_uncompat() IKeyword_alter_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_alter_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_alter_uncompatContext)
}

func (s *Id_hintContext) Keyword_in_uncompat() IKeyword_in_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_in_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_in_uncompatContext)
}

func (s *Id_hintContext) Keyword_window_uncompat() IKeyword_window_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_window_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_window_uncompatContext)
}

func (s *Id_hintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_hintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Id_hintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterId_hint(s)
	}
}

func (s *Id_hintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitId_hint(s)
	}
}

func (p *SQLv1Antlr4Parser) Id_hint() (localctx IId_hintContext) {
	localctx = NewId_hintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 782, SQLv1Antlr4ParserRULE_id_hint)
	p.SetState(4348)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4340)
			p.Identifier()
		}

	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4341)
			p.Keyword_compat()
		}

	case SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4342)
			p.Keyword_expr_uncompat()
		}

	case SQLv1Antlr4ParserANY, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserSTREAM:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4343)
			p.Keyword_table_uncompat()
		}

	case SQLv1Antlr4ParserALL, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITHOUT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4344)
			p.Keyword_select_uncompat()
		}

	case SQLv1Antlr4ParserCOLUMN:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4345)
			p.Keyword_alter_uncompat()
		}

	case SQLv1Antlr4ParserCOMPACT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4346)
			p.Keyword_in_uncompat()
		}

	case SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserROWS:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4347)
			p.Keyword_window_uncompat()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IId_as_compatContext is an interface to support dynamic dispatch.
type IId_as_compatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Keyword_as_compat() IKeyword_as_compatContext

	// IsId_as_compatContext differentiates from other interfaces.
	IsId_as_compatContext()
}

type Id_as_compatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_as_compatContext() *Id_as_compatContext {
	var p = new(Id_as_compatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_as_compat
	return p
}

func InitEmptyId_as_compatContext(p *Id_as_compatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_as_compat
}

func (*Id_as_compatContext) IsId_as_compatContext() {}

func NewId_as_compatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_as_compatContext {
	var p = new(Id_as_compatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_as_compat

	return p
}

func (s *Id_as_compatContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_as_compatContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Id_as_compatContext) Keyword_as_compat() IKeyword_as_compatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_as_compatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_as_compatContext)
}

func (s *Id_as_compatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_as_compatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Id_as_compatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterId_as_compat(s)
	}
}

func (s *Id_as_compatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitId_as_compat(s)
	}
}

func (p *SQLv1Antlr4Parser) Id_as_compat() (localctx IId_as_compatContext) {
	localctx = NewId_as_compatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 784, SQLv1Antlr4ParserRULE_id_as_compat)
	p.SetState(4352)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4350)
			p.Identifier()
		}

	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4351)
			p.Keyword_as_compat()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAn_idContext is an interface to support dynamic dispatch.
type IAn_idContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id() IIdContext
	STRING_VALUE() antlr.TerminalNode

	// IsAn_idContext differentiates from other interfaces.
	IsAn_idContext()
}

type An_idContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAn_idContext() *An_idContext {
	var p = new(An_idContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id
	return p
}

func InitEmptyAn_idContext(p *An_idContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id
}

func (*An_idContext) IsAn_idContext() {}

func NewAn_idContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *An_idContext {
	var p = new(An_idContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id

	return p
}

func (s *An_idContext) GetParser() antlr.Parser { return s.parser }

func (s *An_idContext) Id() IIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *An_idContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRING_VALUE, 0)
}

func (s *An_idContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *An_idContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *An_idContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAn_id(s)
	}
}

func (s *An_idContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAn_id(s)
	}
}

func (p *SQLv1Antlr4Parser) An_id() (localctx IAn_idContext) {
	localctx = NewAn_idContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 786, SQLv1Antlr4ParserRULE_an_id)
	p.SetState(4356)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALL, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserANY, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSTREAM, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWITHOUT, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4354)
			p.Id()
		}

	case SQLv1Antlr4ParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4355)
			p.Match(SQLv1Antlr4ParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAn_id_or_typeContext is an interface to support dynamic dispatch.
type IAn_id_or_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_or_type() IId_or_typeContext
	STRING_VALUE() antlr.TerminalNode

	// IsAn_id_or_typeContext differentiates from other interfaces.
	IsAn_id_or_typeContext()
}

type An_id_or_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAn_id_or_typeContext() *An_id_or_typeContext {
	var p = new(An_id_or_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_or_type
	return p
}

func InitEmptyAn_id_or_typeContext(p *An_id_or_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_or_type
}

func (*An_id_or_typeContext) IsAn_id_or_typeContext() {}

func NewAn_id_or_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *An_id_or_typeContext {
	var p = new(An_id_or_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_or_type

	return p
}

func (s *An_id_or_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *An_id_or_typeContext) Id_or_type() IId_or_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_or_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_or_typeContext)
}

func (s *An_id_or_typeContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRING_VALUE, 0)
}

func (s *An_id_or_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *An_id_or_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *An_id_or_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAn_id_or_type(s)
	}
}

func (s *An_id_or_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAn_id_or_type(s)
	}
}

func (p *SQLv1Antlr4Parser) An_id_or_type() (localctx IAn_id_or_typeContext) {
	localctx = NewAn_id_or_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 788, SQLv1Antlr4ParserRULE_an_id_or_type)
	p.SetState(4360)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALL, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserANY, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCALLABLE, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDICT, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserENUM, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFLOW, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserLIST, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOPTIONAL, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESOURCE, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSET, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSTREAM, SQLv1Antlr4ParserSTRUCT, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTAGGED, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTUPLE, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVARIANT, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWITHOUT, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4358)
			p.Id_or_type()
		}

	case SQLv1Antlr4ParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4359)
			p.Match(SQLv1Antlr4ParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAn_id_schemaContext is an interface to support dynamic dispatch.
type IAn_id_schemaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_schema() IId_schemaContext
	STRING_VALUE() antlr.TerminalNode

	// IsAn_id_schemaContext differentiates from other interfaces.
	IsAn_id_schemaContext()
}

type An_id_schemaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAn_id_schemaContext() *An_id_schemaContext {
	var p = new(An_id_schemaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_schema
	return p
}

func InitEmptyAn_id_schemaContext(p *An_id_schemaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_schema
}

func (*An_id_schemaContext) IsAn_id_schemaContext() {}

func NewAn_id_schemaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *An_id_schemaContext {
	var p = new(An_id_schemaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_schema

	return p
}

func (s *An_id_schemaContext) GetParser() antlr.Parser { return s.parser }

func (s *An_id_schemaContext) Id_schema() IId_schemaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_schemaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_schemaContext)
}

func (s *An_id_schemaContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRING_VALUE, 0)
}

func (s *An_id_schemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *An_id_schemaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *An_id_schemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAn_id_schema(s)
	}
}

func (s *An_id_schemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAn_id_schema(s)
	}
}

func (p *SQLv1Antlr4Parser) An_id_schema() (localctx IAn_id_schemaContext) {
	localctx = NewAn_id_schemaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 790, SQLv1Antlr4ParserRULE_an_id_schema)
	p.SetState(4364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALL, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWITHOUT, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4362)
			p.Id_schema()
		}

	case SQLv1Antlr4ParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4363)
			p.Match(SQLv1Antlr4ParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAn_id_exprContext is an interface to support dynamic dispatch.
type IAn_id_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_expr() IId_exprContext
	STRING_VALUE() antlr.TerminalNode

	// IsAn_id_exprContext differentiates from other interfaces.
	IsAn_id_exprContext()
}

type An_id_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAn_id_exprContext() *An_id_exprContext {
	var p = new(An_id_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_expr
	return p
}

func InitEmptyAn_id_exprContext(p *An_id_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_expr
}

func (*An_id_exprContext) IsAn_id_exprContext() {}

func NewAn_id_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *An_id_exprContext {
	var p = new(An_id_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_expr

	return p
}

func (s *An_id_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *An_id_exprContext) Id_expr() IId_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_exprContext)
}

func (s *An_id_exprContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRING_VALUE, 0)
}

func (s *An_id_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *An_id_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *An_id_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAn_id_expr(s)
	}
}

func (s *An_id_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAn_id_expr(s)
	}
}

func (p *SQLv1Antlr4Parser) An_id_expr() (localctx IAn_id_exprContext) {
	localctx = NewAn_id_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 792, SQLv1Antlr4ParserRULE_an_id_expr)
	p.SetState(4368)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4366)
			p.Id_expr()
		}

	case SQLv1Antlr4ParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4367)
			p.Match(SQLv1Antlr4ParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAn_id_expr_inContext is an interface to support dynamic dispatch.
type IAn_id_expr_inContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_expr_in() IId_expr_inContext
	STRING_VALUE() antlr.TerminalNode

	// IsAn_id_expr_inContext differentiates from other interfaces.
	IsAn_id_expr_inContext()
}

type An_id_expr_inContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAn_id_expr_inContext() *An_id_expr_inContext {
	var p = new(An_id_expr_inContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_expr_in
	return p
}

func InitEmptyAn_id_expr_inContext(p *An_id_expr_inContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_expr_in
}

func (*An_id_expr_inContext) IsAn_id_expr_inContext() {}

func NewAn_id_expr_inContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *An_id_expr_inContext {
	var p = new(An_id_expr_inContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_expr_in

	return p
}

func (s *An_id_expr_inContext) GetParser() antlr.Parser { return s.parser }

func (s *An_id_expr_inContext) Id_expr_in() IId_expr_inContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_expr_inContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_expr_inContext)
}

func (s *An_id_expr_inContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRING_VALUE, 0)
}

func (s *An_id_expr_inContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *An_id_expr_inContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *An_id_expr_inContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAn_id_expr_in(s)
	}
}

func (s *An_id_expr_inContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAn_id_expr_in(s)
	}
}

func (p *SQLv1Antlr4Parser) An_id_expr_in() (localctx IAn_id_expr_inContext) {
	localctx = NewAn_id_expr_inContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 794, SQLv1Antlr4ParserRULE_an_id_expr_in)
	p.SetState(4372)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4370)
			p.Id_expr_in()
		}

	case SQLv1Antlr4ParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4371)
			p.Match(SQLv1Antlr4ParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAn_id_windowContext is an interface to support dynamic dispatch.
type IAn_id_windowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_window() IId_windowContext
	STRING_VALUE() antlr.TerminalNode

	// IsAn_id_windowContext differentiates from other interfaces.
	IsAn_id_windowContext()
}

type An_id_windowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAn_id_windowContext() *An_id_windowContext {
	var p = new(An_id_windowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_window
	return p
}

func InitEmptyAn_id_windowContext(p *An_id_windowContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_window
}

func (*An_id_windowContext) IsAn_id_windowContext() {}

func NewAn_id_windowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *An_id_windowContext {
	var p = new(An_id_windowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_window

	return p
}

func (s *An_id_windowContext) GetParser() antlr.Parser { return s.parser }

func (s *An_id_windowContext) Id_window() IId_windowContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_windowContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_windowContext)
}

func (s *An_id_windowContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRING_VALUE, 0)
}

func (s *An_id_windowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *An_id_windowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *An_id_windowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAn_id_window(s)
	}
}

func (s *An_id_windowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAn_id_window(s)
	}
}

func (p *SQLv1Antlr4Parser) An_id_window() (localctx IAn_id_windowContext) {
	localctx = NewAn_id_windowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 796, SQLv1Antlr4ParserRULE_an_id_window)
	p.SetState(4376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALL, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserANY, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSTREAM, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWITHOUT, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4374)
			p.Id_window()
		}

	case SQLv1Antlr4ParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4375)
			p.Match(SQLv1Antlr4ParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAn_id_tableContext is an interface to support dynamic dispatch.
type IAn_id_tableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_table() IId_tableContext
	STRING_VALUE() antlr.TerminalNode

	// IsAn_id_tableContext differentiates from other interfaces.
	IsAn_id_tableContext()
}

type An_id_tableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAn_id_tableContext() *An_id_tableContext {
	var p = new(An_id_tableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_table
	return p
}

func InitEmptyAn_id_tableContext(p *An_id_tableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_table
}

func (*An_id_tableContext) IsAn_id_tableContext() {}

func NewAn_id_tableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *An_id_tableContext {
	var p = new(An_id_tableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_table

	return p
}

func (s *An_id_tableContext) GetParser() antlr.Parser { return s.parser }

func (s *An_id_tableContext) Id_table() IId_tableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_tableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_tableContext)
}

func (s *An_id_tableContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRING_VALUE, 0)
}

func (s *An_id_tableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *An_id_tableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *An_id_tableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAn_id_table(s)
	}
}

func (s *An_id_tableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAn_id_table(s)
	}
}

func (p *SQLv1Antlr4Parser) An_id_table() (localctx IAn_id_tableContext) {
	localctx = NewAn_id_tableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 798, SQLv1Antlr4ParserRULE_an_id_table)
	p.SetState(4380)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALL, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWITHOUT, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4378)
			p.Id_table()
		}

	case SQLv1Antlr4ParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4379)
			p.Match(SQLv1Antlr4ParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAn_id_withoutContext is an interface to support dynamic dispatch.
type IAn_id_withoutContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_without() IId_withoutContext
	STRING_VALUE() antlr.TerminalNode

	// IsAn_id_withoutContext differentiates from other interfaces.
	IsAn_id_withoutContext()
}

type An_id_withoutContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAn_id_withoutContext() *An_id_withoutContext {
	var p = new(An_id_withoutContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_without
	return p
}

func InitEmptyAn_id_withoutContext(p *An_id_withoutContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_without
}

func (*An_id_withoutContext) IsAn_id_withoutContext() {}

func NewAn_id_withoutContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *An_id_withoutContext {
	var p = new(An_id_withoutContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_without

	return p
}

func (s *An_id_withoutContext) GetParser() antlr.Parser { return s.parser }

func (s *An_id_withoutContext) Id_without() IId_withoutContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_withoutContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_withoutContext)
}

func (s *An_id_withoutContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRING_VALUE, 0)
}

func (s *An_id_withoutContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *An_id_withoutContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *An_id_withoutContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAn_id_without(s)
	}
}

func (s *An_id_withoutContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAn_id_without(s)
	}
}

func (p *SQLv1Antlr4Parser) An_id_without() (localctx IAn_id_withoutContext) {
	localctx = NewAn_id_withoutContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 800, SQLv1Antlr4ParserRULE_an_id_without)
	p.SetState(4384)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserANY, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSTREAM, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4382)
			p.Id_without()
		}

	case SQLv1Antlr4ParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4383)
			p.Match(SQLv1Antlr4ParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAn_id_hintContext is an interface to support dynamic dispatch.
type IAn_id_hintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_hint() IId_hintContext
	STRING_VALUE() antlr.TerminalNode

	// IsAn_id_hintContext differentiates from other interfaces.
	IsAn_id_hintContext()
}

type An_id_hintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAn_id_hintContext() *An_id_hintContext {
	var p = new(An_id_hintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_hint
	return p
}

func InitEmptyAn_id_hintContext(p *An_id_hintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_hint
}

func (*An_id_hintContext) IsAn_id_hintContext() {}

func NewAn_id_hintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *An_id_hintContext {
	var p = new(An_id_hintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_hint

	return p
}

func (s *An_id_hintContext) GetParser() antlr.Parser { return s.parser }

func (s *An_id_hintContext) Id_hint() IId_hintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_hintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_hintContext)
}

func (s *An_id_hintContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRING_VALUE, 0)
}

func (s *An_id_hintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *An_id_hintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *An_id_hintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAn_id_hint(s)
	}
}

func (s *An_id_hintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAn_id_hint(s)
	}
}

func (p *SQLv1Antlr4Parser) An_id_hint() (localctx IAn_id_hintContext) {
	localctx = NewAn_id_hintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 802, SQLv1Antlr4ParserRULE_an_id_hint)
	p.SetState(4388)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALL, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserANY, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSTREAM, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWITHOUT, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4386)
			p.Id_hint()
		}

	case SQLv1Antlr4ParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4387)
			p.Match(SQLv1Antlr4ParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAn_id_pureContext is an interface to support dynamic dispatch.
type IAn_id_pureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	STRING_VALUE() antlr.TerminalNode

	// IsAn_id_pureContext differentiates from other interfaces.
	IsAn_id_pureContext()
}

type An_id_pureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAn_id_pureContext() *An_id_pureContext {
	var p = new(An_id_pureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_pure
	return p
}

func InitEmptyAn_id_pureContext(p *An_id_pureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_pure
}

func (*An_id_pureContext) IsAn_id_pureContext() {}

func NewAn_id_pureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *An_id_pureContext {
	var p = new(An_id_pureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_pure

	return p
}

func (s *An_id_pureContext) GetParser() antlr.Parser { return s.parser }

func (s *An_id_pureContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *An_id_pureContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRING_VALUE, 0)
}

func (s *An_id_pureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *An_id_pureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *An_id_pureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAn_id_pure(s)
	}
}

func (s *An_id_pureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAn_id_pure(s)
	}
}

func (p *SQLv1Antlr4Parser) An_id_pure() (localctx IAn_id_pureContext) {
	localctx = NewAn_id_pureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 804, SQLv1Antlr4ParserRULE_an_id_pure)
	p.SetState(4392)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4390)
			p.Identifier()
		}

	case SQLv1Antlr4ParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4391)
			p.Match(SQLv1Antlr4ParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAn_id_as_compatContext is an interface to support dynamic dispatch.
type IAn_id_as_compatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_as_compat() IId_as_compatContext
	STRING_VALUE() antlr.TerminalNode

	// IsAn_id_as_compatContext differentiates from other interfaces.
	IsAn_id_as_compatContext()
}

type An_id_as_compatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAn_id_as_compatContext() *An_id_as_compatContext {
	var p = new(An_id_as_compatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_as_compat
	return p
}

func InitEmptyAn_id_as_compatContext(p *An_id_as_compatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_as_compat
}

func (*An_id_as_compatContext) IsAn_id_as_compatContext() {}

func NewAn_id_as_compatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *An_id_as_compatContext {
	var p = new(An_id_as_compatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_an_id_as_compat

	return p
}

func (s *An_id_as_compatContext) GetParser() antlr.Parser { return s.parser }

func (s *An_id_as_compatContext) Id_as_compat() IId_as_compatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_as_compatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_as_compatContext)
}

func (s *An_id_as_compatContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRING_VALUE, 0)
}

func (s *An_id_as_compatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *An_id_as_compatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *An_id_as_compatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterAn_id_as_compat(s)
	}
}

func (s *An_id_as_compatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitAn_id_as_compat(s)
	}
}

func (p *SQLv1Antlr4Parser) An_id_as_compat() (localctx IAn_id_as_compatContext) {
	localctx = NewAn_id_as_compatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 806, SQLv1Antlr4ParserRULE_an_id_as_compat)
	p.SetState(4396)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4394)
			p.Id_as_compat()
		}

	case SQLv1Antlr4ParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4395)
			p.Match(SQLv1Antlr4ParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IView_nameContext is an interface to support dynamic dispatch.
type IView_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext
	PRIMARY() antlr.TerminalNode
	KEY() antlr.TerminalNode

	// IsView_nameContext differentiates from other interfaces.
	IsView_nameContext()
}

type View_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyView_nameContext() *View_nameContext {
	var p = new(View_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_view_name
	return p
}

func InitEmptyView_nameContext(p *View_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_view_name
}

func (*View_nameContext) IsView_nameContext() {}

func NewView_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *View_nameContext {
	var p = new(View_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_view_name

	return p
}

func (s *View_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *View_nameContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *View_nameContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPRIMARY, 0)
}

func (s *View_nameContext) KEY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserKEY, 0)
}

func (s *View_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *View_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *View_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterView_name(s)
	}
}

func (s *View_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitView_name(s)
	}
}

func (p *SQLv1Antlr4Parser) View_name() (localctx IView_nameContext) {
	localctx = NewView_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 808, SQLv1Antlr4ParserRULE_view_name)
	p.SetState(4401)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 481, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4398)
			p.An_id()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4399)
			p.Match(SQLv1Antlr4ParserPRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4400)
			p.Match(SQLv1Antlr4ParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_id_prefixContext is an interface to support dynamic dispatch.
type IOpt_id_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id() IAn_idContext
	DOT() antlr.TerminalNode

	// IsOpt_id_prefixContext differentiates from other interfaces.
	IsOpt_id_prefixContext()
}

type Opt_id_prefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_id_prefixContext() *Opt_id_prefixContext {
	var p = new(Opt_id_prefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_opt_id_prefix
	return p
}

func InitEmptyOpt_id_prefixContext(p *Opt_id_prefixContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_opt_id_prefix
}

func (*Opt_id_prefixContext) IsOpt_id_prefixContext() {}

func NewOpt_id_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_id_prefixContext {
	var p = new(Opt_id_prefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_opt_id_prefix

	return p
}

func (s *Opt_id_prefixContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_id_prefixContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Opt_id_prefixContext) DOT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDOT, 0)
}

func (s *Opt_id_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_id_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_id_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterOpt_id_prefix(s)
	}
}

func (s *Opt_id_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitOpt_id_prefix(s)
	}
}

func (p *SQLv1Antlr4Parser) Opt_id_prefix() (localctx IOpt_id_prefixContext) {
	localctx = NewOpt_id_prefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 810, SQLv1Antlr4ParserRULE_opt_id_prefix)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4406)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 482, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4403)
			p.An_id()
		}
		{
			p.SetState(4404)
			p.Match(SQLv1Antlr4ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICluster_exprContext is an interface to support dynamic dispatch.
type ICluster_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Pure_column_or_named() IPure_column_or_namedContext
	ASTERISK() antlr.TerminalNode
	An_id() IAn_idContext
	COLON() antlr.TerminalNode

	// IsCluster_exprContext differentiates from other interfaces.
	IsCluster_exprContext()
}

type Cluster_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCluster_exprContext() *Cluster_exprContext {
	var p = new(Cluster_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_cluster_expr
	return p
}

func InitEmptyCluster_exprContext(p *Cluster_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_cluster_expr
}

func (*Cluster_exprContext) IsCluster_exprContext() {}

func NewCluster_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cluster_exprContext {
	var p = new(Cluster_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_cluster_expr

	return p
}

func (s *Cluster_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Cluster_exprContext) Pure_column_or_named() IPure_column_or_namedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPure_column_or_namedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPure_column_or_namedContext)
}

func (s *Cluster_exprContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserASTERISK, 0)
}

func (s *Cluster_exprContext) An_id() IAn_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_idContext)
}

func (s *Cluster_exprContext) COLON() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOLON, 0)
}

func (s *Cluster_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cluster_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cluster_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterCluster_expr(s)
	}
}

func (s *Cluster_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitCluster_expr(s)
	}
}

func (p *SQLv1Antlr4Parser) Cluster_expr() (localctx ICluster_exprContext) {
	localctx = NewCluster_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 812, SQLv1Antlr4ParserRULE_cluster_expr)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4411)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 483, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4408)
			p.An_id()
		}
		{
			p.SetState(4409)
			p.Match(SQLv1Antlr4ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4415)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserDOLLAR, SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALL, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserANY, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSTREAM, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWITHOUT, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserSTRING_VALUE, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		{
			p.SetState(4413)
			p.Pure_column_or_named()
		}

	case SQLv1Antlr4ParserASTERISK:
		{
			p.SetState(4414)
			p.Match(SQLv1Antlr4ParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IId_or_typeContext is an interface to support dynamic dispatch.
type IId_or_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id() IIdContext
	Type_id() IType_idContext

	// IsId_or_typeContext differentiates from other interfaces.
	IsId_or_typeContext()
}

type Id_or_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_or_typeContext() *Id_or_typeContext {
	var p = new(Id_or_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_or_type
	return p
}

func InitEmptyId_or_typeContext(p *Id_or_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_or_type
}

func (*Id_or_typeContext) IsId_or_typeContext() {}

func NewId_or_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_or_typeContext {
	var p = new(Id_or_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_or_type

	return p
}

func (s *Id_or_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_or_typeContext) Id() IIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *Id_or_typeContext) Type_id() IType_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_idContext)
}

func (s *Id_or_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_or_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Id_or_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterId_or_type(s)
	}
}

func (s *Id_or_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitId_or_type(s)
	}
}

func (p *SQLv1Antlr4Parser) Id_or_type() (localctx IId_or_typeContext) {
	localctx = NewId_or_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 814, SQLv1Antlr4ParserRULE_id_or_type)
	p.SetState(4419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALL, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserANY, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMN, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSTREAM, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWITHOUT, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4417)
			p.Id()
		}

	case SQLv1Antlr4ParserCALLABLE, SQLv1Antlr4ParserDICT, SQLv1Antlr4ParserENUM, SQLv1Antlr4ParserFLOW, SQLv1Antlr4ParserLIST, SQLv1Antlr4ParserOPTIONAL, SQLv1Antlr4ParserRESOURCE, SQLv1Antlr4ParserSET, SQLv1Antlr4ParserSTRUCT, SQLv1Antlr4ParserTAGGED, SQLv1Antlr4ParserTUPLE, SQLv1Antlr4ParserVARIANT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4418)
			p.Type_id()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_id_prefix_or_typeContext is an interface to support dynamic dispatch.
type IOpt_id_prefix_or_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id_or_type() IAn_id_or_typeContext
	DOT() antlr.TerminalNode

	// IsOpt_id_prefix_or_typeContext differentiates from other interfaces.
	IsOpt_id_prefix_or_typeContext()
}

type Opt_id_prefix_or_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_id_prefix_or_typeContext() *Opt_id_prefix_or_typeContext {
	var p = new(Opt_id_prefix_or_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_opt_id_prefix_or_type
	return p
}

func InitEmptyOpt_id_prefix_or_typeContext(p *Opt_id_prefix_or_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_opt_id_prefix_or_type
}

func (*Opt_id_prefix_or_typeContext) IsOpt_id_prefix_or_typeContext() {}

func NewOpt_id_prefix_or_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_id_prefix_or_typeContext {
	var p = new(Opt_id_prefix_or_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_opt_id_prefix_or_type

	return p
}

func (s *Opt_id_prefix_or_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_id_prefix_or_typeContext) An_id_or_type() IAn_id_or_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_or_typeContext)
}

func (s *Opt_id_prefix_or_typeContext) DOT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDOT, 0)
}

func (s *Opt_id_prefix_or_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_id_prefix_or_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_id_prefix_or_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterOpt_id_prefix_or_type(s)
	}
}

func (s *Opt_id_prefix_or_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitOpt_id_prefix_or_type(s)
	}
}

func (p *SQLv1Antlr4Parser) Opt_id_prefix_or_type() (localctx IOpt_id_prefix_or_typeContext) {
	localctx = NewOpt_id_prefix_or_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 816, SQLv1Antlr4ParserRULE_opt_id_prefix_or_type)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4424)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 486, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4421)
			p.An_id_or_type()
		}
		{
			p.SetState(4422)
			p.Match(SQLv1Antlr4ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IId_or_atContext is an interface to support dynamic dispatch.
type IId_or_atContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id_or_type() IAn_id_or_typeContext
	COMMAT() antlr.TerminalNode

	// IsId_or_atContext differentiates from other interfaces.
	IsId_or_atContext()
}

type Id_or_atContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_or_atContext() *Id_or_atContext {
	var p = new(Id_or_atContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_or_at
	return p
}

func InitEmptyId_or_atContext(p *Id_or_atContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_or_at
}

func (*Id_or_atContext) IsId_or_atContext() {}

func NewId_or_atContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_or_atContext {
	var p = new(Id_or_atContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_or_at

	return p
}

func (s *Id_or_atContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_or_atContext) An_id_or_type() IAn_id_or_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_or_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_or_typeContext)
}

func (s *Id_or_atContext) COMMAT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMAT, 0)
}

func (s *Id_or_atContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_or_atContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Id_or_atContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterId_or_at(s)
	}
}

func (s *Id_or_atContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitId_or_at(s)
	}
}

func (p *SQLv1Antlr4Parser) Id_or_at() (localctx IId_or_atContext) {
	localctx = NewId_or_atContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 818, SQLv1Antlr4ParserRULE_id_or_at)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4427)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserCOMMAT {
		{
			p.SetState(4426)
			p.Match(SQLv1Antlr4ParserCOMMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4429)
		p.An_id_or_type()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IId_table_or_typeContext is an interface to support dynamic dispatch.
type IId_table_or_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	An_id_table() IAn_id_tableContext
	Type_id() IType_idContext

	// IsId_table_or_typeContext differentiates from other interfaces.
	IsId_table_or_typeContext()
}

type Id_table_or_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_table_or_typeContext() *Id_table_or_typeContext {
	var p = new(Id_table_or_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_table_or_type
	return p
}

func InitEmptyId_table_or_typeContext(p *Id_table_or_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_table_or_type
}

func (*Id_table_or_typeContext) IsId_table_or_typeContext() {}

func NewId_table_or_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_table_or_typeContext {
	var p = new(Id_table_or_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_table_or_type

	return p
}

func (s *Id_table_or_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_table_or_typeContext) An_id_table() IAn_id_tableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAn_id_tableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAn_id_tableContext)
}

func (s *Id_table_or_typeContext) Type_id() IType_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_idContext)
}

func (s *Id_table_or_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_table_or_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Id_table_or_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterId_table_or_type(s)
	}
}

func (s *Id_table_or_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitId_table_or_type(s)
	}
}

func (p *SQLv1Antlr4Parser) Id_table_or_type() (localctx IId_table_or_typeContext) {
	localctx = NewId_table_or_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 820, SQLv1Antlr4ParserRULE_id_table_or_type)
	p.SetState(4433)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALL, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCOMPACT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserROWS, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSCHEMA, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWITHOUT, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR, SQLv1Antlr4ParserSTRING_VALUE, SQLv1Antlr4ParserID_PLAIN, SQLv1Antlr4ParserID_QUOTED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4431)
			p.An_id_table()
		}

	case SQLv1Antlr4ParserCALLABLE, SQLv1Antlr4ParserDICT, SQLv1Antlr4ParserENUM, SQLv1Antlr4ParserFLOW, SQLv1Antlr4ParserLIST, SQLv1Antlr4ParserOPTIONAL, SQLv1Antlr4ParserRESOURCE, SQLv1Antlr4ParserSET, SQLv1Antlr4ParserSTRUCT, SQLv1Antlr4ParserTAGGED, SQLv1Antlr4ParserTUPLE, SQLv1Antlr4ParserVARIANT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4432)
			p.Type_id()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IId_table_or_atContext is an interface to support dynamic dispatch.
type IId_table_or_atContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id_table_or_type() IId_table_or_typeContext
	COMMAT() antlr.TerminalNode

	// IsId_table_or_atContext differentiates from other interfaces.
	IsId_table_or_atContext()
}

type Id_table_or_atContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_table_or_atContext() *Id_table_or_atContext {
	var p = new(Id_table_or_atContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_table_or_at
	return p
}

func InitEmptyId_table_or_atContext(p *Id_table_or_atContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_table_or_at
}

func (*Id_table_or_atContext) IsId_table_or_atContext() {}

func NewId_table_or_atContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_table_or_atContext {
	var p = new(Id_table_or_atContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_id_table_or_at

	return p
}

func (s *Id_table_or_atContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_table_or_atContext) Id_table_or_type() IId_table_or_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_table_or_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_table_or_typeContext)
}

func (s *Id_table_or_atContext) COMMAT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMAT, 0)
}

func (s *Id_table_or_atContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_table_or_atContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Id_table_or_atContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterId_table_or_at(s)
	}
}

func (s *Id_table_or_atContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitId_table_or_at(s)
	}
}

func (p *SQLv1Antlr4Parser) Id_table_or_at() (localctx IId_table_or_atContext) {
	localctx = NewId_table_or_atContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 822, SQLv1Antlr4ParserRULE_id_table_or_at)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4436)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLv1Antlr4ParserCOMMAT {
		{
			p.SetState(4435)
			p.Match(SQLv1Antlr4ParserCOMMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4438)
		p.Id_table_or_type()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeywordContext is an interface to support dynamic dispatch.
type IKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Keyword_compat() IKeyword_compatContext
	Keyword_expr_uncompat() IKeyword_expr_uncompatContext
	Keyword_table_uncompat() IKeyword_table_uncompatContext
	Keyword_select_uncompat() IKeyword_select_uncompatContext
	Keyword_alter_uncompat() IKeyword_alter_uncompatContext
	Keyword_in_uncompat() IKeyword_in_uncompatContext
	Keyword_window_uncompat() IKeyword_window_uncompatContext
	Keyword_hint_uncompat() IKeyword_hint_uncompatContext

	// IsKeywordContext differentiates from other interfaces.
	IsKeywordContext()
}

type KeywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordContext() *KeywordContext {
	var p = new(KeywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword
	return p
}

func InitEmptyKeywordContext(p *KeywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword
}

func (*KeywordContext) IsKeywordContext() {}

func NewKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordContext {
	var p = new(KeywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword

	return p
}

func (s *KeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordContext) Keyword_compat() IKeyword_compatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_compatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_compatContext)
}

func (s *KeywordContext) Keyword_expr_uncompat() IKeyword_expr_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_expr_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_expr_uncompatContext)
}

func (s *KeywordContext) Keyword_table_uncompat() IKeyword_table_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_table_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_table_uncompatContext)
}

func (s *KeywordContext) Keyword_select_uncompat() IKeyword_select_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_select_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_select_uncompatContext)
}

func (s *KeywordContext) Keyword_alter_uncompat() IKeyword_alter_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_alter_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_alter_uncompatContext)
}

func (s *KeywordContext) Keyword_in_uncompat() IKeyword_in_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_in_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_in_uncompatContext)
}

func (s *KeywordContext) Keyword_window_uncompat() IKeyword_window_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_window_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_window_uncompatContext)
}

func (s *KeywordContext) Keyword_hint_uncompat() IKeyword_hint_uncompatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_hint_uncompatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_hint_uncompatContext)
}

func (s *KeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterKeyword(s)
	}
}

func (s *KeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitKeyword(s)
	}
}

func (p *SQLv1Antlr4Parser) Keyword() (localctx IKeywordContext) {
	localctx = NewKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 824, SQLv1Antlr4ParserRULE_keyword)
	p.SetState(4448)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLv1Antlr4ParserABORT, SQLv1Antlr4ParserACTION, SQLv1Antlr4ParserADD, SQLv1Antlr4ParserAFTER, SQLv1Antlr4ParserALTER, SQLv1Antlr4ParserANALYZE, SQLv1Antlr4ParserAND, SQLv1Antlr4ParserANSI, SQLv1Antlr4ParserARRAY, SQLv1Antlr4ParserASC, SQLv1Antlr4ParserASYNC, SQLv1Antlr4ParserAT, SQLv1Antlr4ParserATTACH, SQLv1Antlr4ParserATTRIBUTES, SQLv1Antlr4ParserAUTOINCREMENT, SQLv1Antlr4ParserBACKUP, SQLv1Antlr4ParserCOLLECTION, SQLv1Antlr4ParserBEFORE, SQLv1Antlr4ParserBEGIN, SQLv1Antlr4ParserBERNOULLI, SQLv1Antlr4ParserBY, SQLv1Antlr4ParserCASCADE, SQLv1Antlr4ParserCHANGEFEED, SQLv1Antlr4ParserCHECK, SQLv1Antlr4ParserCLASSIFIER, SQLv1Antlr4ParserCOLLATE, SQLv1Antlr4ParserCOMMIT, SQLv1Antlr4ParserCONDITIONAL, SQLv1Antlr4ParserCONFLICT, SQLv1Antlr4ParserCONNECT, SQLv1Antlr4ParserCONSTRAINT, SQLv1Antlr4ParserCONSUMER, SQLv1Antlr4ParserCOVER, SQLv1Antlr4ParserCREATE, SQLv1Antlr4ParserCROSS, SQLv1Antlr4ParserCURRENT, SQLv1Antlr4ParserDATA, SQLv1Antlr4ParserDATABASE, SQLv1Antlr4ParserDECIMAL, SQLv1Antlr4ParserDECLARE, SQLv1Antlr4ParserDEFAULT, SQLv1Antlr4ParserDEFERRABLE, SQLv1Antlr4ParserDEFERRED, SQLv1Antlr4ParserDEFINE, SQLv1Antlr4ParserDELETE, SQLv1Antlr4ParserDESC, SQLv1Antlr4ParserDESCRIBE, SQLv1Antlr4ParserDETACH, SQLv1Antlr4ParserDIRECTORY, SQLv1Antlr4ParserDISABLE, SQLv1Antlr4ParserDISCARD, SQLv1Antlr4ParserDO, SQLv1Antlr4ParserDROP, SQLv1Antlr4ParserEACH, SQLv1Antlr4ParserELSE, SQLv1Antlr4ParserEMPTY, SQLv1Antlr4ParserENCRYPTED, SQLv1Antlr4ParserEND, SQLv1Antlr4ParserERROR, SQLv1Antlr4ParserESCAPE, SQLv1Antlr4ParserEVALUATE, SQLv1Antlr4ParserEXCLUDE, SQLv1Antlr4ParserEXCLUSION, SQLv1Antlr4ParserEXCLUSIVE, SQLv1Antlr4ParserEXPLAIN, SQLv1Antlr4ParserEXPORT, SQLv1Antlr4ParserEXTERNAL, SQLv1Antlr4ParserFAIL, SQLv1Antlr4ParserFAMILY, SQLv1Antlr4ParserFILTER, SQLv1Antlr4ParserFIRST, SQLv1Antlr4ParserFLATTEN, SQLv1Antlr4ParserFOLLOWING, SQLv1Antlr4ParserFOR, SQLv1Antlr4ParserFOREIGN, SQLv1Antlr4ParserFUNCTION, SQLv1Antlr4ParserGLOB, SQLv1Antlr4ParserGRANT, SQLv1Antlr4ParserGROUP, SQLv1Antlr4ParserGROUPING, SQLv1Antlr4ParserHASH, SQLv1Antlr4ParserIF, SQLv1Antlr4ParserIGNORE, SQLv1Antlr4ParserILIKE, SQLv1Antlr4ParserIMMEDIATE, SQLv1Antlr4ParserIMPORT, SQLv1Antlr4ParserIN, SQLv1Antlr4ParserINCREMENTAL, SQLv1Antlr4ParserINDEX, SQLv1Antlr4ParserINDEXED, SQLv1Antlr4ParserINHERITS, SQLv1Antlr4ParserINITIAL, SQLv1Antlr4ParserINITIALLY, SQLv1Antlr4ParserINNER, SQLv1Antlr4ParserINSERT, SQLv1Antlr4ParserINSTEAD, SQLv1Antlr4ParserINTO, SQLv1Antlr4ParserIS, SQLv1Antlr4ParserISNULL, SQLv1Antlr4ParserJOIN, SQLv1Antlr4ParserKEY, SQLv1Antlr4ParserLAST, SQLv1Antlr4ParserLEFT, SQLv1Antlr4ParserLEGACY, SQLv1Antlr4ParserLIKE, SQLv1Antlr4ParserMANAGE, SQLv1Antlr4ParserMATCH, SQLv1Antlr4ParserMATCHES, SQLv1Antlr4ParserMATCH_RECOGNIZE, SQLv1Antlr4ParserMEASURES, SQLv1Antlr4ParserMICROSECONDS, SQLv1Antlr4ParserMILLISECONDS, SQLv1Antlr4ParserMODIFY, SQLv1Antlr4ParserNANOSECONDS, SQLv1Antlr4ParserNATURAL, SQLv1Antlr4ParserNEXT, SQLv1Antlr4ParserNO, SQLv1Antlr4ParserNOTNULL, SQLv1Antlr4ParserNULLS, SQLv1Antlr4ParserOBJECT, SQLv1Antlr4ParserOF, SQLv1Antlr4ParserOFFSET, SQLv1Antlr4ParserOMIT, SQLv1Antlr4ParserON, SQLv1Antlr4ParserONE, SQLv1Antlr4ParserONLY, SQLv1Antlr4ParserOPTION, SQLv1Antlr4ParserOR, SQLv1Antlr4ParserORDER, SQLv1Antlr4ParserOTHERS, SQLv1Antlr4ParserOUTER, SQLv1Antlr4ParserOVER, SQLv1Antlr4ParserPARALLEL, SQLv1Antlr4ParserPARTITION, SQLv1Antlr4ParserPASSING, SQLv1Antlr4ParserPASSWORD, SQLv1Antlr4ParserPAST, SQLv1Antlr4ParserPATTERN, SQLv1Antlr4ParserPER, SQLv1Antlr4ParserPERMUTE, SQLv1Antlr4ParserPLAN, SQLv1Antlr4ParserPOOL, SQLv1Antlr4ParserPRAGMA, SQLv1Antlr4ParserPRECEDING, SQLv1Antlr4ParserPRESORT, SQLv1Antlr4ParserPRIMARY, SQLv1Antlr4ParserPRIVILEGES, SQLv1Antlr4ParserQUEUE, SQLv1Antlr4ParserRAISE, SQLv1Antlr4ParserREFERENCES, SQLv1Antlr4ParserREGEXP, SQLv1Antlr4ParserREINDEX, SQLv1Antlr4ParserRELEASE, SQLv1Antlr4ParserREMOVE, SQLv1Antlr4ParserRENAME, SQLv1Antlr4ParserREPLACE, SQLv1Antlr4ParserREPLICATION, SQLv1Antlr4ParserRESET, SQLv1Antlr4ParserRESPECT, SQLv1Antlr4ParserRESTORE, SQLv1Antlr4ParserRESTRICT, SQLv1Antlr4ParserRESULT, SQLv1Antlr4ParserREVERT, SQLv1Antlr4ParserREVOKE, SQLv1Antlr4ParserRIGHT, SQLv1Antlr4ParserRLIKE, SQLv1Antlr4ParserROLLBACK, SQLv1Antlr4ParserROW, SQLv1Antlr4ParserSAMPLE, SQLv1Antlr4ParserSAVEPOINT, SQLv1Antlr4ParserSECONDS, SQLv1Antlr4ParserSEEK, SQLv1Antlr4ParserSEMI, SQLv1Antlr4ParserSETS, SQLv1Antlr4ParserSHOW, SQLv1Antlr4ParserTSKIP, SQLv1Antlr4ParserSOURCE, SQLv1Antlr4ParserSUBQUERY, SQLv1Antlr4ParserSUBSET, SQLv1Antlr4ParserSYMBOLS, SQLv1Antlr4ParserSYNC, SQLv1Antlr4ParserSYSTEM, SQLv1Antlr4ParserTABLE, SQLv1Antlr4ParserTABLES, SQLv1Antlr4ParserTABLESAMPLE, SQLv1Antlr4ParserTABLESTORE, SQLv1Antlr4ParserTEMP, SQLv1Antlr4ParserTEMPORARY, SQLv1Antlr4ParserTHEN, SQLv1Antlr4ParserTIES, SQLv1Antlr4ParserTO, SQLv1Antlr4ParserTOPIC, SQLv1Antlr4ParserTRANSACTION, SQLv1Antlr4ParserTRIGGER, SQLv1Antlr4ParserTYPE, SQLv1Antlr4ParserUNCONDITIONAL, SQLv1Antlr4ParserUNIQUE, SQLv1Antlr4ParserUNKNOWN, SQLv1Antlr4ParserUNMATCHED, SQLv1Antlr4ParserUPDATE, SQLv1Antlr4ParserUPSERT, SQLv1Antlr4ParserUSE, SQLv1Antlr4ParserUSER, SQLv1Antlr4ParserUSING, SQLv1Antlr4ParserVACUUM, SQLv1Antlr4ParserVALUES, SQLv1Antlr4ParserVIEW, SQLv1Antlr4ParserVIRTUAL, SQLv1Antlr4ParserWITH, SQLv1Antlr4ParserWRAPPER, SQLv1Antlr4ParserXOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4440)
			p.Keyword_compat()
		}

	case SQLv1Antlr4ParserASYMMETRIC, SQLv1Antlr4ParserBETWEEN, SQLv1Antlr4ParserBITCAST, SQLv1Antlr4ParserCASE, SQLv1Antlr4ParserCAST, SQLv1Antlr4ParserCUBE, SQLv1Antlr4ParserCURRENT_DATE, SQLv1Antlr4ParserCURRENT_TIME, SQLv1Antlr4ParserCURRENT_TIMESTAMP, SQLv1Antlr4ParserEMPTY_ACTION, SQLv1Antlr4ParserEXISTS, SQLv1Antlr4ParserFROM, SQLv1Antlr4ParserFULL, SQLv1Antlr4ParserHOP, SQLv1Antlr4ParserJSON_EXISTS, SQLv1Antlr4ParserJSON_QUERY, SQLv1Antlr4ParserJSON_VALUE, SQLv1Antlr4ParserLOCAL, SQLv1Antlr4ParserNOT, SQLv1Antlr4ParserNULL, SQLv1Antlr4ParserPROCESS, SQLv1Antlr4ParserREDUCE, SQLv1Antlr4ParserRETURN, SQLv1Antlr4ParserRETURNING, SQLv1Antlr4ParserROLLUP, SQLv1Antlr4ParserSELECT, SQLv1Antlr4ParserSYMMETRIC, SQLv1Antlr4ParserUNBOUNDED, SQLv1Antlr4ParserWHEN, SQLv1Antlr4ParserWHERE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4441)
			p.Keyword_expr_uncompat()
		}

	case SQLv1Antlr4ParserANY, SQLv1Antlr4ParserERASE, SQLv1Antlr4ParserSTREAM:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4442)
			p.Keyword_table_uncompat()
		}

	case SQLv1Antlr4ParserALL, SQLv1Antlr4ParserAS, SQLv1Antlr4ParserASSUME, SQLv1Antlr4ParserDISTINCT, SQLv1Antlr4ParserEXCEPT, SQLv1Antlr4ParserHAVING, SQLv1Antlr4ParserINTERSECT, SQLv1Antlr4ParserLIMIT, SQLv1Antlr4ParserUNION, SQLv1Antlr4ParserWINDOW, SQLv1Antlr4ParserWITHOUT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4443)
			p.Keyword_select_uncompat()
		}

	case SQLv1Antlr4ParserCOLUMN:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4444)
			p.Keyword_alter_uncompat()
		}

	case SQLv1Antlr4ParserCOMPACT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4445)
			p.Keyword_in_uncompat()
		}

	case SQLv1Antlr4ParserGROUPS, SQLv1Antlr4ParserRANGE, SQLv1Antlr4ParserROWS:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4446)
			p.Keyword_window_uncompat()
		}

	case SQLv1Antlr4ParserCOLUMNS, SQLv1Antlr4ParserSCHEMA:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4447)
			p.Keyword_hint_uncompat()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyword_expr_uncompatContext is an interface to support dynamic dispatch.
type IKeyword_expr_uncompatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASYMMETRIC() antlr.TerminalNode
	BETWEEN() antlr.TerminalNode
	BITCAST() antlr.TerminalNode
	CASE() antlr.TerminalNode
	CAST() antlr.TerminalNode
	CUBE() antlr.TerminalNode
	CURRENT_DATE() antlr.TerminalNode
	CURRENT_TIME() antlr.TerminalNode
	CURRENT_TIMESTAMP() antlr.TerminalNode
	EMPTY_ACTION() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	FULL() antlr.TerminalNode
	HOP() antlr.TerminalNode
	JSON_EXISTS() antlr.TerminalNode
	JSON_VALUE() antlr.TerminalNode
	JSON_QUERY() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	NOT() antlr.TerminalNode
	NULL() antlr.TerminalNode
	PROCESS() antlr.TerminalNode
	REDUCE() antlr.TerminalNode
	RETURN() antlr.TerminalNode
	RETURNING() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	SELECT() antlr.TerminalNode
	SYMMETRIC() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	WHEN() antlr.TerminalNode
	WHERE() antlr.TerminalNode

	// IsKeyword_expr_uncompatContext differentiates from other interfaces.
	IsKeyword_expr_uncompatContext()
}

type Keyword_expr_uncompatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyword_expr_uncompatContext() *Keyword_expr_uncompatContext {
	var p = new(Keyword_expr_uncompatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword_expr_uncompat
	return p
}

func InitEmptyKeyword_expr_uncompatContext(p *Keyword_expr_uncompatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword_expr_uncompat
}

func (*Keyword_expr_uncompatContext) IsKeyword_expr_uncompatContext() {}

func NewKeyword_expr_uncompatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Keyword_expr_uncompatContext {
	var p = new(Keyword_expr_uncompatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword_expr_uncompat

	return p
}

func (s *Keyword_expr_uncompatContext) GetParser() antlr.Parser { return s.parser }

func (s *Keyword_expr_uncompatContext) ASYMMETRIC() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserASYMMETRIC, 0)
}

func (s *Keyword_expr_uncompatContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserBETWEEN, 0)
}

func (s *Keyword_expr_uncompatContext) BITCAST() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserBITCAST, 0)
}

func (s *Keyword_expr_uncompatContext) CASE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCASE, 0)
}

func (s *Keyword_expr_uncompatContext) CAST() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCAST, 0)
}

func (s *Keyword_expr_uncompatContext) CUBE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCUBE, 0)
}

func (s *Keyword_expr_uncompatContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCURRENT_DATE, 0)
}

func (s *Keyword_expr_uncompatContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCURRENT_TIME, 0)
}

func (s *Keyword_expr_uncompatContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCURRENT_TIMESTAMP, 0)
}

func (s *Keyword_expr_uncompatContext) EMPTY_ACTION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEMPTY_ACTION, 0)
}

func (s *Keyword_expr_uncompatContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXISTS, 0)
}

func (s *Keyword_expr_uncompatContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFROM, 0)
}

func (s *Keyword_expr_uncompatContext) FULL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFULL, 0)
}

func (s *Keyword_expr_uncompatContext) HOP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserHOP, 0)
}

func (s *Keyword_expr_uncompatContext) JSON_EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserJSON_EXISTS, 0)
}

func (s *Keyword_expr_uncompatContext) JSON_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserJSON_VALUE, 0)
}

func (s *Keyword_expr_uncompatContext) JSON_QUERY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserJSON_QUERY, 0)
}

func (s *Keyword_expr_uncompatContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLOCAL, 0)
}

func (s *Keyword_expr_uncompatContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNOT, 0)
}

func (s *Keyword_expr_uncompatContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNULL, 0)
}

func (s *Keyword_expr_uncompatContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPROCESS, 0)
}

func (s *Keyword_expr_uncompatContext) REDUCE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREDUCE, 0)
}

func (s *Keyword_expr_uncompatContext) RETURN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRETURN, 0)
}

func (s *Keyword_expr_uncompatContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRETURNING, 0)
}

func (s *Keyword_expr_uncompatContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserROLLUP, 0)
}

func (s *Keyword_expr_uncompatContext) SELECT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSELECT, 0)
}

func (s *Keyword_expr_uncompatContext) SYMMETRIC() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSYMMETRIC, 0)
}

func (s *Keyword_expr_uncompatContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUNBOUNDED, 0)
}

func (s *Keyword_expr_uncompatContext) WHEN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWHEN, 0)
}

func (s *Keyword_expr_uncompatContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWHERE, 0)
}

func (s *Keyword_expr_uncompatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Keyword_expr_uncompatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Keyword_expr_uncompatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterKeyword_expr_uncompat(s)
	}
}

func (s *Keyword_expr_uncompatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitKeyword_expr_uncompat(s)
	}
}

func (p *SQLv1Antlr4Parser) Keyword_expr_uncompat() (localctx IKeyword_expr_uncompatContext) {
	localctx = NewKeyword_expr_uncompatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 826, SQLv1Antlr4ParserRULE_keyword_expr_uncompat)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4450)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-57)) & ^0x3f) == 0 && ((int64(1)<<(_la-57))&4611687014860206081) != 0) || ((int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&72550175280775169) != 0) || ((int64((_la-200)) & ^0x3f) == 0 && ((int64(1)<<(_la-200))&1179943248399958021) != 0) || ((int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&422214612553729) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyword_table_uncompatContext is an interface to support dynamic dispatch.
type IKeyword_table_uncompatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ANY() antlr.TerminalNode
	ERASE() antlr.TerminalNode
	STREAM() antlr.TerminalNode

	// IsKeyword_table_uncompatContext differentiates from other interfaces.
	IsKeyword_table_uncompatContext()
}

type Keyword_table_uncompatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyword_table_uncompatContext() *Keyword_table_uncompatContext {
	var p = new(Keyword_table_uncompatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword_table_uncompat
	return p
}

func InitEmptyKeyword_table_uncompatContext(p *Keyword_table_uncompatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword_table_uncompat
}

func (*Keyword_table_uncompatContext) IsKeyword_table_uncompatContext() {}

func NewKeyword_table_uncompatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Keyword_table_uncompatContext {
	var p = new(Keyword_table_uncompatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword_table_uncompat

	return p
}

func (s *Keyword_table_uncompatContext) GetParser() antlr.Parser { return s.parser }

func (s *Keyword_table_uncompatContext) ANY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserANY, 0)
}

func (s *Keyword_table_uncompatContext) ERASE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserERASE, 0)
}

func (s *Keyword_table_uncompatContext) STREAM() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTREAM, 0)
}

func (s *Keyword_table_uncompatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Keyword_table_uncompatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Keyword_table_uncompatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterKeyword_table_uncompat(s)
	}
}

func (s *Keyword_table_uncompatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitKeyword_table_uncompat(s)
	}
}

func (p *SQLv1Antlr4Parser) Keyword_table_uncompat() (localctx IKeyword_table_uncompatContext) {
	localctx = NewKeyword_table_uncompatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 828, SQLv1Antlr4ParserRULE_keyword_table_uncompat)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4452)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLv1Antlr4ParserANY || _la == SQLv1Antlr4ParserERASE || _la == SQLv1Antlr4ParserSTREAM) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyword_select_uncompatContext is an interface to support dynamic dispatch.
type IKeyword_select_uncompatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	AS() antlr.TerminalNode
	ASSUME() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode
	HAVING() antlr.TerminalNode
	INTERSECT() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	UNION() antlr.TerminalNode
	WINDOW() antlr.TerminalNode
	WITHOUT() antlr.TerminalNode

	// IsKeyword_select_uncompatContext differentiates from other interfaces.
	IsKeyword_select_uncompatContext()
}

type Keyword_select_uncompatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyword_select_uncompatContext() *Keyword_select_uncompatContext {
	var p = new(Keyword_select_uncompatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword_select_uncompat
	return p
}

func InitEmptyKeyword_select_uncompatContext(p *Keyword_select_uncompatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword_select_uncompat
}

func (*Keyword_select_uncompatContext) IsKeyword_select_uncompatContext() {}

func NewKeyword_select_uncompatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Keyword_select_uncompatContext {
	var p = new(Keyword_select_uncompatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword_select_uncompat

	return p
}

func (s *Keyword_select_uncompatContext) GetParser() antlr.Parser { return s.parser }

func (s *Keyword_select_uncompatContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserALL, 0)
}

func (s *Keyword_select_uncompatContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAS, 0)
}

func (s *Keyword_select_uncompatContext) ASSUME() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserASSUME, 0)
}

func (s *Keyword_select_uncompatContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDISTINCT, 0)
}

func (s *Keyword_select_uncompatContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXCEPT, 0)
}

func (s *Keyword_select_uncompatContext) HAVING() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserHAVING, 0)
}

func (s *Keyword_select_uncompatContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINTERSECT, 0)
}

func (s *Keyword_select_uncompatContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLIMIT, 0)
}

func (s *Keyword_select_uncompatContext) UNION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUNION, 0)
}

func (s *Keyword_select_uncompatContext) WINDOW() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWINDOW, 0)
}

func (s *Keyword_select_uncompatContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWITHOUT, 0)
}

func (s *Keyword_select_uncompatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Keyword_select_uncompatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Keyword_select_uncompatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterKeyword_select_uncompat(s)
	}
}

func (s *Keyword_select_uncompatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitKeyword_select_uncompat(s)
	}
}

func (p *SQLv1Antlr4Parser) Keyword_select_uncompat() (localctx IKeyword_select_uncompatContext) {
	localctx = NewKeyword_select_uncompatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 830, SQLv1Antlr4ParserRULE_keyword_select_uncompat)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4454)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&90212730035765248) != 0) || ((int64((_la-113)) & ^0x3f) == 0 && ((int64(1)<<(_la-113))&576465150349950977) != 0) || _la == SQLv1Antlr4ParserLIMIT || ((int64((_la-301)) & ^0x3f) == 0 && ((int64(1)<<(_la-301))&327681) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyword_alter_uncompatContext is an interface to support dynamic dispatch.
type IKeyword_alter_uncompatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLUMN() antlr.TerminalNode

	// IsKeyword_alter_uncompatContext differentiates from other interfaces.
	IsKeyword_alter_uncompatContext()
}

type Keyword_alter_uncompatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyword_alter_uncompatContext() *Keyword_alter_uncompatContext {
	var p = new(Keyword_alter_uncompatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword_alter_uncompat
	return p
}

func InitEmptyKeyword_alter_uncompatContext(p *Keyword_alter_uncompatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword_alter_uncompat
}

func (*Keyword_alter_uncompatContext) IsKeyword_alter_uncompatContext() {}

func NewKeyword_alter_uncompatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Keyword_alter_uncompatContext {
	var p = new(Keyword_alter_uncompatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword_alter_uncompat

	return p
}

func (s *Keyword_alter_uncompatContext) GetParser() antlr.Parser { return s.parser }

func (s *Keyword_alter_uncompatContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOLUMN, 0)
}

func (s *Keyword_alter_uncompatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Keyword_alter_uncompatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Keyword_alter_uncompatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterKeyword_alter_uncompat(s)
	}
}

func (s *Keyword_alter_uncompatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitKeyword_alter_uncompat(s)
	}
}

func (p *SQLv1Antlr4Parser) Keyword_alter_uncompat() (localctx IKeyword_alter_uncompatContext) {
	localctx = NewKeyword_alter_uncompatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 832, SQLv1Antlr4ParserRULE_keyword_alter_uncompat)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4456)
		p.Match(SQLv1Antlr4ParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyword_in_uncompatContext is an interface to support dynamic dispatch.
type IKeyword_in_uncompatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMPACT() antlr.TerminalNode

	// IsKeyword_in_uncompatContext differentiates from other interfaces.
	IsKeyword_in_uncompatContext()
}

type Keyword_in_uncompatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyword_in_uncompatContext() *Keyword_in_uncompatContext {
	var p = new(Keyword_in_uncompatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword_in_uncompat
	return p
}

func InitEmptyKeyword_in_uncompatContext(p *Keyword_in_uncompatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword_in_uncompat
}

func (*Keyword_in_uncompatContext) IsKeyword_in_uncompatContext() {}

func NewKeyword_in_uncompatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Keyword_in_uncompatContext {
	var p = new(Keyword_in_uncompatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword_in_uncompat

	return p
}

func (s *Keyword_in_uncompatContext) GetParser() antlr.Parser { return s.parser }

func (s *Keyword_in_uncompatContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMPACT, 0)
}

func (s *Keyword_in_uncompatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Keyword_in_uncompatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Keyword_in_uncompatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterKeyword_in_uncompat(s)
	}
}

func (s *Keyword_in_uncompatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitKeyword_in_uncompat(s)
	}
}

func (p *SQLv1Antlr4Parser) Keyword_in_uncompat() (localctx IKeyword_in_uncompatContext) {
	localctx = NewKeyword_in_uncompatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 834, SQLv1Antlr4ParserRULE_keyword_in_uncompat)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4458)
		p.Match(SQLv1Antlr4ParserCOMPACT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyword_window_uncompatContext is an interface to support dynamic dispatch.
type IKeyword_window_uncompatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUPS() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	ROWS() antlr.TerminalNode

	// IsKeyword_window_uncompatContext differentiates from other interfaces.
	IsKeyword_window_uncompatContext()
}

type Keyword_window_uncompatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyword_window_uncompatContext() *Keyword_window_uncompatContext {
	var p = new(Keyword_window_uncompatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword_window_uncompat
	return p
}

func InitEmptyKeyword_window_uncompatContext(p *Keyword_window_uncompatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword_window_uncompat
}

func (*Keyword_window_uncompatContext) IsKeyword_window_uncompatContext() {}

func NewKeyword_window_uncompatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Keyword_window_uncompatContext {
	var p = new(Keyword_window_uncompatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword_window_uncompat

	return p
}

func (s *Keyword_window_uncompatContext) GetParser() antlr.Parser { return s.parser }

func (s *Keyword_window_uncompatContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGROUPS, 0)
}

func (s *Keyword_window_uncompatContext) RANGE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRANGE, 0)
}

func (s *Keyword_window_uncompatContext) ROWS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserROWS, 0)
}

func (s *Keyword_window_uncompatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Keyword_window_uncompatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Keyword_window_uncompatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterKeyword_window_uncompat(s)
	}
}

func (s *Keyword_window_uncompatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitKeyword_window_uncompat(s)
	}
}

func (p *SQLv1Antlr4Parser) Keyword_window_uncompat() (localctx IKeyword_window_uncompatContext) {
	localctx = NewKeyword_window_uncompatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 836, SQLv1Antlr4ParserRULE_keyword_window_uncompat)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4460)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLv1Antlr4ParserGROUPS || _la == SQLv1Antlr4ParserRANGE || _la == SQLv1Antlr4ParserROWS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyword_hint_uncompatContext is an interface to support dynamic dispatch.
type IKeyword_hint_uncompatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SCHEMA() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode

	// IsKeyword_hint_uncompatContext differentiates from other interfaces.
	IsKeyword_hint_uncompatContext()
}

type Keyword_hint_uncompatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyword_hint_uncompatContext() *Keyword_hint_uncompatContext {
	var p = new(Keyword_hint_uncompatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword_hint_uncompat
	return p
}

func InitEmptyKeyword_hint_uncompatContext(p *Keyword_hint_uncompatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword_hint_uncompat
}

func (*Keyword_hint_uncompatContext) IsKeyword_hint_uncompatContext() {}

func NewKeyword_hint_uncompatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Keyword_hint_uncompatContext {
	var p = new(Keyword_hint_uncompatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword_hint_uncompat

	return p
}

func (s *Keyword_hint_uncompatContext) GetParser() antlr.Parser { return s.parser }

func (s *Keyword_hint_uncompatContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSCHEMA, 0)
}

func (s *Keyword_hint_uncompatContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOLUMNS, 0)
}

func (s *Keyword_hint_uncompatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Keyword_hint_uncompatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Keyword_hint_uncompatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterKeyword_hint_uncompat(s)
	}
}

func (s *Keyword_hint_uncompatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitKeyword_hint_uncompat(s)
	}
}

func (p *SQLv1Antlr4Parser) Keyword_hint_uncompat() (localctx IKeyword_hint_uncompatContext) {
	localctx = NewKeyword_hint_uncompatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 838, SQLv1Antlr4ParserRULE_keyword_hint_uncompat)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4462)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLv1Antlr4ParserCOLUMNS || _la == SQLv1Antlr4ParserSCHEMA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyword_as_compatContext is an interface to support dynamic dispatch.
type IKeyword_as_compatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ABORT() antlr.TerminalNode
	ACTION() antlr.TerminalNode
	ADD() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	AND() antlr.TerminalNode
	ANSI() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	ASC() antlr.TerminalNode
	ASYNC() antlr.TerminalNode
	AT() antlr.TerminalNode
	ATTACH() antlr.TerminalNode
	ATTRIBUTES() antlr.TerminalNode
	AUTOINCREMENT() antlr.TerminalNode
	BACKUP() antlr.TerminalNode
	BEFORE() antlr.TerminalNode
	BEGIN() antlr.TerminalNode
	BERNOULLI() antlr.TerminalNode
	BY() antlr.TerminalNode
	CASCADE() antlr.TerminalNode
	CHANGEFEED() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	CLASSIFIER() antlr.TerminalNode
	COLLECTION() antlr.TerminalNode
	COMMIT() antlr.TerminalNode
	CONDITIONAL() antlr.TerminalNode
	CONFLICT() antlr.TerminalNode
	CONNECT() antlr.TerminalNode
	CONSTRAINT() antlr.TerminalNode
	CONSUMER() antlr.TerminalNode
	COVER() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	DECLARE() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	DEFERRABLE() antlr.TerminalNode
	DEFERRED() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	DESC() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	DETACH() antlr.TerminalNode
	DIRECTORY() antlr.TerminalNode
	DISABLE() antlr.TerminalNode
	DISCARD() antlr.TerminalNode
	DROP() antlr.TerminalNode
	EACH() antlr.TerminalNode
	ELSE() antlr.TerminalNode
	EMPTY() antlr.TerminalNode
	ENCRYPTED() antlr.TerminalNode
	END() antlr.TerminalNode
	ERROR() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	EVALUATE() antlr.TerminalNode
	EXCLUDE() antlr.TerminalNode
	EXCLUSIVE() antlr.TerminalNode
	EXPLAIN() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	FAIL() antlr.TerminalNode
	FAMILY() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	FLATTEN() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	FOR() antlr.TerminalNode
	FOREIGN() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	GLOB() antlr.TerminalNode
	GRANT() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	GROUPING() antlr.TerminalNode
	HASH() antlr.TerminalNode
	IF() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	ILIKE() antlr.TerminalNode
	IMMEDIATE() antlr.TerminalNode
	IMPORT() antlr.TerminalNode
	IN() antlr.TerminalNode
	INCREMENTAL() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	INDEXED() antlr.TerminalNode
	INHERITS() antlr.TerminalNode
	INITIAL() antlr.TerminalNode
	INITIALLY() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	INSTEAD() antlr.TerminalNode
	INTO() antlr.TerminalNode
	IS() antlr.TerminalNode
	LAST() antlr.TerminalNode
	LEGACY() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	MANAGE() antlr.TerminalNode
	MATCH() antlr.TerminalNode
	MATCHES() antlr.TerminalNode
	MATCH_RECOGNIZE() antlr.TerminalNode
	MEASURES() antlr.TerminalNode
	MICROSECONDS() antlr.TerminalNode
	MILLISECONDS() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	NANOSECONDS() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	NO() antlr.TerminalNode
	NULLS() antlr.TerminalNode
	OBJECT() antlr.TerminalNode
	OF() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	OMIT() antlr.TerminalNode
	ONE() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	OPTION() antlr.TerminalNode
	OR() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	OTHERS() antlr.TerminalNode
	PARALLEL() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	PASSING() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	PAST() antlr.TerminalNode
	PATTERN() antlr.TerminalNode
	PER() antlr.TerminalNode
	PERMUTE() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	POOL() antlr.TerminalNode
	PRAGMA() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode
	QUEUE() antlr.TerminalNode
	RAISE() antlr.TerminalNode
	REFERENCES() antlr.TerminalNode
	REGEXP() antlr.TerminalNode
	REINDEX() antlr.TerminalNode
	RELEASE() antlr.TerminalNode
	REMOVE() antlr.TerminalNode
	RENAME() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	REPLICATION() antlr.TerminalNode
	RESET() antlr.TerminalNode
	RESPECT() antlr.TerminalNode
	RESTORE() antlr.TerminalNode
	RESTRICT() antlr.TerminalNode
	REVERT() antlr.TerminalNode
	REVOKE() antlr.TerminalNode
	RLIKE() antlr.TerminalNode
	ROLLBACK() antlr.TerminalNode
	ROW() antlr.TerminalNode
	SAVEPOINT() antlr.TerminalNode
	SECONDS() antlr.TerminalNode
	SEEK() antlr.TerminalNode
	SETS() antlr.TerminalNode
	SHOW() antlr.TerminalNode
	TSKIP() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	SUBQUERY() antlr.TerminalNode
	SUBSET() antlr.TerminalNode
	SYMBOLS() antlr.TerminalNode
	SYNC() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	TABLESAMPLE() antlr.TerminalNode
	TABLESTORE() antlr.TerminalNode
	TEMP() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	THEN() antlr.TerminalNode
	TIES() antlr.TerminalNode
	TO() antlr.TerminalNode
	TOPIC() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	TRIGGER() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	UNCONDITIONAL() antlr.TerminalNode
	UNIQUE() antlr.TerminalNode
	UNKNOWN() antlr.TerminalNode
	UNMATCHED() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	UPSERT() antlr.TerminalNode
	USE() antlr.TerminalNode
	USER() antlr.TerminalNode
	VACUUM() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	VIRTUAL() antlr.TerminalNode
	WRAPPER() antlr.TerminalNode
	XOR() antlr.TerminalNode

	// IsKeyword_as_compatContext differentiates from other interfaces.
	IsKeyword_as_compatContext()
}

type Keyword_as_compatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyword_as_compatContext() *Keyword_as_compatContext {
	var p = new(Keyword_as_compatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword_as_compat
	return p
}

func InitEmptyKeyword_as_compatContext(p *Keyword_as_compatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword_as_compat
}

func (*Keyword_as_compatContext) IsKeyword_as_compatContext() {}

func NewKeyword_as_compatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Keyword_as_compatContext {
	var p = new(Keyword_as_compatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword_as_compat

	return p
}

func (s *Keyword_as_compatContext) GetParser() antlr.Parser { return s.parser }

func (s *Keyword_as_compatContext) ABORT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserABORT, 0)
}

func (s *Keyword_as_compatContext) ACTION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserACTION, 0)
}

func (s *Keyword_as_compatContext) ADD() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserADD, 0)
}

func (s *Keyword_as_compatContext) AFTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAFTER, 0)
}

func (s *Keyword_as_compatContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserALTER, 0)
}

func (s *Keyword_as_compatContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserANALYZE, 0)
}

func (s *Keyword_as_compatContext) AND() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAND, 0)
}

func (s *Keyword_as_compatContext) ANSI() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserANSI, 0)
}

func (s *Keyword_as_compatContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserARRAY, 0)
}

func (s *Keyword_as_compatContext) ASC() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserASC, 0)
}

func (s *Keyword_as_compatContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserASYNC, 0)
}

func (s *Keyword_as_compatContext) AT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAT, 0)
}

func (s *Keyword_as_compatContext) ATTACH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserATTACH, 0)
}

func (s *Keyword_as_compatContext) ATTRIBUTES() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserATTRIBUTES, 0)
}

func (s *Keyword_as_compatContext) AUTOINCREMENT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAUTOINCREMENT, 0)
}

func (s *Keyword_as_compatContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserBACKUP, 0)
}

func (s *Keyword_as_compatContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserBEFORE, 0)
}

func (s *Keyword_as_compatContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserBEGIN, 0)
}

func (s *Keyword_as_compatContext) BERNOULLI() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserBERNOULLI, 0)
}

func (s *Keyword_as_compatContext) BY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserBY, 0)
}

func (s *Keyword_as_compatContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCASCADE, 0)
}

func (s *Keyword_as_compatContext) CHANGEFEED() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCHANGEFEED, 0)
}

func (s *Keyword_as_compatContext) CHECK() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCHECK, 0)
}

func (s *Keyword_as_compatContext) CLASSIFIER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCLASSIFIER, 0)
}

func (s *Keyword_as_compatContext) COLLECTION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOLLECTION, 0)
}

func (s *Keyword_as_compatContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMIT, 0)
}

func (s *Keyword_as_compatContext) CONDITIONAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCONDITIONAL, 0)
}

func (s *Keyword_as_compatContext) CONFLICT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCONFLICT, 0)
}

func (s *Keyword_as_compatContext) CONNECT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCONNECT, 0)
}

func (s *Keyword_as_compatContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCONSTRAINT, 0)
}

func (s *Keyword_as_compatContext) CONSUMER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCONSUMER, 0)
}

func (s *Keyword_as_compatContext) COVER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOVER, 0)
}

func (s *Keyword_as_compatContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCREATE, 0)
}

func (s *Keyword_as_compatContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCURRENT, 0)
}

func (s *Keyword_as_compatContext) DATA() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDATA, 0)
}

func (s *Keyword_as_compatContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDATABASE, 0)
}

func (s *Keyword_as_compatContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDECIMAL, 0)
}

func (s *Keyword_as_compatContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDECLARE, 0)
}

func (s *Keyword_as_compatContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDEFAULT, 0)
}

func (s *Keyword_as_compatContext) DEFERRABLE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDEFERRABLE, 0)
}

func (s *Keyword_as_compatContext) DEFERRED() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDEFERRED, 0)
}

func (s *Keyword_as_compatContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDELETE, 0)
}

func (s *Keyword_as_compatContext) DESC() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDESC, 0)
}

func (s *Keyword_as_compatContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDESCRIBE, 0)
}

func (s *Keyword_as_compatContext) DETACH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDETACH, 0)
}

func (s *Keyword_as_compatContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDIRECTORY, 0)
}

func (s *Keyword_as_compatContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDISABLE, 0)
}

func (s *Keyword_as_compatContext) DISCARD() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDISCARD, 0)
}

func (s *Keyword_as_compatContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDROP, 0)
}

func (s *Keyword_as_compatContext) EACH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEACH, 0)
}

func (s *Keyword_as_compatContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserELSE, 0)
}

func (s *Keyword_as_compatContext) EMPTY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEMPTY, 0)
}

func (s *Keyword_as_compatContext) ENCRYPTED() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserENCRYPTED, 0)
}

func (s *Keyword_as_compatContext) END() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEND, 0)
}

func (s *Keyword_as_compatContext) ERROR() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserERROR, 0)
}

func (s *Keyword_as_compatContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserESCAPE, 0)
}

func (s *Keyword_as_compatContext) EVALUATE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEVALUATE, 0)
}

func (s *Keyword_as_compatContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXCLUDE, 0)
}

func (s *Keyword_as_compatContext) EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXCLUSIVE, 0)
}

func (s *Keyword_as_compatContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXPLAIN, 0)
}

func (s *Keyword_as_compatContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXPORT, 0)
}

func (s *Keyword_as_compatContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXTERNAL, 0)
}

func (s *Keyword_as_compatContext) FAIL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFAIL, 0)
}

func (s *Keyword_as_compatContext) FAMILY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFAMILY, 0)
}

func (s *Keyword_as_compatContext) FILTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFILTER, 0)
}

func (s *Keyword_as_compatContext) FIRST() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFIRST, 0)
}

func (s *Keyword_as_compatContext) FLATTEN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFLATTEN, 0)
}

func (s *Keyword_as_compatContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFOLLOWING, 0)
}

func (s *Keyword_as_compatContext) FOR() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFOR, 0)
}

func (s *Keyword_as_compatContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFOREIGN, 0)
}

func (s *Keyword_as_compatContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFUNCTION, 0)
}

func (s *Keyword_as_compatContext) GLOB() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGLOB, 0)
}

func (s *Keyword_as_compatContext) GRANT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGRANT, 0)
}

func (s *Keyword_as_compatContext) GROUP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGROUP, 0)
}

func (s *Keyword_as_compatContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGROUPING, 0)
}

func (s *Keyword_as_compatContext) HASH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserHASH, 0)
}

func (s *Keyword_as_compatContext) IF() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIF, 0)
}

func (s *Keyword_as_compatContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIGNORE, 0)
}

func (s *Keyword_as_compatContext) ILIKE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserILIKE, 0)
}

func (s *Keyword_as_compatContext) IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIMMEDIATE, 0)
}

func (s *Keyword_as_compatContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIMPORT, 0)
}

func (s *Keyword_as_compatContext) IN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIN, 0)
}

func (s *Keyword_as_compatContext) INCREMENTAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINCREMENTAL, 0)
}

func (s *Keyword_as_compatContext) INDEX() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINDEX, 0)
}

func (s *Keyword_as_compatContext) INDEXED() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINDEXED, 0)
}

func (s *Keyword_as_compatContext) INHERITS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINHERITS, 0)
}

func (s *Keyword_as_compatContext) INITIAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINITIAL, 0)
}

func (s *Keyword_as_compatContext) INITIALLY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINITIALLY, 0)
}

func (s *Keyword_as_compatContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINSERT, 0)
}

func (s *Keyword_as_compatContext) INSTEAD() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINSTEAD, 0)
}

func (s *Keyword_as_compatContext) INTO() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINTO, 0)
}

func (s *Keyword_as_compatContext) IS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIS, 0)
}

func (s *Keyword_as_compatContext) LAST() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLAST, 0)
}

func (s *Keyword_as_compatContext) LEGACY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLEGACY, 0)
}

func (s *Keyword_as_compatContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLIKE, 0)
}

func (s *Keyword_as_compatContext) MANAGE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMANAGE, 0)
}

func (s *Keyword_as_compatContext) MATCH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMATCH, 0)
}

func (s *Keyword_as_compatContext) MATCHES() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMATCHES, 0)
}

func (s *Keyword_as_compatContext) MATCH_RECOGNIZE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMATCH_RECOGNIZE, 0)
}

func (s *Keyword_as_compatContext) MEASURES() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMEASURES, 0)
}

func (s *Keyword_as_compatContext) MICROSECONDS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMICROSECONDS, 0)
}

func (s *Keyword_as_compatContext) MILLISECONDS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMILLISECONDS, 0)
}

func (s *Keyword_as_compatContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMODIFY, 0)
}

func (s *Keyword_as_compatContext) NANOSECONDS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNANOSECONDS, 0)
}

func (s *Keyword_as_compatContext) NEXT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNEXT, 0)
}

func (s *Keyword_as_compatContext) NO() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNO, 0)
}

func (s *Keyword_as_compatContext) NULLS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNULLS, 0)
}

func (s *Keyword_as_compatContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOBJECT, 0)
}

func (s *Keyword_as_compatContext) OF() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOF, 0)
}

func (s *Keyword_as_compatContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOFFSET, 0)
}

func (s *Keyword_as_compatContext) OMIT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOMIT, 0)
}

func (s *Keyword_as_compatContext) ONE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserONE, 0)
}

func (s *Keyword_as_compatContext) ONLY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserONLY, 0)
}

func (s *Keyword_as_compatContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOPTION, 0)
}

func (s *Keyword_as_compatContext) OR() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOR, 0)
}

func (s *Keyword_as_compatContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserORDER, 0)
}

func (s *Keyword_as_compatContext) OTHERS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOTHERS, 0)
}

func (s *Keyword_as_compatContext) PARALLEL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPARALLEL, 0)
}

func (s *Keyword_as_compatContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPARTITION, 0)
}

func (s *Keyword_as_compatContext) PASSING() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPASSING, 0)
}

func (s *Keyword_as_compatContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPASSWORD, 0)
}

func (s *Keyword_as_compatContext) PAST() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPAST, 0)
}

func (s *Keyword_as_compatContext) PATTERN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPATTERN, 0)
}

func (s *Keyword_as_compatContext) PER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPER, 0)
}

func (s *Keyword_as_compatContext) PERMUTE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPERMUTE, 0)
}

func (s *Keyword_as_compatContext) PLAN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPLAN, 0)
}

func (s *Keyword_as_compatContext) POOL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPOOL, 0)
}

func (s *Keyword_as_compatContext) PRAGMA() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPRAGMA, 0)
}

func (s *Keyword_as_compatContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPRECEDING, 0)
}

func (s *Keyword_as_compatContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPRIMARY, 0)
}

func (s *Keyword_as_compatContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPRIVILEGES, 0)
}

func (s *Keyword_as_compatContext) QUEUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserQUEUE, 0)
}

func (s *Keyword_as_compatContext) RAISE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRAISE, 0)
}

func (s *Keyword_as_compatContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREFERENCES, 0)
}

func (s *Keyword_as_compatContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREGEXP, 0)
}

func (s *Keyword_as_compatContext) REINDEX() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREINDEX, 0)
}

func (s *Keyword_as_compatContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRELEASE, 0)
}

func (s *Keyword_as_compatContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREMOVE, 0)
}

func (s *Keyword_as_compatContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRENAME, 0)
}

func (s *Keyword_as_compatContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREPLACE, 0)
}

func (s *Keyword_as_compatContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREPLICATION, 0)
}

func (s *Keyword_as_compatContext) RESET() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRESET, 0)
}

func (s *Keyword_as_compatContext) RESPECT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRESPECT, 0)
}

func (s *Keyword_as_compatContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRESTORE, 0)
}

func (s *Keyword_as_compatContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRESTRICT, 0)
}

func (s *Keyword_as_compatContext) REVERT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREVERT, 0)
}

func (s *Keyword_as_compatContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREVOKE, 0)
}

func (s *Keyword_as_compatContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRLIKE, 0)
}

func (s *Keyword_as_compatContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserROLLBACK, 0)
}

func (s *Keyword_as_compatContext) ROW() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserROW, 0)
}

func (s *Keyword_as_compatContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSAVEPOINT, 0)
}

func (s *Keyword_as_compatContext) SECONDS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSECONDS, 0)
}

func (s *Keyword_as_compatContext) SEEK() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSEEK, 0)
}

func (s *Keyword_as_compatContext) SETS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSETS, 0)
}

func (s *Keyword_as_compatContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSHOW, 0)
}

func (s *Keyword_as_compatContext) TSKIP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTSKIP, 0)
}

func (s *Keyword_as_compatContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSOURCE, 0)
}

func (s *Keyword_as_compatContext) SUBQUERY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSUBQUERY, 0)
}

func (s *Keyword_as_compatContext) SUBSET() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSUBSET, 0)
}

func (s *Keyword_as_compatContext) SYMBOLS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSYMBOLS, 0)
}

func (s *Keyword_as_compatContext) SYNC() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSYNC, 0)
}

func (s *Keyword_as_compatContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSYSTEM, 0)
}

func (s *Keyword_as_compatContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTABLE, 0)
}

func (s *Keyword_as_compatContext) TABLES() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTABLES, 0)
}

func (s *Keyword_as_compatContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTABLESAMPLE, 0)
}

func (s *Keyword_as_compatContext) TABLESTORE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTABLESTORE, 0)
}

func (s *Keyword_as_compatContext) TEMP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTEMP, 0)
}

func (s *Keyword_as_compatContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTEMPORARY, 0)
}

func (s *Keyword_as_compatContext) THEN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTHEN, 0)
}

func (s *Keyword_as_compatContext) TIES() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTIES, 0)
}

func (s *Keyword_as_compatContext) TO() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTO, 0)
}

func (s *Keyword_as_compatContext) TOPIC() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTOPIC, 0)
}

func (s *Keyword_as_compatContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTRANSACTION, 0)
}

func (s *Keyword_as_compatContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTRIGGER, 0)
}

func (s *Keyword_as_compatContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTYPE, 0)
}

func (s *Keyword_as_compatContext) UNCONDITIONAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUNCONDITIONAL, 0)
}

func (s *Keyword_as_compatContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUNIQUE, 0)
}

func (s *Keyword_as_compatContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUNKNOWN, 0)
}

func (s *Keyword_as_compatContext) UNMATCHED() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUNMATCHED, 0)
}

func (s *Keyword_as_compatContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUPDATE, 0)
}

func (s *Keyword_as_compatContext) UPSERT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUPSERT, 0)
}

func (s *Keyword_as_compatContext) USE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUSE, 0)
}

func (s *Keyword_as_compatContext) USER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUSER, 0)
}

func (s *Keyword_as_compatContext) VACUUM() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserVACUUM, 0)
}

func (s *Keyword_as_compatContext) VALUES() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserVALUES, 0)
}

func (s *Keyword_as_compatContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserVIRTUAL, 0)
}

func (s *Keyword_as_compatContext) WRAPPER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWRAPPER, 0)
}

func (s *Keyword_as_compatContext) XOR() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserXOR, 0)
}

func (s *Keyword_as_compatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Keyword_as_compatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Keyword_as_compatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterKeyword_as_compat(s)
	}
}

func (s *Keyword_as_compatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitKeyword_as_compat(s)
	}
}

func (p *SQLv1Antlr4Parser) Keyword_as_compat() (localctx IKeyword_as_compatContext) {
	localctx = NewKeyword_as_compatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 840, SQLv1Antlr4ParserRULE_keyword_as_compat)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4464)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-43)) & ^0x3f) == 0 && ((int64(1)<<(_la-43))&-2322451620569311761) != 0) || ((int64((_la-107)) & ^0x3f) == 0 && ((int64(1)<<(_la-107))&-4612606052520792261) != 0) || ((int64((_la-171)) & ^0x3f) == 0 && ((int64(1)<<(_la-171))&-5188254664134609907) != 0) || ((int64((_la-235)) & ^0x3f) == 0 && ((int64(1)<<(_la-235))&-6922071171820036615) != 0) || ((int64((_la-300)) & ^0x3f) == 0 && ((int64(1)<<(_la-300))&3165693) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyword_compatContext is an interface to support dynamic dispatch.
type IKeyword_compatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ABORT() antlr.TerminalNode
	ACTION() antlr.TerminalNode
	ADD() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	AND() antlr.TerminalNode
	ANSI() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	ASC() antlr.TerminalNode
	ASYNC() antlr.TerminalNode
	AT() antlr.TerminalNode
	ATTACH() antlr.TerminalNode
	ATTRIBUTES() antlr.TerminalNode
	AUTOINCREMENT() antlr.TerminalNode
	BACKUP() antlr.TerminalNode
	BEFORE() antlr.TerminalNode
	BEGIN() antlr.TerminalNode
	BERNOULLI() antlr.TerminalNode
	BY() antlr.TerminalNode
	CASCADE() antlr.TerminalNode
	CHANGEFEED() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	CLASSIFIER() antlr.TerminalNode
	COLLATE() antlr.TerminalNode
	COLLECTION() antlr.TerminalNode
	COMMIT() antlr.TerminalNode
	CONDITIONAL() antlr.TerminalNode
	CONFLICT() antlr.TerminalNode
	CONNECT() antlr.TerminalNode
	CONSTRAINT() antlr.TerminalNode
	CONSUMER() antlr.TerminalNode
	COVER() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	CROSS() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	DECLARE() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	DEFERRABLE() antlr.TerminalNode
	DEFERRED() antlr.TerminalNode
	DEFINE() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	DESC() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	DETACH() antlr.TerminalNode
	DIRECTORY() antlr.TerminalNode
	DISABLE() antlr.TerminalNode
	DISCARD() antlr.TerminalNode
	DO() antlr.TerminalNode
	DROP() antlr.TerminalNode
	EACH() antlr.TerminalNode
	ELSE() antlr.TerminalNode
	EMPTY() antlr.TerminalNode
	ENCRYPTED() antlr.TerminalNode
	END() antlr.TerminalNode
	ERROR() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	EVALUATE() antlr.TerminalNode
	EXCLUDE() antlr.TerminalNode
	EXCLUSION() antlr.TerminalNode
	EXCLUSIVE() antlr.TerminalNode
	EXPLAIN() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	FAIL() antlr.TerminalNode
	FAMILY() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	FLATTEN() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	FOR() antlr.TerminalNode
	FOREIGN() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	GLOB() antlr.TerminalNode
	GRANT() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	GROUPING() antlr.TerminalNode
	HASH() antlr.TerminalNode
	IF() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	ILIKE() antlr.TerminalNode
	IMMEDIATE() antlr.TerminalNode
	IMPORT() antlr.TerminalNode
	IN() antlr.TerminalNode
	INCREMENTAL() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	INDEXED() antlr.TerminalNode
	INHERITS() antlr.TerminalNode
	INITIAL() antlr.TerminalNode
	INITIALLY() antlr.TerminalNode
	INNER() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	INSTEAD() antlr.TerminalNode
	INTO() antlr.TerminalNode
	IS() antlr.TerminalNode
	ISNULL() antlr.TerminalNode
	JOIN() antlr.TerminalNode
	KEY() antlr.TerminalNode
	LAST() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	LEGACY() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	MANAGE() antlr.TerminalNode
	MATCH() antlr.TerminalNode
	MATCHES() antlr.TerminalNode
	MATCH_RECOGNIZE() antlr.TerminalNode
	MEASURES() antlr.TerminalNode
	MICROSECONDS() antlr.TerminalNode
	MILLISECONDS() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	NANOSECONDS() antlr.TerminalNode
	NATURAL() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	NO() antlr.TerminalNode
	NOTNULL() antlr.TerminalNode
	NULLS() antlr.TerminalNode
	OBJECT() antlr.TerminalNode
	OF() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	OMIT() antlr.TerminalNode
	ON() antlr.TerminalNode
	ONE() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	OPTION() antlr.TerminalNode
	OR() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	OTHERS() antlr.TerminalNode
	OUTER() antlr.TerminalNode
	OVER() antlr.TerminalNode
	PARALLEL() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	PASSING() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	PAST() antlr.TerminalNode
	PATTERN() antlr.TerminalNode
	PER() antlr.TerminalNode
	PERMUTE() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	POOL() antlr.TerminalNode
	PRAGMA() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	PRESORT() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode
	QUEUE() antlr.TerminalNode
	RAISE() antlr.TerminalNode
	REFERENCES() antlr.TerminalNode
	REGEXP() antlr.TerminalNode
	REINDEX() antlr.TerminalNode
	RELEASE() antlr.TerminalNode
	REMOVE() antlr.TerminalNode
	RENAME() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	REPLICATION() antlr.TerminalNode
	RESET() antlr.TerminalNode
	RESPECT() antlr.TerminalNode
	RESTORE() antlr.TerminalNode
	RESTRICT() antlr.TerminalNode
	RESULT() antlr.TerminalNode
	REVERT() antlr.TerminalNode
	REVOKE() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	RLIKE() antlr.TerminalNode
	ROLLBACK() antlr.TerminalNode
	ROW() antlr.TerminalNode
	SAMPLE() antlr.TerminalNode
	SAVEPOINT() antlr.TerminalNode
	SECONDS() antlr.TerminalNode
	SEEK() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	SETS() antlr.TerminalNode
	SHOW() antlr.TerminalNode
	TSKIP() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	SUBQUERY() antlr.TerminalNode
	SUBSET() antlr.TerminalNode
	SYMBOLS() antlr.TerminalNode
	SYNC() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	TABLESAMPLE() antlr.TerminalNode
	TABLESTORE() antlr.TerminalNode
	TEMP() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	THEN() antlr.TerminalNode
	TIES() antlr.TerminalNode
	TO() antlr.TerminalNode
	TOPIC() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	TRIGGER() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	UNCONDITIONAL() antlr.TerminalNode
	UNIQUE() antlr.TerminalNode
	UNKNOWN() antlr.TerminalNode
	UNMATCHED() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	UPSERT() antlr.TerminalNode
	USE() antlr.TerminalNode
	USER() antlr.TerminalNode
	USING() antlr.TerminalNode
	VACUUM() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	VIRTUAL() antlr.TerminalNode
	WITH() antlr.TerminalNode
	WRAPPER() antlr.TerminalNode
	XOR() antlr.TerminalNode

	// IsKeyword_compatContext differentiates from other interfaces.
	IsKeyword_compatContext()
}

type Keyword_compatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyword_compatContext() *Keyword_compatContext {
	var p = new(Keyword_compatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword_compat
	return p
}

func InitEmptyKeyword_compatContext(p *Keyword_compatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword_compat
}

func (*Keyword_compatContext) IsKeyword_compatContext() {}

func NewKeyword_compatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Keyword_compatContext {
	var p = new(Keyword_compatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_keyword_compat

	return p
}

func (s *Keyword_compatContext) GetParser() antlr.Parser { return s.parser }

func (s *Keyword_compatContext) ABORT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserABORT, 0)
}

func (s *Keyword_compatContext) ACTION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserACTION, 0)
}

func (s *Keyword_compatContext) ADD() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserADD, 0)
}

func (s *Keyword_compatContext) AFTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAFTER, 0)
}

func (s *Keyword_compatContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserALTER, 0)
}

func (s *Keyword_compatContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserANALYZE, 0)
}

func (s *Keyword_compatContext) AND() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAND, 0)
}

func (s *Keyword_compatContext) ANSI() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserANSI, 0)
}

func (s *Keyword_compatContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserARRAY, 0)
}

func (s *Keyword_compatContext) ASC() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserASC, 0)
}

func (s *Keyword_compatContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserASYNC, 0)
}

func (s *Keyword_compatContext) AT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAT, 0)
}

func (s *Keyword_compatContext) ATTACH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserATTACH, 0)
}

func (s *Keyword_compatContext) ATTRIBUTES() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserATTRIBUTES, 0)
}

func (s *Keyword_compatContext) AUTOINCREMENT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserAUTOINCREMENT, 0)
}

func (s *Keyword_compatContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserBACKUP, 0)
}

func (s *Keyword_compatContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserBEFORE, 0)
}

func (s *Keyword_compatContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserBEGIN, 0)
}

func (s *Keyword_compatContext) BERNOULLI() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserBERNOULLI, 0)
}

func (s *Keyword_compatContext) BY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserBY, 0)
}

func (s *Keyword_compatContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCASCADE, 0)
}

func (s *Keyword_compatContext) CHANGEFEED() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCHANGEFEED, 0)
}

func (s *Keyword_compatContext) CHECK() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCHECK, 0)
}

func (s *Keyword_compatContext) CLASSIFIER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCLASSIFIER, 0)
}

func (s *Keyword_compatContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOLLATE, 0)
}

func (s *Keyword_compatContext) COLLECTION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOLLECTION, 0)
}

func (s *Keyword_compatContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOMMIT, 0)
}

func (s *Keyword_compatContext) CONDITIONAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCONDITIONAL, 0)
}

func (s *Keyword_compatContext) CONFLICT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCONFLICT, 0)
}

func (s *Keyword_compatContext) CONNECT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCONNECT, 0)
}

func (s *Keyword_compatContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCONSTRAINT, 0)
}

func (s *Keyword_compatContext) CONSUMER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCONSUMER, 0)
}

func (s *Keyword_compatContext) COVER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCOVER, 0)
}

func (s *Keyword_compatContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCREATE, 0)
}

func (s *Keyword_compatContext) CROSS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCROSS, 0)
}

func (s *Keyword_compatContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCURRENT, 0)
}

func (s *Keyword_compatContext) DATA() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDATA, 0)
}

func (s *Keyword_compatContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDATABASE, 0)
}

func (s *Keyword_compatContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDECIMAL, 0)
}

func (s *Keyword_compatContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDECLARE, 0)
}

func (s *Keyword_compatContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDEFAULT, 0)
}

func (s *Keyword_compatContext) DEFERRABLE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDEFERRABLE, 0)
}

func (s *Keyword_compatContext) DEFERRED() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDEFERRED, 0)
}

func (s *Keyword_compatContext) DEFINE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDEFINE, 0)
}

func (s *Keyword_compatContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDELETE, 0)
}

func (s *Keyword_compatContext) DESC() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDESC, 0)
}

func (s *Keyword_compatContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDESCRIBE, 0)
}

func (s *Keyword_compatContext) DETACH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDETACH, 0)
}

func (s *Keyword_compatContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDIRECTORY, 0)
}

func (s *Keyword_compatContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDISABLE, 0)
}

func (s *Keyword_compatContext) DISCARD() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDISCARD, 0)
}

func (s *Keyword_compatContext) DO() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDO, 0)
}

func (s *Keyword_compatContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDROP, 0)
}

func (s *Keyword_compatContext) EACH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEACH, 0)
}

func (s *Keyword_compatContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserELSE, 0)
}

func (s *Keyword_compatContext) EMPTY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEMPTY, 0)
}

func (s *Keyword_compatContext) ENCRYPTED() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserENCRYPTED, 0)
}

func (s *Keyword_compatContext) END() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEND, 0)
}

func (s *Keyword_compatContext) ERROR() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserERROR, 0)
}

func (s *Keyword_compatContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserESCAPE, 0)
}

func (s *Keyword_compatContext) EVALUATE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEVALUATE, 0)
}

func (s *Keyword_compatContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXCLUDE, 0)
}

func (s *Keyword_compatContext) EXCLUSION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXCLUSION, 0)
}

func (s *Keyword_compatContext) EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXCLUSIVE, 0)
}

func (s *Keyword_compatContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXPLAIN, 0)
}

func (s *Keyword_compatContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXPORT, 0)
}

func (s *Keyword_compatContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserEXTERNAL, 0)
}

func (s *Keyword_compatContext) FAIL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFAIL, 0)
}

func (s *Keyword_compatContext) FAMILY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFAMILY, 0)
}

func (s *Keyword_compatContext) FILTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFILTER, 0)
}

func (s *Keyword_compatContext) FIRST() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFIRST, 0)
}

func (s *Keyword_compatContext) FLATTEN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFLATTEN, 0)
}

func (s *Keyword_compatContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFOLLOWING, 0)
}

func (s *Keyword_compatContext) FOR() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFOR, 0)
}

func (s *Keyword_compatContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFOREIGN, 0)
}

func (s *Keyword_compatContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFUNCTION, 0)
}

func (s *Keyword_compatContext) GLOB() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGLOB, 0)
}

func (s *Keyword_compatContext) GRANT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGRANT, 0)
}

func (s *Keyword_compatContext) GROUP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGROUP, 0)
}

func (s *Keyword_compatContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserGROUPING, 0)
}

func (s *Keyword_compatContext) HASH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserHASH, 0)
}

func (s *Keyword_compatContext) IF() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIF, 0)
}

func (s *Keyword_compatContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIGNORE, 0)
}

func (s *Keyword_compatContext) ILIKE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserILIKE, 0)
}

func (s *Keyword_compatContext) IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIMMEDIATE, 0)
}

func (s *Keyword_compatContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIMPORT, 0)
}

func (s *Keyword_compatContext) IN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIN, 0)
}

func (s *Keyword_compatContext) INCREMENTAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINCREMENTAL, 0)
}

func (s *Keyword_compatContext) INDEX() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINDEX, 0)
}

func (s *Keyword_compatContext) INDEXED() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINDEXED, 0)
}

func (s *Keyword_compatContext) INHERITS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINHERITS, 0)
}

func (s *Keyword_compatContext) INITIAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINITIAL, 0)
}

func (s *Keyword_compatContext) INITIALLY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINITIALLY, 0)
}

func (s *Keyword_compatContext) INNER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINNER, 0)
}

func (s *Keyword_compatContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINSERT, 0)
}

func (s *Keyword_compatContext) INSTEAD() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINSTEAD, 0)
}

func (s *Keyword_compatContext) INTO() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINTO, 0)
}

func (s *Keyword_compatContext) IS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserIS, 0)
}

func (s *Keyword_compatContext) ISNULL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserISNULL, 0)
}

func (s *Keyword_compatContext) JOIN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserJOIN, 0)
}

func (s *Keyword_compatContext) KEY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserKEY, 0)
}

func (s *Keyword_compatContext) LAST() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLAST, 0)
}

func (s *Keyword_compatContext) LEFT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLEFT, 0)
}

func (s *Keyword_compatContext) LEGACY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLEGACY, 0)
}

func (s *Keyword_compatContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLIKE, 0)
}

func (s *Keyword_compatContext) MANAGE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMANAGE, 0)
}

func (s *Keyword_compatContext) MATCH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMATCH, 0)
}

func (s *Keyword_compatContext) MATCHES() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMATCHES, 0)
}

func (s *Keyword_compatContext) MATCH_RECOGNIZE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMATCH_RECOGNIZE, 0)
}

func (s *Keyword_compatContext) MEASURES() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMEASURES, 0)
}

func (s *Keyword_compatContext) MICROSECONDS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMICROSECONDS, 0)
}

func (s *Keyword_compatContext) MILLISECONDS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMILLISECONDS, 0)
}

func (s *Keyword_compatContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserMODIFY, 0)
}

func (s *Keyword_compatContext) NANOSECONDS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNANOSECONDS, 0)
}

func (s *Keyword_compatContext) NATURAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNATURAL, 0)
}

func (s *Keyword_compatContext) NEXT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNEXT, 0)
}

func (s *Keyword_compatContext) NO() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNO, 0)
}

func (s *Keyword_compatContext) NOTNULL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNOTNULL, 0)
}

func (s *Keyword_compatContext) NULLS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserNULLS, 0)
}

func (s *Keyword_compatContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOBJECT, 0)
}

func (s *Keyword_compatContext) OF() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOF, 0)
}

func (s *Keyword_compatContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOFFSET, 0)
}

func (s *Keyword_compatContext) OMIT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOMIT, 0)
}

func (s *Keyword_compatContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserON, 0)
}

func (s *Keyword_compatContext) ONE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserONE, 0)
}

func (s *Keyword_compatContext) ONLY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserONLY, 0)
}

func (s *Keyword_compatContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOPTION, 0)
}

func (s *Keyword_compatContext) OR() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOR, 0)
}

func (s *Keyword_compatContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserORDER, 0)
}

func (s *Keyword_compatContext) OTHERS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOTHERS, 0)
}

func (s *Keyword_compatContext) OUTER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOUTER, 0)
}

func (s *Keyword_compatContext) OVER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOVER, 0)
}

func (s *Keyword_compatContext) PARALLEL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPARALLEL, 0)
}

func (s *Keyword_compatContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPARTITION, 0)
}

func (s *Keyword_compatContext) PASSING() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPASSING, 0)
}

func (s *Keyword_compatContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPASSWORD, 0)
}

func (s *Keyword_compatContext) PAST() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPAST, 0)
}

func (s *Keyword_compatContext) PATTERN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPATTERN, 0)
}

func (s *Keyword_compatContext) PER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPER, 0)
}

func (s *Keyword_compatContext) PERMUTE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPERMUTE, 0)
}

func (s *Keyword_compatContext) PLAN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPLAN, 0)
}

func (s *Keyword_compatContext) POOL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPOOL, 0)
}

func (s *Keyword_compatContext) PRAGMA() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPRAGMA, 0)
}

func (s *Keyword_compatContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPRECEDING, 0)
}

func (s *Keyword_compatContext) PRESORT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPRESORT, 0)
}

func (s *Keyword_compatContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPRIMARY, 0)
}

func (s *Keyword_compatContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserPRIVILEGES, 0)
}

func (s *Keyword_compatContext) QUEUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserQUEUE, 0)
}

func (s *Keyword_compatContext) RAISE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRAISE, 0)
}

func (s *Keyword_compatContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREFERENCES, 0)
}

func (s *Keyword_compatContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREGEXP, 0)
}

func (s *Keyword_compatContext) REINDEX() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREINDEX, 0)
}

func (s *Keyword_compatContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRELEASE, 0)
}

func (s *Keyword_compatContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREMOVE, 0)
}

func (s *Keyword_compatContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRENAME, 0)
}

func (s *Keyword_compatContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREPLACE, 0)
}

func (s *Keyword_compatContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREPLICATION, 0)
}

func (s *Keyword_compatContext) RESET() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRESET, 0)
}

func (s *Keyword_compatContext) RESPECT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRESPECT, 0)
}

func (s *Keyword_compatContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRESTORE, 0)
}

func (s *Keyword_compatContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRESTRICT, 0)
}

func (s *Keyword_compatContext) RESULT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRESULT, 0)
}

func (s *Keyword_compatContext) REVERT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREVERT, 0)
}

func (s *Keyword_compatContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREVOKE, 0)
}

func (s *Keyword_compatContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRIGHT, 0)
}

func (s *Keyword_compatContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRLIKE, 0)
}

func (s *Keyword_compatContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserROLLBACK, 0)
}

func (s *Keyword_compatContext) ROW() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserROW, 0)
}

func (s *Keyword_compatContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSAMPLE, 0)
}

func (s *Keyword_compatContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSAVEPOINT, 0)
}

func (s *Keyword_compatContext) SECONDS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSECONDS, 0)
}

func (s *Keyword_compatContext) SEEK() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSEEK, 0)
}

func (s *Keyword_compatContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSEMI, 0)
}

func (s *Keyword_compatContext) SETS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSETS, 0)
}

func (s *Keyword_compatContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSHOW, 0)
}

func (s *Keyword_compatContext) TSKIP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTSKIP, 0)
}

func (s *Keyword_compatContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSOURCE, 0)
}

func (s *Keyword_compatContext) SUBQUERY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSUBQUERY, 0)
}

func (s *Keyword_compatContext) SUBSET() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSUBSET, 0)
}

func (s *Keyword_compatContext) SYMBOLS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSYMBOLS, 0)
}

func (s *Keyword_compatContext) SYNC() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSYNC, 0)
}

func (s *Keyword_compatContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSYSTEM, 0)
}

func (s *Keyword_compatContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTABLE, 0)
}

func (s *Keyword_compatContext) TABLES() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTABLES, 0)
}

func (s *Keyword_compatContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTABLESAMPLE, 0)
}

func (s *Keyword_compatContext) TABLESTORE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTABLESTORE, 0)
}

func (s *Keyword_compatContext) TEMP() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTEMP, 0)
}

func (s *Keyword_compatContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTEMPORARY, 0)
}

func (s *Keyword_compatContext) THEN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTHEN, 0)
}

func (s *Keyword_compatContext) TIES() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTIES, 0)
}

func (s *Keyword_compatContext) TO() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTO, 0)
}

func (s *Keyword_compatContext) TOPIC() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTOPIC, 0)
}

func (s *Keyword_compatContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTRANSACTION, 0)
}

func (s *Keyword_compatContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTRIGGER, 0)
}

func (s *Keyword_compatContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTYPE, 0)
}

func (s *Keyword_compatContext) UNCONDITIONAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUNCONDITIONAL, 0)
}

func (s *Keyword_compatContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUNIQUE, 0)
}

func (s *Keyword_compatContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUNKNOWN, 0)
}

func (s *Keyword_compatContext) UNMATCHED() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUNMATCHED, 0)
}

func (s *Keyword_compatContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUPDATE, 0)
}

func (s *Keyword_compatContext) UPSERT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUPSERT, 0)
}

func (s *Keyword_compatContext) USE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUSE, 0)
}

func (s *Keyword_compatContext) USER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUSER, 0)
}

func (s *Keyword_compatContext) USING() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserUSING, 0)
}

func (s *Keyword_compatContext) VACUUM() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserVACUUM, 0)
}

func (s *Keyword_compatContext) VALUES() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserVALUES, 0)
}

func (s *Keyword_compatContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserVIEW, 0)
}

func (s *Keyword_compatContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserVIRTUAL, 0)
}

func (s *Keyword_compatContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWITH, 0)
}

func (s *Keyword_compatContext) WRAPPER() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserWRAPPER, 0)
}

func (s *Keyword_compatContext) XOR() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserXOR, 0)
}

func (s *Keyword_compatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Keyword_compatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Keyword_compatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterKeyword_compat(s)
	}
}

func (s *Keyword_compatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitKeyword_compat(s)
	}
}

func (p *SQLv1Antlr4Parser) Keyword_compat() (localctx IKeyword_compatContext) {
	localctx = NewKeyword_compatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 842, SQLv1Antlr4ParserRULE_keyword_compat)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4466)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-43)) & ^0x3f) == 0 && ((int64(1)<<(_la-43))&-16327067659430417) != 0) || ((int64((_la-107)) & ^0x3f) == 0 && ((int64(1)<<(_la-107))&-920034089209925) != 0) || ((int64((_la-171)) & ^0x3f) == 0 && ((int64(1)<<(_la-171))&-4611688220135113155) != 0) || ((int64((_la-235)) & ^0x3f) == 0 && ((int64(1)<<(_la-235))&-6922071154367406599) != 0) || ((int64((_la-300)) & ^0x3f) == 0 && ((int64(1)<<(_la-300))&3436541) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_idContext is an interface to support dynamic dispatch.
type IType_idContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPTIONAL() antlr.TerminalNode
	TUPLE() antlr.TerminalNode
	STRUCT() antlr.TerminalNode
	VARIANT() antlr.TerminalNode
	LIST() antlr.TerminalNode
	FLOW() antlr.TerminalNode
	DICT() antlr.TerminalNode
	SET() antlr.TerminalNode
	ENUM() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	TAGGED() antlr.TerminalNode
	CALLABLE() antlr.TerminalNode

	// IsType_idContext differentiates from other interfaces.
	IsType_idContext()
}

type Type_idContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_idContext() *Type_idContext {
	var p = new(Type_idContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_id
	return p
}

func InitEmptyType_idContext(p *Type_idContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_id
}

func (*Type_idContext) IsType_idContext() {}

func NewType_idContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_idContext {
	var p = new(Type_idContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_type_id

	return p
}

func (s *Type_idContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_idContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserOPTIONAL, 0)
}

func (s *Type_idContext) TUPLE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTUPLE, 0)
}

func (s *Type_idContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSTRUCT, 0)
}

func (s *Type_idContext) VARIANT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserVARIANT, 0)
}

func (s *Type_idContext) LIST() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserLIST, 0)
}

func (s *Type_idContext) FLOW() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFLOW, 0)
}

func (s *Type_idContext) DICT() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDICT, 0)
}

func (s *Type_idContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserSET, 0)
}

func (s *Type_idContext) ENUM() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserENUM, 0)
}

func (s *Type_idContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserRESOURCE, 0)
}

func (s *Type_idContext) TAGGED() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTAGGED, 0)
}

func (s *Type_idContext) CALLABLE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserCALLABLE, 0)
}

func (s *Type_idContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_idContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_idContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterType_id(s)
	}
}

func (s *Type_idContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitType_id(s)
	}
}

func (p *SQLv1Antlr4Parser) Type_id() (localctx IType_idContext) {
	localctx = NewType_idContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 844, SQLv1Antlr4ParserRULE_type_id)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4468)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&1126037345796097) != 0) || _la == SQLv1Antlr4ParserFLOW || _la == SQLv1Antlr4ParserLIST || ((int64((_la-212)) & ^0x3f) == 0 && ((int64(1)<<(_la-212))&288230444871188481) != 0) || ((int64((_la-276)) & ^0x3f) == 0 && ((int64(1)<<(_la-276))&68721575937) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBool_valueContext is an interface to support dynamic dispatch.
type IBool_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBool_valueContext differentiates from other interfaces.
	IsBool_valueContext()
}

type Bool_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_valueContext() *Bool_valueContext {
	var p = new(Bool_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_bool_value
	return p
}

func InitEmptyBool_valueContext(p *Bool_valueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_bool_value
}

func (*Bool_valueContext) IsBool_valueContext() {}

func NewBool_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_valueContext {
	var p = new(Bool_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_bool_value

	return p
}

func (s *Bool_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_valueContext) TRUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserTRUE, 0)
}

func (s *Bool_valueContext) FALSE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserFALSE, 0)
}

func (s *Bool_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterBool_value(s)
	}
}

func (s *Bool_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitBool_value(s)
	}
}

func (p *SQLv1Antlr4Parser) Bool_value() (localctx IBool_valueContext) {
	localctx = NewBool_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 846, SQLv1Antlr4ParserRULE_bool_value)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4470)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLv1Antlr4ParserFALSE || _la == SQLv1Antlr4ParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRealContext is an interface to support dynamic dispatch.
type IRealContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REAL() antlr.TerminalNode

	// IsRealContext differentiates from other interfaces.
	IsRealContext()
}

type RealContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRealContext() *RealContext {
	var p = new(RealContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_real
	return p
}

func InitEmptyRealContext(p *RealContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_real
}

func (*RealContext) IsRealContext() {}

func NewRealContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RealContext {
	var p = new(RealContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_real

	return p
}

func (s *RealContext) GetParser() antlr.Parser { return s.parser }

func (s *RealContext) REAL() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserREAL, 0)
}

func (s *RealContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RealContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RealContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterReal(s)
	}
}

func (s *RealContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitReal(s)
	}
}

func (p *SQLv1Antlr4Parser) Real_() (localctx IRealContext) {
	localctx = NewRealContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 848, SQLv1Antlr4ParserRULE_real)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4472)
		p.Match(SQLv1Antlr4ParserREAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntegerContext is an interface to support dynamic dispatch.
type IIntegerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DIGITS() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsIntegerContext differentiates from other interfaces.
	IsIntegerContext()
}

type IntegerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerContext() *IntegerContext {
	var p = new(IntegerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_integer
	return p
}

func InitEmptyIntegerContext(p *IntegerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLv1Antlr4ParserRULE_integer
}

func (*IntegerContext) IsIntegerContext() {}

func NewIntegerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerContext {
	var p = new(IntegerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLv1Antlr4ParserRULE_integer

	return p
}

func (s *IntegerContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerContext) DIGITS() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserDIGITS, 0)
}

func (s *IntegerContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLv1Antlr4ParserINTEGER_VALUE, 0)
}

func (s *IntegerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.EnterInteger(s)
	}
}

func (s *IntegerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLv1Antlr4Listener); ok {
		listenerT.ExitInteger(s)
	}
}

func (p *SQLv1Antlr4Parser) Integer() (localctx IIntegerContext) {
	localctx = NewIntegerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 850, SQLv1Antlr4ParserRULE_integer)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4474)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLv1Antlr4ParserDIGITS || _la == SQLv1Antlr4ParserINTEGER_VALUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}
